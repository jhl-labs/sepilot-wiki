{
  "generatedAt": "2026-03-01T09:08:50.533Z",
  "summary": {
    "sourceFiles": 245,
    "packages": 58,
    "existingDocs": 98,
    "gapsFound": 10,
    "issuesCreated": 3
  },
  "techStack": {
    "imports": [
      "@auth/core",
      "@cp949/react-wordcloud",
      "@monaco-editor/react",
      "@octokit/rest",
      "@tanstack/react-query",
      "@tanstack/react-virtual",
      "@types/dompurify",
      "clsx",
      "date-fns",
      "dompurify",
      "fuse.js",
      "gray-matter",
      "ioredis",
      "lucide-react",
      "mermaid",
      "monaco-editor",
      "next",
      "next-auth",
      "node-cron",
      "plotly.js",
      "react",
      "react-dom",
      "react-markdown",
      "react-plotly.js",
      "react-router-dom",
      "react-syntax-highlighter",
      "rehype-raw",
      "rehype-sanitize",
      "remark-gfm",
      "@eslint/js",
      "@playwright/test",
      "@testing-library/dom",
      "@testing-library/jest-dom",
      "@testing-library/react",
      "@testing-library/user-event",
      "@types/node",
      "@types/node-cron",
      "@types/plotly.js",
      "@types/react",
      "@types/react-dom",
      "@types/react-plotly.js",
      "@types/react-syntax-highlighter",
      "@typescript-eslint/eslint-plugin",
      "@typescript-eslint/parser",
      "@vitejs/plugin-react",
      "@vitest/coverage-v8",
      "eslint",
      "eslint-config-next",
      "eslint-plugin-react-hooks",
      "eslint-plugin-react-refresh",
      "globals",
      "husky",
      "jsdom",
      "typescript",
      "typescript-eslint",
      "vite",
      "vite-plugin-pwa",
      "vitest"
    ],
    "frameworks": [],
    "patterns": [],
    "configs": [
      "codecov.yml"
    ]
  },
  "gaps": [
    {
      "topic": "@tanstack/react-query 를 활용한 데이터 패칭·캐싱 전략",
      "importance": "high",
      "reason": "React‑Query는 클라이언트‑사이드 데이터 페칭, 캐싱, 자동 재시도, 백그라운드 업데이트 등 핵심 비즈니스 로직을 담당합니다. 사용 패턴, 쿼리 키 설계, 무효화 전략을 문서화하지 않으면 유지보수 비용이 급증합니다.",
      "suggestedTitle": "[문서] React‑Query 기반 데이터 패칭·캐싱 베스트 프랙티스",
      "relatedTech": [
        "@tanstack/react-query",
        "react",
        "typescript"
      ],
      "issueCreated": 327
    },
    {
      "topic": "monaco‑editor/react 를 이용한 인라인 코드 편집기 구현",
      "importance": "high",
      "reason": "Monaco Editor는 프로젝트 내 코드·쿼리 편집 UI의 핵심 컴포넌트이며, 언어 서비스, 테마, 파일 시스템 연동, 보안(예: XSS 방지) 설정이 복잡합니다. 개발자 경험을 일관되게 유지하려면 상세 가이드가 필요합니다.",
      "suggestedTitle": "[문서] monaco‑editor/react 기반 인라인 코드 편집기 구현 가이드",
      "relatedTech": [
        "@monaco-editor/react",
        "monaco-editor",
        "react"
      ],
      "issueCreated": 328
    },
    {
      "topic": "vite-plugin-pwa 로 PWA(오프라인) 지원 설정",
      "importance": "high",
      "reason": "프로덕션 배포 시 오프라인 캐시, 서비스 워커, 매니페스트 관리가 핵심이며, 잘못된 설정은 업데이트 실패·보안 이슈를 초래합니다. 빌드 단계, 캐시 전략, 업데이트 알림 흐름을 문서화해야 합니다.",
      "suggestedTitle": "[문서] vite-plugin-pwa 로 PWA 설정 및 배포 가이드",
      "relatedTech": [
        "vite",
        "vite-plugin-pwa"
      ],
      "issueCreated": 329
    },
    {
      "topic": "Playwright + Vitest 기반 E2E·유닛 테스트 전략",
      "importance": "high",
      "reason": "프로젝트는 Playwright, Vitest, Testing Library 로 테스트 파이프라인을 구축하고 있습니다. 테스트 구조, CI 연동, 스냅샷 관리, 테스트 데이터 정리 방안을 문서화하지 않으면 테스트 신뢰성이 떨어집니다.",
      "suggestedTitle": "[문서] Playwright·Vitest 테스트 파이프라인 설계 및 운영 매뉴얼",
      "relatedTech": [
        "@playwright/test",
        "vitest",
        "@testing-library/react",
        "github actions"
      ],
      "issueCreated": null
    },
    {
      "topic": "Plotly.js 및 react‑plotly.js 를 활용한 인터랙티브 차트 구현",
      "importance": "medium",
      "reason": "데이터 시각화는 제품 핵심 UI 요소이며, 차트 옵션, 레이아웃 관리, 성능 최적화, 접근성(ARIA) 설정을 문서화하지 않으면 일관된 UI 제공이 어려워집니다.",
      "suggestedTitle": "[문서] Plotly.js와 react‑plotly.js 로 인터랙티브 차트 만들기",
      "relatedTech": [
        "plotly.js",
        "react-plotly.js",
        "react"
      ],
      "issueCreated": null
    },
    {
      "topic": "@tanstack/react-virtual 로 가상 리스트·그리드 구현",
      "importance": "medium",
      "reason": "대용량 리스트 렌더링 시 성능 최적화가 필수이며, 아이템 사이즈 측정, 스크롤 동기화, 서버 사이드 페이징과의 연동 방법을 문서화해야 개발자가 올바르게 활용할 수 있습니다.",
      "suggestedTitle": "[문서] react‑virtual 로 가상 리스트·그리드 구현 가이드",
      "relatedTech": [
        "@tanstack/react-virtual",
        "react"
      ],
      "issueCreated": null
    },
    {
      "topic": "codecov.yml 로 코드 커버리지 보고서 자동화",
      "importance": "medium",
      "reason": "CI/CD 파이프라인에서 커버리지 기준을 enforce 하는 방법, 커버리지 임계값, PR 주석 자동화 등을 명시하지 않으면 품질 관리가 어려워집니다.",
      "suggestedTitle": "[문서] codecov.yml 로 코드 커버리지 자동화 및 정책 설정",
      "relatedTech": [
        "codecov.yml",
        "github actions",
        "vitest",
        "eslint"
      ],
      "issueCreated": null
    },
    {
      "topic": "NextAuth & @auth/core 기반 인증·인가 구현",
      "importance": "critical",
      "reason": "프로젝트는 next‑auth와 @auth/core 로 사용자 인증·세션 관리를 수행합니다. 인증 흐름, 토큰 보안, 세션 스토어, OAuth·SSO 설정 등은 보안 사고를 방지하기 위해 반드시 문서화돼야 합니다.",
      "suggestedTitle": "[문서] NextAuth와 @auth/core을 이용한 인증·인가 가이드",
      "relatedTech": [
        "next-auth",
        "@auth/core",
        "next",
        "ioredis"
      ],
      "issueCreated": null
    },
    {
      "topic": "ioredis 기반 캐시·세션 스토어 설계",
      "importance": "critical",
      "reason": "Redis는 인증 토큰, 세션, 레이트‑리밋 등 보안·성능에 직접적인 영향을 미칩니다. 연결 옵션, 클러스터/레플리카 구성, TTL 정책, 오류 복구 방안을 문서화해야 운영 중 장애를 최소화할 수 있습니다.",
      "suggestedTitle": "[문서] ioredis를 이용한 캐시·세션 스토어 설계 및 운영 가이드",
      "relatedTech": [
        "ioredis",
        "next-auth",
        "node"
      ],
      "issueCreated": null
    },
    {
      "topic": "react‑markdown + remark‑gfm + rehype‑raw/rehype‑sanitize 를 이용한 마크다운 렌더링 파이프라인",
      "importance": "critical",
      "reason": "사용자 입력 마크다운을 HTML 로 변환하는 과정에서 XSS 위험이 존재합니다. 허용 태그/속성, sanitization 옵션, GFM 확장 사용법 등을 명시하지 않으면 보안 취약점이 발생합니다.",
      "suggestedTitle": "[문서] 안전한 마크다운 렌더링: react‑markdown, remark‑gfm, rehype‑raw/rehype‑sanitize 사용법",
      "relatedTech": [
        "react-markdown",
        "remark-gfm",
        "rehype-raw",
        "rehype-sanitize"
      ],
      "issueCreated": null
    }
  ]
}