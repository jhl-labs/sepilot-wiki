[
  {
    "title": "Sepilot Wiki가 어떤 언어/프레임워크로 구현되어 있나요?",
    "slug": "projects/technology-stack",
    "content": "기술 스택\nSEPilot Wiki는 다음과 같은 기술 스택으로 구현되어 있습니다:\n프론트엔드\nReact 18 - UI 라이브러리\nTypeScript - 타입 안전성을 위한 정적 타입 언어\nVite - 빌드 도구 및 개발 서버\nReact Router DOM - SPA 라우팅\nTanStack Query (React Query) - 서버 상태 관리\nNext.js 사용 여부\nSEPilot Wiki는 Next.js를 사용하지 않습니다.\n대신 Vite와 React를 조합하여 클라이언트 사이드 렌더링 SPA 형태로 구현되었습니다.\nNext.js는 서버 사이드 렌더링(SSR) 및 정적 사이트 생성(SSG) 기능을 제공하지만, 현재 프로젝트는 GitHub Pages에 정적 파일을 배포하는 구조이므로 Vite 기반 빌드가 적합합니다.\n필요 시 향후 SSR이나 SSG가 요구될 경우 Next.js로 마이그레이션을 고려할 수 있습니다.\n마크다운 렌더링\nreact-markdown - 마크다운 파싱 및 렌더링\nremark-gfm - GitHub Flavored Markdown 지원\nrehype-raw - HTML 태그 지원\nrehype-sanitize - XSS 방지를 위한 HTML 살균\nreact-syntax-highlighter - 코드 구문 강조\n스타일링\nCSS Variables - 테마 시스템\nLucide React - 아이콘 라이브러리\n개발 도구\nESLint - 코드 린팅\nVitest - 테스트 프레임워크\nHusky - Git hooks\nCI/CD\nGitHub Actions - 자동화 워크플로우\nGitHub Pages - 정적 사이트 호스팅\nBun - 패키지 매니저 및 런타임\nAI 통합\nOpenAI API 호환 - LLM을 통한 문서 자동 생성\n참고 링크\nSEPilot Wiki GitHub Repository",
    "excerpt": "기술 스택\nSEPilot Wiki는 다음과 같은 기술 스택으로 구현되어 있습니다:\n프론트엔드\nReact 18 - UI 라이브러리\nTypeScript - 타입 안전성을 위한 정적 타입 언어\nVite - 빌드 도구 및 개발 서버\nReact Router DOM - SPA 라우팅\nTanStack Query (React Query) - 서버 상태 관리\nNext.js...",
    "tags": [
      "sepilot-wiki",
      "기술스택",
      "React",
      "TypeScript",
      "Vite"
    ],
    "lastModified": "2025-12-07T06:05:44Z",
    "author": "SEPilot AI"
  },
  {
    "title": "SEPilot Desktop 소개",
    "slug": "projects/sepilot-desktop-introduction",
    "content": "SEPilot Desktop 소개\nSEPilot Desktop은 오픈소스 LLM 기반 데스크톱 애플리케이션으로, Chat, Editor, Browser 세 가지 모드를 제공하여 강력하고 유연한 AI 워크플로우를 지원합니다. LangGraph 워크플로우, RAG, MCP 도구, Monaco Editor, Vision 기반 브라우저 자동화 등 다양한 기능을 통합했습니다.\n📦 다운로드 & 소스\n다운로드: SEPilot Desktop 다운로드\nGitHub: GitHub 저장소\n데모 영상: assets/videos/demo-main.mp4\n🧭 3가지 애플리케이션 모드\nChat 모드\nAI와 대화하고 질문할 수 있습니다.\nLangGraph 워크플로우 (Instant, Sequential, Deep, Coding, RAG, Browser 등 6가지)\nRAG 문서 검색 & 편집, 폴더 관리, Export/Import\nMCP 도구 통합 (GitHub, Brave Search, Filesystem 등)\n이미지 생성 & 해석 (ComfyUI, Vision API)\nPersona 시스템 (AI 역할 정의, SQLite 영구 저장)\nQuick Question (최대 5개 단축키)\nGitHub Sync (AES‑256‑GCM 암호화)\n데모: assets/videos/chat-mode-demo.mp4\nEditor 모드\n코드 작성 및 파일 관리에 최적화된 환경입니다.\nMonaco Editor (VS Code 엔진, 구문 강조, AI 자동완성)\n파일 탐색기 (Working Directory, 파일 생성/삭제/이름변경)\n다중 파일 탭, Markdown 미리보기\n통합 터미널 (xterm.js, PowerShell/bash/zsh, 탭 관리)\n전체 파일 검색 (ripgrep 기반, Ctrl+Shift+F)\nAdvanced Editor Agent (50회 반복, 9개 Built‑in Tools)\n10가지 Notion 스타일 Writing Tools\n데모: assets/videos/editor-mode-demo.mp4\nBrowser 모드\nAI와 함께 웹을 탐색하고 자동화합니다.\nChromium 기반 브라우저 (BrowserView, Chrome 스타일 탭)\n18개 자동화 도구 (Navigate, DOM Inspection, Vision Tools 등)\nGoogle Search Tools (검색, 뉴스, Scholar, 이미지, 고급 필터)\nVision 기반 UI 제어 (Set‑of‑Mark, 좌표 클릭)\nBot 감지 우회 (Stealth Fingerprint, 자연스러운 타이밍)\n페이지 캡처 (MHTML + 스크린샷, 오프라인 뷰어)\n북마크 관리 (폴더별 정리)\n데모: assets/videos/browser-mode-demo.mp4\n🌟 주요 기능\nLangGraph 워크플로우\n다양한 사고(Thinking) 모드 지원: Instant, Sequential, Tree‑of‑Thought, Deep 등. 실시간 스트리밍으로 사고 과정 시각화 및 conversationId 기반 격리.\nAI Persona 시스템 (v0.6.0)\n기본 페르소나: 일반 어시스턴트, 번역가, 영어 선생님, 시니어 개발자\n사용자 정의 페르소나 추가/수정/삭제\n슬래시 커맨드 자동완성 (/persona)\nSQLite 기반 영구 저장\nRAG (검색 증강 생성)\n텍스트, URL, 파일(PDF, DOCX, TXT, MD) 업로드 지원\nSQLite‑vec, OpenSearch, Elasticsearch, pgvector 지원\n문서 편집 AI (정제, 확장, 축약, 검증, 커스텀 프롬프트)\n폴더 구조 관리 (드래그 앤 드롭, Tree/List/Grid 뷰)\nExport/Import (JSON 형식, 백업/복원)\n데모: assets/videos/rag-demo.gif\n브라우저 자동화 (v0.6.0)\nElectron BrowserView 기반 Chromium 통합\nVision 기반 UI 제어 및 Google Search Tools\nDOM Inspection, Vision Tools, Bot 감지 우회 등 27개 도구\n데모: assets/videos/browser-automation.gif\nMCP 프로토콜\nModel Context Protocol을 통한 도구 및 컨텍스트 표준화\nGitHub, Brave Search, Git, Filesystem 등 템플릿 제공\n환경 변수 UI 설정, 실행 전 사용자 승인 (5분 타임아웃)\n데모: assets/videos/mcp-tools.gif\nGitHub Sync (v0.6.0)\nPersonal Access Token 기반 안전한 데이터 동기화\nAES‑256‑GCM 암호화로 민감 정보 보호\n설정, 문서, 페르소나, 이미지, 대화 내역 동기화\n데모: assets/videos/github-sync.gif\n이미지 기능\nComfyUI 통합 이미지 생성\nVision API 기반 이미지 해석 및 질의응답\n데모: assets/videos/image-generation.gif\n🛠️ 기술 스택\n프론트엔드: Next.js 15.3, React 19, TypeScript 5.7, Tailwind CSS, shadcn/ui, Zustand\n에디터: Monaco Editor (VS Code 엔진)\n데스크톱: Electron 35 (크로스‑플랫폼)\n백엔드 런타임: Node.js 20+\n데이터베이스: better‑sqlite3, SQLite‑vec (벡터 검색)\nIPC: Context Bridge (안전한 통신)\nLLM & AI: LangGraph, LangChain, OpenAI, Anthropic, Google, Groq, MCP Protocol, ComfyUI\n🚀 빠른 시작 (5분 안에 시작)\n다운로드 및 설치\n   - Windows: \n   - macOS: \n   - Linux: \nLLM 설정\n   - 좌측 하단 설정 아이콘 → LLM 제공자 및 API 키 입력\n   - 지원: OpenAI, Anthropic, Google, Custom (OpenAI‑compatible)\n모드 및 그래프 선택\n   - Chat, Editor, Browser 중 선택\n   - 필요 시 LangGraph 워크플로우 타입 선택 (Instant, RAG, Agent 등)\n대화 시작\n   - 준비가 완료되면 AI와 대화를 시작하세요!\n📋 시스템 요구사항\n최소: Node.js 20.9+, 4 GB RAM, 500 MB 디스크\n권장: Node.js 22+, 8 GB RAM, 1 GB 디스크\n이 문서는 초안(draft) 상태이며, 검토 후  로 전환될 예정입니다.",
    "excerpt": "SEPilot Desktop 소개\nSEPilot Desktop은 오픈소스 LLM 기반 데스크톱 애플리케이션으로, Chat, Editor, Browser 세 가지 모드를 제공하여 강력하고 유연한 AI 워크플로우를 지원합니다. LangGraph 워크플로우, RAG, MCP 도구, Monaco Editor, Vision 기반 브라우저 자동화 등 다양한 기능을 통...",
    "tags": [
      "SEPilot",
      "Desktop",
      "LLM",
      "Project"
    ],
    "lastModified": "2025-12-07T06:05:44Z",
    "author": "github-actions[bot]"
  },
  {
    "title": "테마 커스터마이징",
    "slug": "guide/theme-customization",
    "content": "테마 커스터마이징\nSEPilot Wiki는 Astro와 유사하게 설정 파일을 통해 다양한 커스터마이징을 지원합니다.\n설정 파일 구조\n사이트 설정 (site.config.ts)\n기본 정보\n로고 설정\nFooter 설정\n테마 설정 (theme.config.ts)\n색상 커스터마이징\n폰트 설정\n레이아웃 설정\n커스텀 CSS\n에서 추가 스타일을 정의할 수 있습니다:\n네비게이션 설정 (navigation.config.ts)\n사이드바에 커스텀 메뉴를 추가합니다:\n지원하는 lucide 아이콘\nlucide.dev/icons에서 사용 가능한 아이콘 이름을 확인할 수 있습니다.\n예: , , , , ,  등",
    "excerpt": "테마 커스터마이징\nSEPilot Wiki는 Astro와 유사하게 설정 파일을 통해 다양한 커스터마이징을 지원합니다.\n설정 파일 구조\n사이트 설정 (site.config.ts)\n기본 정보\n로고 설정\nFooter 설정\n테마 설정 (theme.config.ts)\n색상 커스터마이징\n폰트 설정\n레이아웃 설정\n커스텀 CSS\n에서 추가 스타일을 정의할 수 있습니다:\n네...",
    "tags": [
      "테마",
      "커스터마이징",
      "설정"
    ],
    "lastModified": "2025-12-07T06:05:44Z",
    "author": "github-actions[bot]"
  },
  {
    "title": "시작하기",
    "slug": "guide/getting-started",
    "content": "시작하기\nSEPilot Wiki를 사용하여 나만의 위키를 만드는 방법을 안내합니다.\n설치 및 배포\n템플릿 복제\n의존성 설치 및 개발 서버 실행\n설정 파일 수정\n루트 디렉토리의 설정 파일들을 수정합니다:\n- 사이트 기본 정보 (타이틀, 로고, 소셜 링크)\n- 테마 설정 (색상, 폰트, 레이아웃)\n- 사이드바 메뉴 설정\nGitHub Pages 배포\nGitHub Actions가 자동으로 빌드 후 GitHub Pages에 배포합니다.\n문서 작성 방식\n방법 1: 직접 작성\n 폴더에 마크다운 파일을 직접 추가합니다.\n방법 2: AI 자동 생성\nGitHub Issue에  라벨을 추가하면 AI가 문서 초안을 자동 생성합니다.\n다음 단계\n테마 커스터마이징 - 색상, 폰트, 로고 변경\n다이어그램 및 차트 - Mermaid 및 Plotly 사용법\nLLM 워크플로우 - AI 문서 생성 과정 이해\n설정 파일 가이드 - 상세 설정 옵션",
    "excerpt": "시작하기\nSEPilot Wiki를 사용하여 나만의 위키를 만드는 방법을 안내합니다.\n설치 및 배포\n템플릿 복제\n의존성 설치 및 개발 서버 실행\n설정 파일 수정\n루트 디렉토리의 설정 파일들을 수정합니다:\n- 사이트 기본 정보 (타이틀, 로고, 소셜 링크)\n- 테마 설정 (색상, 폰트, 레이아웃)\n- 사이드바 메뉴 설정\nGitHub Pages 배포\nGitHub...",
    "tags": [
      "시작하기",
      "설치",
      "배포"
    ],
    "lastModified": "2025-12-07T06:05:44Z",
    "author": "github-actions[bot]"
  },
  {
    "title": "FAQ",
    "slug": "guide/faq",
    "content": "FAQ\nSEPilot Wiki 사용에 관한 자주 묻는 질문과 답변입니다.\n일반\nSEPilot Wiki란 무엇인가요?\nSEPilot Wiki는 AI 에이전트 기반의 자동화된 위키 시스템입니다. GitHub 저장소의  폴더를 데이터 저장소로 활용하고, GitHub Issues를 통해 사용자와 소통하며, AI가 문서를 자동으로 생성/수정/유지보수합니다.\n어떤 기술 스택을 사용하나요?\nFrontend: React 18 + TypeScript + Vite\nState Management: TanStack Query\nRouting: React Router 7\nHosting: GitHub Pages\nCI/CD: GitHub Actions\n문서 작성\nAI에게 문서 작성을 요청하려면 어떻게 하나요?\nGitHub Issues에서 새 이슈를 생성합니다\n라벨을 추가합니다\n이슈 본문에 원하는 문서의 내용을 설명합니다\nAI가 자동으로 문서 초안을 작성합니다\n직접 문서를 추가하려면 어떻게 하나요?\n 폴더에 마크다운 파일을 직접 추가할 수 있습니다:\n문서 수정을 요청하려면 어떻게 하나요?\n해당 문서와 관련된 이슈에 댓글로 수정 사항을 작성하면 AI가 피드백을 반영하여 문서를 업데이트합니다.\n기능\n검색은 어떻게 작동하나요?\nFuse.js 기반의 전문 검색(Full-text search)을 지원합니다. 문서 제목, 내용, 태그 등을 대상으로 검색하며, 2자 이상 입력 시 검색이 시작됩니다.\n다크 모드를 지원하나요?\n예, 라이트/다크/시스템 테마를 지원합니다. 우측 상단의 테마 토글 버튼으로 변경할 수 있습니다.\nMermaid 다이어그램을 사용할 수 있나요?\n예, 마크다운 코드 블록에서  언어를 지정하면 다이어그램이 렌더링됩니다:\nmarkdown\nPlotly 차트도 지원하나요?\n예,  코드 블록으로 인터랙티브 차트를 추가할 수 있습니다:\nmarkdown\n문제 해결\n페이지가 404 오류를 표시합니다\nGitHub Pages의 SPA 라우팅 특성상, 직접 URL 접근 시 404가 발생할 수 있습니다. 새로고침하거나 홈페이지에서 네비게이션을 통해 접근해 보세요.\n문서가 목록에 표시되지 않습니다\n프론트매터의 가 인지 확인하세요\n파일 확장자가 인지 확인하세요\nGitHub Actions 배포가 완료되었는지 확인하세요 (약 2-3분 소요)\nAI가 문서를 생성하지 않습니다\n이슈에  라벨이 추가되었는지 확인하세요\nGitHub Actions 워크플로우가 활성화되어 있는지 확인하세요\n워크플로우 실행 로그에서 오류를 확인하세요\n기여\n프로젝트에 기여하려면 어떻게 하나요?\n이슈를 통해 기능 제안 또는 버그 리포트\n라벨로 문서 작성 요청\nPR을 통한 직접 코드 기여\n코드 스타일 가이드가 있나요?\nESLint + Prettier 설정을 준수합니다\nTypeScript strict 모드를 사용합니다\n커밋 전  검사를 통과해야 합니다",
    "excerpt": "FAQ\nSEPilot Wiki 사용에 관한 자주 묻는 질문과 답변입니다.\n일반\nSEPilot Wiki란 무엇인가요?\nSEPilot Wiki는 AI 에이전트 기반의 자동화된 위키 시스템입니다. GitHub 저장소의  폴더를 데이터 저장소로 활용하고, GitHub Issues를 통해 사용자와 소통하며, AI가 문서를 자동으로 생성/수정/유지보수합니다.\n어떤 기...",
    "tags": [
      "FAQ",
      "가이드",
      "도움말"
    ],
    "lastModified": "2025-12-07T06:05:44Z",
    "author": "github-actions[bot]"
  },
  {
    "title": "다이어그램 및 차트 사용 가이드",
    "slug": "guide/diagrams-guide",
    "content": "다이어그램 및 차트 사용 가이드\nSEPilot Wiki는 복잡한 아이디어와 데이터를 시각화하기 위해 Mermaid와 Plotly를 지원합니다.\n마크다운 코드 블록을 사용하여 간편하게 다이어그램과 차트를 그릴 수 있습니다.\nMermaid 다이어그램\n 언어로 코드 블록을 작성하면 자동으로 다이어그램으로 렌더링됩니다.\n플로우차트 (Flowchart)\nmermaid\ngraph TD;\n    Start-->Stop;\n    Start-->Progress;\n    Progress-->Stop;\n클래스 다이어그램 (Class Diagram)\nmermaid\nclassDiagram\n    Animal < -- Duck\n    Animal < -- Fish\n    Animal < -- Zebra\n    Animal : +int age\n    Animal : +String gender\n    Animal: +isMammal()\n    Animal: +mate()\n    class Duck{\n        +String beakColor\n        +swim()\n        +quack()\n    }\n    class Fish{\n        -int sizeInFeet\n        -canEat()\n    }\n    class Zebra{\n        +bool is_wild\n        +run()\n    }\nplotlymarkdown\n`\n문법 강조 (Syntax Highlighting)\n다양한 프로그래밍 언어의 문법 강조를 지원합니다.",
    "excerpt": "다이어그램 및 차트 사용 가이드\nSEPilot Wiki는 복잡한 아이디어와 데이터를 시각화하기 위해 Mermaid와 Plotly를 지원합니다.\n마크다운 코드 블록을 사용하여 간편하게 다이어그램과 차트를 그릴 수 있습니다.\nMermaid 다이어그램\n 언어로 코드 블록을 작성하면 자동으로 다이어그램으로 렌더링됩니다.\n플로우차트 (Flowchart)\nmermai...",
    "tags": [
      "mermaid",
      "plotly",
      "차트",
      "다이어그램",
      "사용법"
    ],
    "lastModified": "2025-12-07T06:05:44Z",
    "author": "github-actions[bot]"
  },
  {
    "title": "LLM 워크플로우",
    "slug": "guide/llm-workflow",
    "content": "LLM 워크플로우\nSEPilot Wiki는 GitHub Actions와 LLM을 연동하여 자동으로 문서를 생성하고 관리합니다.\n워크플로우 개요\n지원하는 이벤트\nrequest 라벨 추가\nIssue에  라벨을 추가하면:\nAI가 Issue 제목과 본문을 분석\n관련 문서 초안 자동 생성\n폴더에 마크다운 파일 저장\nIssue에 결과 댓글 추가\n,  라벨 자동 추가\ninvalid 라벨 추가\n문서에 오류가 있을 때  라벨을 추가하면:\nAI가 Issue 댓글에서 오류 내용 파악\n해당 문서 자동 수정\n수정 결과 댓글로 알림\nMaintainer 댓글\nMaintainer가 댓글을 달면:\nAI가 댓글 내용 분석\n문서 수정, 삭제, 복구 등 작업 수행\n작업 결과 댓글로 알림\nIssue 종료\nIssue를 close하면:\n라벨 제거\n문서가 정식 게시 상태로 전환\nLLM 설정\n환경 변수\nGitHub Repository Secrets에 다음 값을 설정합니다:\n지원하는 LLM 제공자\nOpenAI 호환 API를 사용하는 모든 제공자를 지원합니다:\nOpenAI (GPT-4, GPT-3.5)\nAzure OpenAI\nAnthropic Claude (OpenAI 호환 API 사용 시)\nLocal LLM (Ollama, LM Studio 등)\n컨텍스트 수집\nAI는 다음 정보를 수집하여 작업을 수행합니다:\nIssue 본문: 사용자의 초기 요청\n모든 댓글: 대화 히스토리 및 피드백\n기존 문서: 관련 문서가 있으면 해당 내용\n이전 작업 결과: 이전에 생성된 문서 경로\n이를 통해 AI는 전체 맥락을 이해하고 적절한 작업을 수행합니다.\n문서 생성 규칙\nAI가 생성하는 문서는 다음 규칙을 따릅니다:\nYAML frontmatter 포함 (title, author, tags)\n한국어로 작성\n마크다운 형식\n코드 예시 포함 (해당되는 경우)\nfrontmatter 예시\n워크플로우 파일\n에서 워크플로우를 확인하고 수정할 수 있습니다.\n주요 스크립트:\n- 새 문서 생성\n- 피드백 처리\n- 오류 표시 처리\n- 문서 발행",
    "excerpt": "LLM 워크플로우\nSEPilot Wiki는 GitHub Actions와 LLM을 연동하여 자동으로 문서를 생성하고 관리합니다.\n워크플로우 개요\n지원하는 이벤트\nrequest 라벨 추가\nIssue에  라벨을 추가하면:\nAI가 Issue 제목과 본문을 분석\n관련 문서 초안 자동 생성\n폴더에 마크다운 파일 저장\nIssue에 결과 댓글 추가\n,  라벨 자동 추가...",
    "tags": [
      "LLM",
      "워크플로우",
      "AI",
      "GitHub Actions"
    ],
    "lastModified": "2025-12-07T06:05:44Z",
    "author": "github-actions[bot]"
  },
  {
    "title": "설정 파일 가이드",
    "slug": "guide/configuration-guide",
    "content": "설정 파일 가이드\nSEPilot Wiki의 모든 설정 파일과 옵션을 상세히 설명합니다.\n설정 파일 목록\n  파일   위치   용도  \n ------ ------ ------ \n     루트   사이트 기본 정보  \n     루트   테마 (색상, 폰트, 레이아웃)  \n     루트   네비게이션 메뉴  \n     src/styles   커스텀 CSS  \n     src   GitHub 저장소 연결 설정  \nsite.config.ts 상세\ntheme.config.ts 상세\n색상 (colors)\n폰트 (fonts)\n레이아웃 (layout)\n테두리 반경 (borderRadius)\nnavigation.config.ts 상세\nGitHub 저장소 설정\nRepository Secrets\nGitHub Repository Settings > Secrets에서 설정:\n  변수   필수   설명  \n ------ ------ ------ \n     O   OpenAI 호환 API URL  \n     O   API 키  \n     O   모델명 (예: gpt-4)  \nGitHub Pages 설정\nRepository Settings > Pages\nSource: \"GitHub Actions\" 선택\n브랜치 push 시 자동 배포\n환경 변수\n빌드 시\n개발 시\n 파일에 설정:",
    "excerpt": "설정 파일 가이드\nSEPilot Wiki의 모든 설정 파일과 옵션을 상세히 설명합니다.\n설정 파일 목록\n  파일   위치   용도  \n ------ ------ ------ \n     루트   사이트 기본 정보  \n     루트   테마 (색상, 폰트, 레이아웃)  \n     루트   네비게이션 메뉴  \n     src/styles   커스텀 CSS...",
    "tags": [
      "설정",
      "가이드",
      "TypeScript"
    ],
    "lastModified": "2025-12-07T06:05:44Z",
    "author": "github-actions[bot]"
  },
  {
    "title": "GitHub Actions로 bun을 쓰는 방법",
    "slug": "bun/bun-github-actions-setup",
    "content": "개요\nGitHub Actions 워크플로우에서 bun(JavaScript 런타임 및 패키지 매니저)을 사용하면 빠른 의존성 설치와 빌드가 가능합니다. 이 문서에서는 bun을 설치하고, 캐시를 활용하며, 일반적인 스크립트를 실행하는 전체 흐름을 예시와 함께 설명합니다.\n사전 요구 사항\n저장소에 을 사용하도록 설정된  혹은  파일이 존재해야 합니다.\n워크플로우는 Linux() 환경을 기준으로 설명합니다. Windows/macOS에서도 동일한 단계가 적용되지만, OS별 경로 차이에 유의하세요.\n워크플로우 파일 구조\n 디렉터리에  과 같은 파일을 생성합니다.\n워크플로우 트리거\nJob 정의\n단계별 설정\n3-1. 레포지토리 체크아웃\n3-2. bun 설치\nbun은 공식 설치 스크립트를 통해 간단히 설치할 수 있습니다.\n공식 설치 스크립트는  에서 확인할 수 있습니다.\n3-3. 의존성 캐시\nbun은  대신 와  디렉터리를 사용합니다.\n 액션을 이용해 이 디렉터리를 캐시하면 설치 속도가 크게 향상됩니다.\n3-4. 의존성 설치\n3-5. 테스트 실행 (예시)\n3-6. 빌드 및 배포 (필요 시)\n전체 예시 워크플로우\n아래는 위 단계들을 하나의 파일에 통합한 최종 예시입니다.\n주의: 위 예시에서는 와  스크립트가  혹은 에 정의되어 있다고 가정합니다. 실제 프로젝트에 맞게 스크립트 명령을 조정하세요.\nmacOS / Windows 환경에서 사용하기\nmacOS:  로 변경하고,  설치가 기본 제공됩니다.\nWindows:  로 변경하고, PowerShell 스크립트()를 사용해 bun을 설치합니다. 예시:\nWindows에서는 경로 구분자()와 환경 변수 사용법에 유의하세요.\n베스트 프랙티스\n캐시 키 관리:  파일이 변경될 때마다 캐시가 무효화되도록  를 사용합니다.\nCI 속도 최적화:  대신 bun 전용 설치 스크립트를 사용하면 불필요한 Node.js 설치를 피할 수 있습니다.\n보안: 공식 설치 스크립트는 HTTPS를 통해 전달되며,  옵션으로 오류 시 중단됩니다. 필요 시 SHA256 검증을 추가할 수 있습니다.\n버전 고정: 특정 bun 버전을 사용하려면  환경 변수를 설정하고 설치 스크립트에 전달합니다.\n참고 자료\nBun 공식 홈페이지 및 설치 가이드: \nGitHub Actions 공식 문서: \nactions/cache 액션: \n결론\nGitHub Actions에서 bun을 활용하면 의존성 설치와 빌드 속도가 크게 개선됩니다. 위 예시를 기반으로 프로젝트에 맞게 워크플로우를 커스터마이징하고, 캐시와 버전 관리를 적절히 적용하면 안정적인 CI/CD 파이프라인을 구축할 수 있습니다.",
    "excerpt": "개요\nGitHub Actions 워크플로우에서 bun(JavaScript 런타임 및 패키지 매니저)을 사용하면 빠른 의존성 설치와 빌드가 가능합니다. 이 문서에서는 bun을 설치하고, 캐시를 활용하며, 일반적인 스크립트를 실행하는 전체 흐름을 예시와 함께 설명합니다.\n사전 요구 사항\n저장소에 을 사용하도록 설정된  혹은  파일이 존재해야 합니다.\n워크플로우...",
    "tags": [
      "github-actions",
      "bun",
      "CI",
      "CI/CD",
      "node-alternative"
    ],
    "lastModified": "2025-12-07T06:05:44Z",
    "author": "SEPilot AI"
  },
  {
    "title": "bun과 pnpm, npm의 차이",
    "slug": "bun/bun-comparison-pnpm-npm",
    "content": "bun과 pnpm, npm의 차이\n개요\n은 JavaScript 런타임, 패키지 매니저, 번들러를 하나의 바이너리로 제공하는 통합 툴입니다. 반면에 과 은 패키지 매니저에 초점을 맞추고 있으며, 각각 Node.js와 별도로 동작합니다.\n이 가이드에서는 설치 방식, 성능, 디스크 사용량, 호환성, 생태계 등을 기준으로 세 도구를 비교하고, 어떤 상황에서 어떤 도구를 선택하면 좋은지 살펴봅니다.\n설치 및 초기 설정\n  항목   bun   npm (Node.js 기본)   pnpm  \n ------ ----- ------------------- ------ \n  설치 명령    (스크립트) 또는  (macOS)   Node.js 설치 시 자동 포함 ( 확인)     \n  기본 제공 기능   런타임, 패키지 매니저, 번들러, 테스트 러너 등   런타임 + npm (패키지 매니저)   npm 호환 CLI + 효율적인 저장소 관리  \n  설정 파일    (선택)       (멀티패키지)  \n성능 비교\n  항목   bun   npm   pnpm  \n ------ ----- ----- ------ \n  패키지 설치 속도   매우 빠름 (C++ 로 구현, 병렬 다운로드)   보통 (JavaScript 기반)   npm보다 빠름, 하지만 bun보다는 느림  \n  실행 속도 (런타임)   Node.js 대비 24배 빠름 (V8 엔진 최적화)   Node.js 표준   Node.js 표준 (pnpm은 런타임이 아님)  \n  번들링 속도    로 초단위 번들링   ,  등 별도 도구 필요   별도 번들러 필요  \n벤치마크:  은 10,000개의 의존성을 30초 이내에 설치할 수 있는 반면, npm은 23분, pnpm은 약 1분 정도 소요됩니다(환경에 따라 차이 존재).\n디스크 사용량\nnpm: 각 프로젝트마다 에 전체 복사본을 저장 → 중복 파일이 많이 발생.\npnpm: 내용 주소 기반 저장소(content‑addressable store)를 전역에 두고, 프로젝트마다 심볼릭 링크를 사용 → 중복 최소화, 디스크 사용량 3050% 절감.\nbun:  역시 전역 캐시를 사용하지만, 현재는 pnpm만큼 세밀한 deduplication을 제공하지 않음. 그래도 npm 대비 2030% 정도 절감.\n호환성 및 생태계\n  항목   bun   npm   pnpm  \n ------ ----- ----- ------ \n  Node.js API 호환   대부분 호환, 일부 네이티브 모듈(특히 C/C++ 애드온)에서 빌드 오류 가능   완전 호환   완전 호환 (npm 스크립트 그대로 사용)  \n  패키지 레지스트리   기본적으로 npm 레지스트리 사용   npm 레지스트리   npm 레지스트리  \n  스크립트 실행    (npm script와 동일)        \n  커뮤니티·플러그인   아직 초기 단계, 공식 플러그인 제한적   가장 큰 생태계, 수많은 플러그인·툴   npm 호환 플러그인 대부분 사용 가능  \n주요 사용 사례\nbun: 빠른 프로토타이핑, 작은 프로젝트, 번들링이 필요 없는 서버리스 함수, 성능이 중요한 CLI 툴.\nnpm: 대부분의 Node.js 프로젝트, 레거시 코드베이스, 광범위한 CI/CD 파이프라인.\npnpm: 모노레포, 대규모 프로젝트, 디스크 사용량을 최소화하고 설치 속도를 개선하고 싶을 때.\n선택 가이드\n  상황   추천 도구  \n ------ ----------- \n  프로젝트가 작고 빠른 설치·실행이 필요   bun  \n  기존 Node.js 생태계와 완전 호환이 필요   npm  \n  멀티패키지(모노레포) 혹은 디스크 절감이 중요한 대규모 프로젝트   pnpm  \n결론\n은 속도와 통합성을 중시하는 최신 개발자에게 매력적인 선택입니다.\n은 보편성과 광범위한 호환성을 제공하므로 여전히 기본 선택지입니다.\n은 효율적인 저장소 관리와 모노레포 지원이 강점이며, npm과 100% 호환됩니다.\n프로젝트 요구사항(성능, 디스크 사용량, 생태계 지원)을 고려해 적절한 도구를 선택하면 됩니다.\n이 문서는 2025년 기준 정보를 바탕으로 작성되었습니다. 각 툴의 최신 버전 및 업데이트 내용은 공식 문서를 참고하세요.",
    "excerpt": "bun과 pnpm, npm의 차이\n개요\n은 JavaScript 런타임, 패키지 매니저, 번들러를 하나의 바이너리로 제공하는 통합 툴입니다. 반면에 과 은 패키지 매니저에 초점을 맞추고 있으며, 각각 Node.js와 별도로 동작합니다.\n이 가이드에서는 설치 방식, 성능, 디스크 사용량, 호환성, 생태계 등을 기준으로 세 도구를 비교하고, 어떤 상황에서 어떤...",
    "tags": [
      "bun",
      "pnpm",
      "npm",
      "비교",
      "가이드"
    ],
    "lastModified": "2025-12-07T06:05:44Z",
    "author": "github-actions[bot]"
  },
  {
    "title": "bun 이란?",
    "slug": "bun/bun-overview",
    "content": "개요\nbun은 JavaScript/TypeScript 런타임, 번들러, 그리고 패키지 매니저를 하나로 통합한 도구입니다.\n런타임: Node.js와 호환되는 API를 제공하면서 V8 엔진 대신 JavaScriptCore(Apple의 엔진)를 사용합니다.\n번들러:  명령을 통해 ES 모듈, CommonJS, TypeScript 등을 빠르게 번들링합니다.\n패키지 매니저:  로 npm 레지스트리의 패키지를 설치하며, 과  구조를 그대로 사용합니다.\n공식 웹사이트: https://bun.sh\nGitHub 레포지터리: https://github.com/oven-sh/bun\nbun을 선택한 이유\n  항목   설명  \n ------ ------ \n  성능   Zig 언어와 JavaScriptCore를 활용해 파일 I/O, 네트워크, 패키지 설치, 번들링 속도가 기존 Node.js 기반 도구보다 현저히 빠릅니다. 공식 벤치마크에서는  대비 23배,  대비 510배 빠른 결과가 보고되었습니다.  \n  통합 도구   런타임, 번들러, 패키지 매니저가 하나의 바이너리()에 포함돼 별도 설치가 필요 없습니다. 개발 환경 설정이 간단해집니다.  \n  Zero‑Config 지원    명령만으로 TypeScript 파일을 바로 실행할 수 있어 별도  설정이 불필요합니다.  \n  호환성   대부분의 npm 패키지를 그대로 사용할 수 있으며,  스크립트도 그대로 동작합니다.  \n  경량 설치 파일   단일 실행 파일(≈ 30 MB)로 배포되어 CI/CD 파이프라인에 쉽게 통합할 수 있습니다.  \n장점\n빠른 설치 및 실행\n  -  은 병렬 I/O와 캐시 최적화를 통해 npm/yarn 대비 수 초 내에 의존성을 설치합니다.\n내장 번들러\n  -  로 ESBuild와 유사한 속도로 번들을 생성하며, 자동 트리쉐이킹과 코드 스플리팅을 지원합니다.\nTypeScript 지원\n  - 별도 트랜스파일러 없이  로 바로 실행 가능.\n단일 바이너리\n  - 런타임, 번들러, 패키지 매니저가 하나의 실행 파일에 포함돼 환경 관리가 단순합니다.\nPOSIX 호환\n  - macOS, Linux, Windows(WSL 포함)에서 동일한 바이너리를 사용합니다.\n단점\n생태계 성숙도\n  - npm/yarn에 비해 아직 사용자가 적고, 일부 복잡한 네이티브 모듈(예:  기반)에서 호환성 문제가 발생할 수 있습니다.\n플러그인 및 툴링\n  - Webpack, Rollup 등 기존 번들러용 플러그인 생태계와 직접 호환되지 않으며, bun 전용 플러그인도 아직 제한적입니다.\n문서 및 커뮤니티\n  - 공식 문서는 꾸준히 업데이트되고 있지만, Stack Overflow 등 커뮤니티 기반 Q&A가 상대적으로 적습니다.\n버전 관리\n  - 현재는  자체가 버전 관리 도구 역할을 하지 않으며, 프로젝트별 Node.js 버전 관리와는 별개로 다루어야 합니다.\n라이선스 및 역사\n라이선스: MIT License (오픈 소스, 자유롭게 사용·수정·배포 가능)\n주요 연혁\n  - 2021년 5월: 프로젝트 초기 설계 및 공개 발표 (Jarred Sumner, Oven.sh 팀)\n  - 2022년 1월: 첫 베타 버전() 공개, GitHub 스타 수 급증\n  - 2022년 8월:  에서 패키지 매니저 기능 정식 추가\n  - 2023년 3월:  에서 TypeScript 실행 지원 및  도입\n  - 2024년 11월:  에서 Windows 지원 및 안정화 버전 출시\n자세한 릴리즈 노트는 GitHub Releases 페이지(https://github.com/oven-sh/bun/releases)를 참고하세요.\n결론\nbun은 속도와 통합성을 중시하는 프로젝트에 적합한 최신 JavaScript 도구입니다.\n성능이 중요한 CI/CD 파이프라인, 대규모 모노레포, 혹은 빠른 개발 피드백 루프가 필요한 경우 bun을 고려해볼 만합니다.\n반면, 특정 네이티브 모듈이나 풍부한 플러그인 생태계가 필수인 경우에는 기존 npm/yarn + Webpack/Rollup 조합이 더 안정적일 수 있습니다.\n프로젝트에 적용하기 전, 핵심 의존성이 bun과 호환되는지 확인하고, 작은 파일럿 프로젝트에서 성능 및 호환성을 검증하는 것을 권장합니다.\n추가 조사 필요: 복잡한 네이티브 모듈(예:  기반)과 bun의 호환성 여부는 프로젝트별 테스트가 필요합니다. 공식 문서와 GitHub 이슈 트래커를 지속적으로 확인하세요.",
    "excerpt": "개요\nbun은 JavaScript/TypeScript 런타임, 번들러, 그리고 패키지 매니저를 하나로 통합한 도구입니다.\n런타임: Node.js와 호환되는 API를 제공하면서 V8 엔진 대신 JavaScriptCore(Apple의 엔진)를 사용합니다.\n번들러:  명령을 통해 ES 모듈, CommonJS, TypeScript 등을 빠르게 번들링합니다.\n패키지...",
    "tags": [
      "bun",
      "npm",
      "yarn",
      "패키지 매니저",
      "가이드"
    ],
    "lastModified": "2025-12-07T06:05:44Z",
    "author": "SEPilot AI"
  }
]