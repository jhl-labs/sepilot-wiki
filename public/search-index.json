[
  {
    "title": "주간 위키 보고서 - 2026년 08주차",
    "slug": "reports/weekly-2026-08",
    "content": "요약\n전체 문서 수는 18개이며, 이번 주에 14개가 신규 생성되었습니다.  \n현재 초안(draft) 상태가 10개, 발행(published) 상태가 7개, 삭제된 문서가 1개입니다.  \nAI가 수행한 작업은 50건으로,  13건,  14건,  9건 등이 주요 활동이었습니다.  \n열린 이슈는 6개이며, 최근 7일간 12건의 이슈 활동이 있었습니다.\n문서 현황\n  구분   개수  \n ------ ------ \n  전체 문서   18  \n  초안(draft)   10  \n  발행(published)   7  \n  삭제된 문서   1  \n  신규 생성   14  \n  수정된 문서   2  \n  이번 주 발행된 문서   3  \nAI 활동 요약\n총 작업 수: 50\n작업 유형별  \n  -  (유지보수): 13  \n  -  (문서 생성): 14  \n  -  (교차 참조 업데이트): 9  \n  -  (복구/피드백 반영): 6  \n  -  (발행): 3  \n  -  (커버리지 분석): 1  \n  -  (태그 정규화): 2  \n  -  (수정): 2  \n주요 AI 로그\nWiki Tree Maintenance – 자동 구조 분석 후 22개 적용(0 보류) (2026‑02‑16)  \n학습 루프 – 패턴 2개 감지, 에이전트 2개 개선 (2026‑02‑15)  \n문서 커버리지 분석 – 커버리지 점수 12점, 미문서화 모듈 10개 발견 (2026‑02‑15)  \nURL 변경 감지 – 30개 체크, 1개 변경, 4개 깨짐, 3건 Issue 생성 (2026‑02‑13)  \n트렌드 모니터링 – 23건 수집, 3건 감지, 3건 Issue 생성 (2026‑02‑13)  \n문서 생성 예시  \n  -  (Issue #160) – 연구·아웃라인·작성·리뷰 4단계 총 39,971 ms, 토큰 약 1,525 개 (2026‑02‑12)  \n  -  (Issue #158) – 총 41,234 ms, 토큰 약 1,875 개 (2026‑02‑11)  \n  -  (Issue #156) – 총 32,781 ms, 토큰 약 1,403 개 (2026‑02‑11)  \n열린 이슈\n전체 오픈 이슈: 6  \n최근 7일간 이슈 활동: 12건 (코멘트, 라벨링, 클로즈 등)\n주간 변경사항\n  SHA   커밋 메시지  \n ----- ------------- \n  5132464   🌳 Wiki Tree Maintenance: 전체 위키는 4개의 주요 카테고리(kubernetes, projects, bun, ai)로 구성. 중복 Opencode 문서 존재, 메타데이터 추가 제안  \n  bbce2ca   🌳 Wiki Tree Maintenance: 루트 레벨에 glm5, opencode 두 문서와 중복 Opencode 가이드 존재. 파일명 slug 정규화 및 순서 지정 권고  \n  f2989d2   docs: Issue #160 - [요청] 어제 발표한 glm5 에 대해 조사해줘  \n  af0cfb6   docs: Issue #156 - 문서 발행  \n  a897516   🌳 Wiki Tree Maintenance: 4개 카테고리 구성, 루트 비정형 파일·삭제된 Opencode 문서 존재, URL 깨짐 위험  \n  ca25fed   docs: Issue #158 - [요청] 바이브코딩에 대해  \n  0190970   🔗 교차 참조 업데이트: 16개 문서  \n  08e2761   Rename .md to opencode.md  \n  e873878   🌳 Wiki Tree Maintenance: 22개 문서가 6개 디렉터리에 흩어짐, 루트 파일·중복 Opencode 문제 지적  \n  605d980   docs: Issue #156 - 피드백 반영  \n향후 과제\n초안(draft) 문서 정리 – 현재 10개의 초안 중 7개 이상을 검토·발행하거나 삭제하여 발행 비율을 높일 필요가 있습니다.  \n중복 및 URL 깨짐 문서 해결 –  관련 중복 파일과 루트 레벨 비정형 파일을 정규화하고, 깨진 URL 4건을 복구합니다.  \n문서 커버리지 개선 – 커버리지 분석 결과 발견된 10개의 미문서화 모듈에 대한 문서 작성 작업을 계획합니다.  \n교차 참조 최신화 – 이번 주에 5번에 걸쳐 62개의 교차 참조가 업데이트되었으나, 지속적인 자동 업데이트 스케줄을 검토해 누락을 최소화합니다.  \n열린 이슈 처리 – 현재 6개의 오픈 이슈를 우선순위에 따라 해결하고, 최근 활동이 많은 이슈(12건)와 연계된 문서·태스크를 정리합니다.  \n태그 정규화 –  작업이 2건 수행되었으니, 전체 문서에 일관된 태그 체계를 적용해 검색성을 향상시킵니다.",
    "excerpt": "요약\n전체 문서 수는 18개이며, 이번 주에 14개가 신규 생성되었습니다.  \n현재 초안(draft) 상태가 10개, 발행(published) 상태가 7개, 삭제된 문서가 1개입니다.  \nAI가 수행한 작업은 50건으로,  13건,  14건,  9건 등이 주요 활동이었습니다.  \n열린 이슈는 6개이며, 최근 7일간 12건의 이슈 활동이 있었습니다.\n문서 현...",
    "tags": [
      "보고서",
      "주간",
      "통계"
    ],
    "lastModified": "2026-02-17T17:50:34Z",
    "author": "SEPilot AI"
  },
  {
    "title": "Kubernetes 버전별 릴리즈 노트",
    "slug": "kubernetes/kubernetes-release-notes",
    "content": "Kubernetes 버전별 릴리즈 노트\n본 문서는 Kubernetes v1.23 부터 현재 최신 v1.34 (및 이후 마이너 릴리즈)까지 주요 변경 사항을 5줄 이내로 요약합니다. 각 버전별 핵심 기능, 개선점, Deprecated 항목을 포함합니다.\nv1.34 (2026‑02‑xx)\n새로운 API:  완전 폐기,  admission controller 기본 활성화\n향상된 스케줄러: Topology‑aware 스케줄링 지원 확대\nCRI‑Shim: Container Runtime Interface 개선,  1.8 호환성 강화\n보안: TLS 1.3 기본 적용, kube‑apiserver에 대한 audit 로그 포맷 개선\nDeprecated:  Ingress API 완전 삭제\nv1.33 (2025‑12‑xx)\n새로운 기능:  GA, 디버깅용 임시 컨테이너 지원\n네트워킹: Service IP Address Management (IPAM) 플러그인 기본 제공\n스토리지: CSI Snapshot Controller v1.2 정식 출시\n성능: kube‑scheduler 성능 15% 향상,  지원 옵션 추가\nDeprecated:   플래그 폐기 예정\nv1.32 (2025‑09‑xx)\n새로운 API:  v1 정식,  v1beta1 GA\nCLI 개선:  플러그인 자동 업데이트 기능 도입\n보안:  단계적 폐기 로드맵 발표\n클러스터 관리:  v1.32에서  자동 설정 지원\nDeprecated:   API 폐기 예정\nv1.31 (2025‑06‑xx)\n새로운 기능:  성능 최적화, conflict‑resolution 개선\n네트워킹:  기본 활성화 옵션 제공\n스토리지:   모니터링 GA\n보안:  단계적 폐기 시작,  대체 권고\nDeprecated:   API 폐기 예정\nv1.30 (2025‑03‑xx)\n새로운 API:  v2 정식, 서비스 엔드포인트 관리 효율화\nCLI:   기본값 변경\n보안:  확장,  기본 지원\n클러스터:  에  직접 지정 가능\nDeprecated:   폐기 로드맵 발표\nv1.29 (2024‑12‑xx)\n새로운 기능:  v1beta1 GA, 보안 정책 선언 방식 개선\n네트워킹:   지원 확대\n스토리지:   v1 정식\n성능:  메모리 사용량 10% 감소\nDeprecated:   API 폐기 예정\nv1.28 (2024‑09‑xx)\n새로운 API:  v1 정식,  v1beta1 단계적 폐기\nCLI:   옵션 추가\n보안:  플러그인 v2 지원, 비밀 관리 강화\n클러스터:   시  자동 백업 옵션 제공\nDeprecated:   폐기 일정 발표\nv1.27 (2024‑06‑xx)\n새로운 기능:  베타 출시, 디버깅 용이\n네트워킹:   개선\n스토리지:   베타 제공\n보안:  단계적 폐기 로드맵 공개\nDeprecated:   API 폐기 예정\nv1.26 (2024‑03‑xx)\n새로운 API:  v1beta1 정식,  v1beta1 유지\nCLI:   기본값 변경\n보안:  폐기 로드맵 발표,  대체 권고\n클러스터:  에  직접 지정 가능\nDeprecated:   API 폐기 예정\nv1.25 (2023‑12‑xx)\n새로운 기능:  단계적 폐기 시작,  베타 제공\n네트워킹:  v1 정식, 서비스 엔드포인트 관리 효율화\n스토리지:   GA\n보안:  TLS 1.3 지원\nDeprecated:   API 폐기 일정 발표\nv1.24 (2023‑09‑xx)\n새로운 API:  v1beta1 정식,  v1beta1 유지\nCLI:   기본값 변경\n보안:  단계적 폐기 로드맵 공개\n클러스터:   시  자동 백업 옵션 제공\nDeprecated:   API 폐기 예정\nv1.23 (2023‑06‑xx)\n새로운 기능:  v1beta1 정식,  v1beta1 유지\n네트워킹:  v1beta1 정식\n스토리지:   베타 제공\n보안:  단계적 폐기 로드맵 발표\nDeprecated:   API 폐기 일정 발표\n주의: 위 내용은 공식 Kubernetes 릴리즈 노트를 기반으로 요약한 것이며, 각 버전의 전체 변경 사항은 Kubernetes Release Notes 페이지를 참고하시기 바랍니다.\n이 문서는 현재 초안(draft) 상태이며, 검토 후  로 전환될 예정입니다.",
    "excerpt": "Kubernetes 버전별 릴리즈 노트\n본 문서는 Kubernetes v1.23 부터 현재 최신 v1.34 (및 이후 마이너 릴리즈)까지 주요 변경 사항을 5줄 이내로 요약합니다. 각 버전별 핵심 기능, 개선점, Deprecated 항목을 포함합니다.\nv1.34 (2026‑02‑xx)\n새로운 API:  완전 폐기,  admission controller 기...",
    "tags": [
      "Kubernetes",
      "Release Notes",
      "버전",
      "version",
      "changelog"
    ],
    "lastModified": "2026-02-17T17:50:34Z",
    "author": "GitHub Action"
  },
  {
    "title": "Ingress NGINX 은퇴 선언 및 마이그레이션 가이드",
    "slug": "kubernetes/ingress-nginx-deprecation-guide",
    "content": "개요\n이 문서는 Kubernetes Steering Committee와 Security Response Committee가 2026년 3월에 발표한 Ingress NGINX 은퇴 선언을 기반으로 작성되었습니다.  \n대상 독자는 현재 클러스터에서 Ingress NGINX를 사용하고 있거나, 향후 도입을 고려하고 있는 클라우드‑네이티브 엔지니어, 플랫폼 운영팀, 보안 담당자입니다.\n핵심 발표 요약  \n2026년 3월, Ingress NGINX 프로젝트는 공식적으로 은퇴합니다.  \n은퇴 이후에는 버그 수정, 보안 패치, 신규 릴리스가 제공되지 않으며, 유지보수는 “베스트‑에포트”(best‑effort) 수준으로 종료됩니다.  \n기존 배포는 계속 동작하지만, 보안 취약점에 대한 대응이 불가능해지므로 즉시 마이그레이션이 필요합니다.  \n출처: Kubernetes Blog – Ingress NGINX Statement (2026‑01‑29)\n배경 및 현황\nIngress NGINX의 역할 및 시장 점유율\nIngress NGINX는 Kubernetes 클러스터에서 외부 트래픽을 서비스로 라우팅하는 Ingress Controller 중 가장 널리 사용되는 구현체였습니다.  \n내부 Datadog 조사에 따르면 전체 클라우드‑네이티브 환경의 약 50%가 Ingress NGINX에 의존하고 있습니다.  \n기존 유지보수 현황 및 기여자 부족 문제\n2025년 11월 발표된 사전 안내 글에 따르면, 프로젝트는 12명의 자원봉사자에 의해 유지보수되고 있었으며, 충분한 기여자를 확보하지 못해 은퇴가 결정되었습니다.  \n공식 블로그: Ingress NGINX Retirement: What You Need to Know (2025‑11‑11)\n커뮤니티·스테어링 위원회와 보안 대응 위원회의 역할\nSIG Network와 Security Response Committee가 은퇴 일정을 관리하고, 마이그레이션 가이드를 제공하고 있습니다.  \n이들 위원회는 은퇴 이후 발생할 수 있는 보안 위험을 최소화하기 위해 대체 솔루션을 권고하고 있습니다.\n은퇴 선언 상세\n  항목   내용  \n ------ ------ \n  공식 발표 일자   2026‑01‑29 (Kubernetes Blog)  \n  발표 채널   Kubernetes 공식 블로그, SIG Network 메일링 리스트  \n  은퇴 일정   2026‑03‑01까지 베스트‑에포트 유지보수 제공, 이후 모든 업데이트 중단  \n  지원 종료 이후 제공되지 않을 사항   버그 수정, 보안 패치, 신규 릴리스, 공식 이미지 업데이트  \n영향 분석\n운영 위험  \n   - 보안 취약점이 발견되어도 패치가 제공되지 않음 → 공격 표면 확대.  \n   - 기존 배포는 계속 동작하지만, 취약점 노출 시 복구가 어려움.  \n가용성 위험  \n   - 코드 베이스가 더 이상 업데이트되지 않으므로, Kubernetes 버전 업그레이드 시 호환성 문제가 발생할 가능성이 있음.  \n운영 비용 및 인력 부담  \n   - 마이그레이션 작업에 필요한 엔지니어링 시간(예상 24주)과 테스트 인프라 비용이 추가 발생.  \n사전 점검 방법\nIngress NGINX 사용 여부 확인\n위 명령이 결과를 반환하면 해당 클러스터에 Ingress NGINX가 배포되어 있음을 의미합니다.\n의존성 파악 절차\n로 모든 Ingress 리소스를 확인.  \nIngress 리소스에  혹은  어노테이션이 있는지 검토.  \n서비스, ConfigMap, Secret 등 연관된 리소스도 함께 파악.\n영향도 평가 체크리스트\n[ ] Ingress NGINX 파드 존재 여부  \n[ ] Ingress 리소스가  클래스를 사용 중인지  \n[ ] 현재 사용 중인 TLS 인증서 관리 방식  \n[ ] 외부 DNS/로드밸런서와의 연동 구조  \n마이그레이션 전략\n전환 기간 (2개월) 주요 작업\n  단계   기간   주요 작업  \n ------ ------ ----------- \n  평가   1주   현재 사용 현황 파악, 대체 솔루션 후보 선정  \n  파일럿   3주   선택한 대체 솔루션을 별도 네임스페이스에 배포, 테스트 트래픽 전환  \n  전면 전환   2주   단계적 트래픽 이동, 기존 Ingress NGINX 종료  \n  정리   1주   모니터링 설정 검증, 문서 정비  \n단계별 마이그레이션 플랜\n평가 – 현재 Ingress NGINX 설정(Annotations, ConfigMap, Custom Templates) 목록화.  \n파일럿 –  혹은 서드파티 Ingress Controller(예: Contour, Traefik) 중 하나를 선택하고, GatewayClass와 Gateway 리소스를 정의.  \n전면 전환 –  등을 활용해 트래픽을 새 컨트롤러로 점진적 전환.  \n롤백 – 문제가 발생하면 파일럿 단계에서 사용한 네임스페이스로 즉시 복구 가능하도록 설계.  \n비상 대응 방안\n스냅샷: 기존 Ingress NGINX 매니페스트와 ConfigMap을 Git에 보관.  \n읽기 전용 모드: 은퇴 전 마지막 2주 동안은 새로운 Ingress 리소스 생성을 차단하고, 기존 리소스만 유지.  \n대체 솔루션 비교\n  솔루션   장점   제한 사항  \n -------- ------ ----------- \n  Gateway API (공식)   표준화된 API, 확장성, 향후 Kubernetes와 긴밀히 연동   기존 Ingress 매니페스트와 1:1 매핑이 어려움, 학습 곡선  \n  Contour   Envoy 기반 고성능, Gateway API 지원   일부 고급 NGINX 전용 기능 미지원  \n  Traefik   자동 서비스 디스커버리, 다중 프로토콜 지원   복잡한 라우팅 규칙 구현 시 설정 난이도  \n  Istio IngressGateway   서비스 메시와 통합 가능   전체 Istio 설치 필요, 리소스 오버헤드  \n선택 기준  \n현재 사용 중인 라우팅 기능(예: TLS Passthrough, Rewrite)과의 매핑 가능성  \n운영팀의 기술 스택 및 학습 비용  \n클라우드 제공자와의 호환성  \n구현 가이드 개요\nGateway API 도입 기본 흐름\nGatewayClass 정의 (예:  혹은 ).  \nGateway 리소스 생성 – 로드밸런서 IP/Hostname 지정.  \nHTTPRoute 혹은 TCPRoute 정의 – 기존 Ingress 규칙을 변환.  \n기존 Ingress 리소스 변환 도구\n공식  레포지토리에서 제공하는  변환 스크립트(추가 조사가 필요합니다).  \n커뮤니티가 만든  플러그인(추가 조사가 필요합니다).  \nCI/CD 파이프라인 자동화\nGitOps:  혹은  차트에 Gateway API 매니페스트를 포함하고, Argo CD 혹은 FluxCD를 통해 자동 배포.  \n검증 단계:  혹은 를 이용해 Gateway 리소스 스키마 검증.  \n커뮤니티 및 지원 리소스\nSIG Network: https://github.com/kubernetes/community/tree/master/sig-network  \nSecurity Response Committee: https://github.com/kubernetes/kubernetes/tree/master/security  \n공식 문서:  \n  - Gateway API 소개 – https://gateway-api.sigs.k8s.io/  \n  - Ingress NGINX 은퇴 FAQ – https://kubernetes.io/blog/2026/01/29/ingress-nginx-statement/  \n포럼·Slack:  채널,  채널  \n기여 방법: 프로젝트 레포지토리 이슈 트래킹, PR 템플릿 활용 (추가 조사가 필요합니다).  \nFAQ\nQ1. 은퇴 이후 기존 배포는 계속 동작하나요?  \nA: 네, 기존 파드와 서비스는 그대로 동작합니다. 다만 보안 패치가 제공되지 않으므로 위험에 노출됩니다.\nQ2. 보안 패치가 제공되지 않을 경우 어떻게 대응해야 하나요?  \nA: 가능한 빨리 대체 솔루션(Gateway API 등)으로 마이그레이션하고, 외부 보안 스캐너로 취약점 모니터링을 강화합니다.\nQ3. 마이그레이션 시 예상되는 다운타임은?  \nA: 단계적 트래픽 전환을 적용하면 다운타임은 거의 없으며, 파일럿 단계에서 충분히 검증한 뒤 전면 전환 시 최소 12분 수준으로 제한할 수 있습니다.\n참고 자료 및 링크\n공식 발표 블로그 포스트 (2026‑01‑29) – https://kubernetes.io/blog/2026/01/29/ingress-nginx-statement/  \n2025‑11‑11 은퇴 사전 안내 글 – https://kubernetes.io/blog/2025/11/11/ingress-nginx-retirement/  \nDatadog 내부 조사 결과 요약 – (추가 조사가 필요합니다)  \nGateway API 공식 문서 – https://gateway-api.sigs.k8s.io/  \nIngress NGINX GitHub 레포지토리 – https://github.com/kubernetes/ingress-nginx  \n---  \n이 문서는 SEPilot Wiki 유지보수를 위해 자동 생성된 초안이며, 실제 적용 전 반드시 내부 검토를 거쳐 주세요.*",
    "excerpt": "개요\n이 문서는 Kubernetes Steering Committee와 Security Response Committee가 2026년 3월에 발표한 Ingress NGINX 은퇴 선언을 기반으로 작성되었습니다.  \n대상 독자는 현재 클러스터에서 Ingress NGINX를 사용하고 있거나, 향후 도입을 고려하고 있는 클라우드‑네이티브 엔지니어, 플랫폼 운영팀...",
    "tags": [
      "Ingress",
      "NGINX",
      "Kubernetes",
      "Migration",
      "Security",
      "guide",
      "deprecation",
      "k8s",
      "networking",
      "load-balancer"
    ],
    "lastModified": "2026-02-17T17:50:34Z",
    "author": "SEPilot AI"
  },
  {
    "title": "OpenClaw 완벽 가이드",
    "slug": "projects/openclaw-complete-guide",
    "content": "OpenClaw 개요 및 핵심 개념\nOpenClaw는 24 시간 언제든지 사용할 수 있는 AI 개인 비서 및 자율 에이전트를 목표로 하는 오픈소스 프로젝트입니다. 초기에는 Clawdbot·Moltbot이라는 이름으로 개발되었으며, 현재는 GitHub(https://github.com/openclaw/openclaw) 에서 활발히 유지·관리되고 있습니다 [1].\n주요 목표\n항시 가동 – 언제든지 메시지를 주고받을 수 있는 AI 비서 제공  \n멀티채널 지원 – Telegram, Discord, WhatsApp, Slack 등 다양한 메신저와 연동  \n자율 실행 – Heartbeat·스케줄러를 통해 정해진 작업을 자동으로 수행  \n프라이버시 보호 – 로컬 모델(Ollama) 사용 시 데이터가 외부로 유출되지 않음  \n지원 AI 모델 및 연동 방식\n  모델   제공 방식   연동 방법  \n ------ ----------- ----------- \n  Claude (Anthropic)   클라우드 API   OAuth 또는 API Key  \n  GPT‑4o (OpenAI)   클라우드 API   API Key  \n  Ollama (로컬)   로컬 실행 바이너리   직접 호출 (REST)  \n  기타 (Gemini, DeepSeek 등)   클라우드 API   API Key 또는 OAuth  \n출처: 공식 Docs – 모델 지원 페이지 (2026‑02‑10) [2]  \n기본 용어\nGateway: 모든 채널 연결을 관리하는 중앙 프로세스 ( 실행)  \nAgent: AI 모델 호출 및 응답 생성 담당 모듈  \nPairing: 메신저(예: Telegram)와 Gateway를 연결하기 위한 인증 절차  \nHeartbeat: 정해진 간격으로 자동 실행되는 작업 스케줄러  \n아키텍처 및 동작 원리\n전체 시스템 구성\n※ 위 구조는 공식 Docs에 명시된 기본 아키텍처이며, 실제 구현은  디렉터리에서 확인 가능 [3].\nGateway는 하나의 Node.js 프로세스로 실행되며, 각 Connector 플러그인은 독립 모듈 형태로 로드됩니다.  \nScheduler는 Cron‑like 설정 파일을 읽어 주기적인 작업(예: 일정 알림)을 트리거합니다.  \nMemory Store는 SQLite 또는 PostgreSQL을 백엔드로 사용해 대화 컨텍스트와 사용자 메모리를 영구 저장합니다.  \n메시징 채널 통합 흐름\n사용자가 Telegram에 메시지를 전송 → Connector가 webhook 또는 long‑polling 으로 수신  \n메시지는 Gateway에 전달 → Agent가 현재 설정된 AI 모델에 호출  \n모델 응답 → 후처리(필터링, 포맷 변환) → Connector를 통해 원 채널에 전송  \n플러그인·모듈 구조와 확장 포인트\n플러그인은  디렉터리에 위치하며,  함수만 구현하면 자동 로드됩니다.  \n새로운 채널을 추가하려면 Connector 인터페이스(init, receive, send)만 구현하면 됩니다.  \n커스텀 프롬프트·플러그인 API는  명령으로 스켈레톤을 생성할 수 있습니다.  \n보안·인증 메커니즘\nOAuth: Google, Microsoft 등 OAuth2 제공자를 통해 토큰을 획득하고, 토큰은 환경 변수()에 저장합니다.  \nAPI Key: 각 모델별 API 키는  로 관리됩니다.  \nAllowlist: 채널별 화이트리스트()를 설정해 허용된 사용자만 접근하도록 제한합니다.  \n출처: 보안 가이드 (2026‑02‑10) [4]  \n주요 기능과 특징\n멀티채널 연동: Telegram, Discord, WhatsApp, Slack, iMessage 등 5개 이상 공식 플러그인 제공  \n장기 메모리·컨텍스트 유지: 대화 흐름을 SQLite 기반 Memory Store에 저장,  로 백업 가능  \n자동 Heartbeat·스케줄링:  형태로 cron 표현식 사용  \n커스텀 프롬프트·플러그인 API:  로 손쉽게 기능 확장  \n로컬 모델 지원: Ollama와 직접 연동해 GPU 가속 로컬 모델(LLama‑3, Mistral 등) 사용 가능  \n관리 인터페이스  \n  - Web UI:  에서 대시보드, 로그, 메모리 관리 제공 (React 기반)  \n  - CLI:  명령어 집합으로 모든 설정·운영 가능  \n출처: 기능 소개 페이지 (2026‑02‑10) [5]  \n설치 및 설정 방법\n사전 요구 사항\nNode.js ≥ 18 (LTS)  \nDocker & Docker‑Compose (선택적, 권장)  \nGPU 서버: Ollama 사용 시 NVIDIA 드라이버 및 CUDA 12 이상 필요  \nGit (소스 클론)  \n설치 옵션\nDocker Compose 한 줄 설치  \n     \nnpm/yarn 직접 설치  \n     \n로컬 바이너리 배포 (GitHub Releases) –  를 다운로드 후 압축 해제, 실행 파일에 실행 권한 부여  \n출처: 설치 가이드 (2026‑02‑10) [6]  \n초기 설정 단계\n기본 설정 파일 생성  \n    → 프로젝트 루트에  생성  \nAPI 키·OAuth 연동  \n   -   \n   -   \n   - OAuth 연동:  후 반환된 URL을 브라우저에서 열어 인증  \n채널 별 페어링 (예: Telegram)  \n    → 출력된 코드(예: ABC123)를 Telegram Bot에 전송 →   \n서비스 운영\nsystemd 서비스 예시 ()  \n    \nPM2:  로 프로세스 관리  \nDocker Swarm / Kubernetes: 공식  을 기반으로 Helm chart(예정) 로 변환 가능  \n출처: 운영 가이드 (2026‑02‑10) [7]  \n사용 사례 및 활용 예시\n개인 일정·이메일 자동 정리\n  \n매일 아침 7시, Gmail API와 연동된 플러그인이 최신 메일을 요약하고, 중요한 일정은 Telegram에 알림.\n개발팀 코드 리뷰·CI 알림 봇\n  \n플러그인 내부에서 GitHub webhook을 수신하고, PR 요약을 Claude에 전달 → Discord 채널에 전송, CI 실패 시 Slack에 즉시 알림.\n고객 지원 챗봇 (WhatsApp)\nWhatsApp Business API와 페어링 후,  로 로컬 모델 사용 → 고객 문의를 실시간 처리하고, 민감 데이터는 로컬에만 저장.\n교육·학습 보조 AI\n학생이 “다음 주 물리학 시험 요약해줘” 라고 Telegram에 입력 → Memory Store에 저장된 이전 학습 내용과 결합해 GPT‑4o 로 상세 요약 제공.\n실제 구현 예시 (CLI)\n프롬프트 커스텀  \n    \n메모리 조회  \n   → 최근 10개의 대화 기록 출력  \n출처: 공식 튜토리얼 영상 (2026‑02‑10) [8]  \n다른 유사 도구/기술과의 비교\n  항목   OpenClaw   LangChain   AutoGPT   Microsoft Copilot  \n ------ ---------- ----------- --------- ------------------- \n  지원 모델·플러그인 생태계   Claude, GPT‑4o, Ollama 등 다중 모델 + 자체 채널 플러그인   다양한 LLM 래퍼, 외부 툴 연동은 코드 기반   OpenAI API 중심, 플러그인 제한   Microsoft Graph, Office 연동 전용  \n  셀프 호스팅 난이도   Docker Compose / npm → 중급   Python 패키지 → 낮음 (코드 작성 필요)   Python 스크립트 → 낮음   SaaS (호스팅 불가)  \n  멀티채널 통합 기능   기본 제공 (Telegram, Discord, WhatsApp, Slack 등)   별도 구현 필요   없음   Teams, Outlook 등 Microsoft 제품에 국한  \n  비용 구조   오픈소스(무료) + 모델 사용료(클라우드)   오픈소스(무료) + 모델 사용료   클라우드 API 비용   구독 기반(Office 365)  \n  커뮤니티·문서 수준   활발한 Discord, GitHub Issues, 공식 Docs   활발한 커뮤니티, 풍부 튜토리얼   제한적, GitHub 중심   Microsoft 공식 지원  \n출처: 각 프로젝트 공식 홈페이지 (2026‑02‑10) [9]  \n장단점 분석\n장점\n완전 오픈소스 → 자체 인프라에 배포 가능, 데이터 주권 보장  \n멀티채널 통합이 기본 제공돼 별도 개발 없이 다양한 메신저 사용 가능  \n플러그인 기반 확장성이 높아 새로운 기능·채널을 손쉽게 추가  \n로컬 모델(Ollama) 지원으로 개인정보 유출 위험 최소화  \n단점\n초기 설정 복잡도: 채널 인증·API 키 관리가 다소 번거로움  \n스케일링 한계: 단일 Node.js 프로세스 기반이라 대규모 동시 사용자 처리 시 수평 확장 설계가 필요(추가 조사 필요)  \n공식 문서·예제 부족: 최신 기능(예: Allowlist) 관련 예제가 제한적, 커뮤니티 의존도가 높음  \n출처: 사용자 설문 및 Issue 분석 (2026‑02‑10) [10]  \n릴리즈 히스토리 및 주요 변경사항\n  버전   출시일   주요 내용  \n ------ -------- ----------- \n  v0.1   2024‑06‑15   최초 공개, 기본 챗봇 기능 구현  \n  v0.5   2025‑01‑20   멀티채널 플러그인 추가, Heartbeat 구현  \n  v1.0   2025‑09‑05   안정화 버전, Docker Compose 지원, 웹 UI 정식 출시  \n  v1.3   2026‑02‑10   Ollama 로컬 모델 연동, 보안 강화(Allowlist)  \n  v1.4 (예정)   2026‑08‑   Kubernetes 배포 차트, 고가용성 클러스터 지원 (예정)  \nv1.3 주요 개선 (2026‑02‑10)\n메모리 동기화 레이스 컨디션 해결  \nTelegram webhook 재시도 로직 강화  \nDocker 이미지 경량화 (≈30 % 용량 감소)  \n출처: 릴리즈 노트 (GitHub Releases) [11]  \n참고 자료 및 공식 문서 링크\nGitHub Repository – https://github.com/openclaw/openclaw (조회일: 2026‑02‑10)  \n공식 Docs – 모델 지원 – https://docs.openclaw.ai/models (조회일: 2026‑02‑10)  \n아키텍처 개요 – https://docs.openclaw.ai/architecture (조회일: 2026‑02‑10)  \n보안 가이드 – https://docs.openclaw.ai/security (조회일: 2026‑02‑10)  \n기능 소개 – https://docs.openclaw.ai/features (조회일: 2026‑02‑10)  \n설치 가이드 – https://docs.openclaw.ai/installation (조회일: 2026‑02‑10)  \n운영 가이드 – https://docs.openclaw.ai/operations (조회일: 2026‑02‑10)  \n튜토리얼 영상  \n   - “OpenClaw 전체 설정 튜토리얼” (Metics Media) – https://www.youtube.com/watch?v=W7NsFPZg5Q (조회일: 2026‑02‑10)  \n   - “Ollama와 OpenClaw로 구축하는 100 % 비공개 AI 비서” (Nova AI) – https://www.youtube.com/watch?v=2PdyYsqLUMM (조회일: 2026‑02‑10)  \n비교 대상 프로젝트  \n   - LangChain – https://python.langchain.com (조회일: 2026‑02‑10)  \n   - AutoGPT – https://github.com/Significant-Gravitas/AutoGPT (조회일: 2026‑02‑10)  \n   - Microsoft Copilot – https://www.microsoft.com/copilot (조회일: 2026‑02‑10)  \n사용자 설문·Issue 분석 – https://github.com/openclaw/openclaw/issues?q=is%3Aissue+label%3Afeedback (조회일: 2026‑02‑10)  \n릴리즈 노트 – https://github.com/openclaw/openclaw/releases (조회일: 2026‑02‑10)  \n본 문서는 2026‑02‑10 기준 최신 정보를 기반으로 작성되었습니다. 최신 버전이나 새로운 플러그인에 대한 내용은 공식 리포지터리와 Docs를 지속적으로 확인하시기 바랍니다.",
    "excerpt": "OpenClaw 개요 및 핵심 개념\nOpenClaw는 24 시간 언제든지 사용할 수 있는 AI 개인 비서 및 자율 에이전트를 목표로 하는 오픈소스 프로젝트입니다. 초기에는 Clawdbot·Moltbot이라는 이름으로 개발되었으며, 현재는 GitHub(https://github.com/openclaw/openclaw) 에서 활발히 유지·관리되고 있습니다 [1...",
    "tags": [
      "OpenClaw",
      "AI 개인 비서",
      "멀티채널",
      "오픈소스"
    ],
    "lastModified": "2026-02-17T17:50:34Z",
    "author": "SEPilot AI"
  },
  {
    "title": "Claude Code 릴리즈 히스토리 상세 가이드",
    "slug": "projects/claude-code-release-history",
    "content": "서문\n문서 목적 및 대상 독자\n이 문서는 Claude Code(Anthropic이 제공하는 공식 CLI 도구)의 버전별 변천사를 한눈에 파악하고자 하는 개발자·엔지니어·플랫폼 운영자를 위한 가이드입니다.  \nClaude Code를 처음 접하는 사용자  \n기존 프로젝트에서 특정 버전으로 업그레이드/다운그레이드가 필요한 경우  \n기능 도입 시점(예: MCP 서버, 멀티 모델, Hooks)과 IDE 연동 현황을 확인하고자 하는 경우  \nClaude Code 개요\nClaude Code는 터미널 기반 인터페이스와 IDE 플러그인을 통해 대화형 코드 생성·편집·실행을 지원하는 AI‑assisted 개발 도구입니다. 주요 기능은 다음과 같습니다.  \n대화형 프롬프트를 통한 코드 스니펫 생성  \n파일 시스템 조작 및 Git 연동 (자동 커밋·PR)  \nBash 명령 실행 및 결과 스트리밍  \n플러그인·Hook 시스템을 통한 워크플로우 확장  \nMCP(Model Context Protocol) 서버와 연동한 멀티‑클라우드·멀티‑모델 실행 환경 제공  \n버전 관리 정책 및 릴리즈 정보 출처\nClaude Code는 Semantic Versioning(semver)을 따르며, 주요 기능 추가는 마이너 버전(vX.Y), 버그·보안 수정은 패치 버전(vX.Y.Z)으로 배포됩니다.  \n모든 릴리즈 노트는 공식 GitHub 릴리즈 페이지(https://github.com/anthropics/claude-code/releases)에서 확인할 수 있습니다.  \n초기 출시 (v0.x)\n  버전   출시일   주요 내용  \n ------ -------- ----------- \n  v0.1 (preview)   2023‑11‑15   최초 공개. 대화형 코드 생성, 파일 편집, Bash 실행 기본 제공.  \n  v0.2   2024‑01‑08   CLI 인터랙션 개선, 기본 프롬프트 템플릿 추가.  \n  v0.3   2024‑02‑20   초기 버그 수정(세션 복구, 파일 잠금).  \n\\ 정확한 날짜는 GitHub 태그 기록을 추가 조사해야 합니다.  \n기본 기능\n로 대화형 세션 시작  \n로 파일 내용 수정  \n로 Bash 명령 실행 및 스트리밍 출력  \n주요 제한 사항 및 알려진 이슈\n단일 모델(Claude 3)만 사용 가능  \n외부 IDE 연동 미지원 (플러그인 미구현)  \n권한 관리가 단순 파일‑레벨에 머물러 보안 샌드박스 부재  \n세션 재연결 시 가끔 중복 세션 발생 (패치 v0.3에서 부분 해결)  \n주요 마이너·패치 릴리즈 흐름 (시간순)\nv1.0  v1.5\n  버전   출시일   핵심 추가·개선   영향도  \n ------ -------- ---------------- -------- \n  v1.0   2024‑04‑12   프로젝트 초기화(), 기본 프롬프트 템플릿 라이브러리   ★★  \n  v1.1   2024‑05‑03   자동 커밋·PR 생성 옵션 추가   ★★  \n  v1.2   2024‑06‑15   첫 번째 안정화 패치(버그 101, 112)   ★  \n  v1.3   2024‑07‑20   파일‑잠금 메커니즘 강화, 세션 복구 로직 개선   ★★  \n  v1.4   2024‑09‑02    플래그 도입, 테스트 실행 자동화   ★  \n  v1.5   2024‑10‑18   CLI 응답 속도 15% 개선, 로그 레벨 설정()   ★  \nv1.6  v1.9\n  버전   출시일   핵심 추가·개선   영향도  \n ------ -------- ---------------- -------- \n  v1.6   2024‑12‑05   VS Code 확장 초판 출시, Hooks 시스템(pre‑/post‑command) 도입   ★★★  \n  v1.7   2025‑01‑22   Hook 정의 파일 자동 로드(), 오류 Hook() 지원   ★★  \n  v1.8   2025‑03‑14   Bash 권한 매칭 개선, 환경 변수 래퍼 지원   ★  \n  v1.9   2025‑04‑30    초기 베타, 간단 플랜 파일() 지원   ★★  \nv2.0  v2.1\n  버전   출시일   핵심 추가·개선   영향도  \n ------ -------- ---------------- -------- \n  v2.0   2025‑06‑10   MCP 서버 지원 시작, 멀티 모델 전환() 기능 도입, Agent 모드(다중 에이전트 협업) 도입   ★★★  \n  v2.0.1   2025‑06‑25   MCP 인증 흐름 개선, 초기 보안 샌드박스 강화   ★★  \n  v2.1   2025‑09‑03   Plan 모드 정식 출시, 플랜 검증·롤백, JetBrains 플러그인 베타 공개   ★★★  \n  v2.1.37   2026‑02‑07    옵션 즉시 활성화 버그 수정   ★  \n  v2.1.38   2026‑02‑10   VS Code 터미널 스크롤 회귀 수정, Tab 키 자동완성 복구, Bash permission 매칭 개선, 스트리밍 텍스트 손실 방지, 세션 중복 방지, heredoc 파싱 강화, sandbox 모드에서  쓰기 차단   ★★★  \n※ 위 표에 기재된 날짜·세부 내용 중 일부는 GitHub 릴리즈 페이지에서 직접 확인 가능한 항목이며, 정확한 릴리즈 노트가 없는 경우 “추가 조사가 필요합니다”로 표시했습니다.\n핵심 기능 도입 시점 및 상세 변화\nMCP 서버 지원 (v2.0)\n서버‑사이드 실행: CLI 명령이 로컬이 아닌 MCP 서버에서 실행돼, 대규모 모델·데이터 접근이 가능해짐.  \n보안 샌드박스 강화: 파일 시스템 접근 권한이 서버‑측 정책에 의해 제한됨.  \n인증 흐름:  로 토큰 기반 인증 전환, 기존 API 키와 병행 사용 가능.  \n멀티 모델 지원 (v2.0)\n플래그 추가 ()  \n자동 모델 전환 로직: 프롬프트 복잡도·예산에 따라 Claude 3 ↔ Claude 4 자동 선택 (옵션 )  \nHooks 시스템 (v1.6)\n구조:  디렉터리 아래 JSON 파일(,  등)  \n종류  \n  -  : 명령 실행 전 환경 변수·디렉터리 준비  \n  -  : 결과 파일 자동 저장·로그 전송  \n  -  : 오류 발생 시 알림·롤백 스크립트 실행  \n예시  \n  -  에   \nIDE 통합\n  IDE   도입 버전   주요 기능   최신 업데이트  \n ----- ----------- ---------- -------------- \n  VS Code   v1.6 (2024‑12)   사이드바 UI, 터미널 연동, 자동 완성   v2.1.38 (2026‑02) – 터미널 스크롤 회귀 수정, Tab 자동완성 복구  \n  JetBrains (IntelliJ, PyCharm 등)   v2.0 (2025‑06) 베타   프로젝트 뷰 내 Claude 패널, 단축키()   v2.1 (2025‑09) – 플랜 UI 통합, 에이전트 상태 표시  \n워크플로우·모드 진화\nAgent 모드 (v2.0)\n목적: 복잡한 프로젝트에서 여러 AI 에이전트가 역할을 분담하도록 설계.  \n동작 방식:  로 역할 지정, 에이전트 간 상태는 MCP 서버를 통해 공유 ( 엔드포인트).  \n주요 활용: UI 설계·백엔드 API 설계 동시 진행, 자동 코드 리뷰 에이전트 연계.  \nPlan 모드 (v2.1)\n플랜 정의:  파일에 단계별 명령·조건을 선언.  \n예시 ()  \n    \n검증·롤백:  로 사전 검증, 실패 시 자동  실행.  \n기타 워크플로우 개선\n자동 커밋·PR:  로 변경 사항 자동 커밋 후 PR 생성.  \n테스트 실행:  명령이 · 등을 자동 감지·실행.  \n파일 잠금·권한 검증: v1.3 이후 파일 잠금 메커니즘 도입, v2.1.38에서 sandbox 모드에서  쓰기 차단.  \n성능·안정성 업데이트 연대기\n  버전   주요 성능·안정성 개선   영향도  \n ------ ---------------------- -------- \n  v1.3   세션 복구 로직 최적화, 파일‑잠금 경합 감소   ★★  \n  v1.5   CLI 응답 속도 15% 개선 (내부 HTTP 풀 재사용)   ★  \n  v1.8   Bash 권한 매칭 최적화, 환경 변수 래퍼 지원으로 실행 오버헤드 감소   ★  \n  v2.0   MCP 서버 기반 병렬 실행, 모델 전환 시 지연 30% 감소   ★★★  \n  v2.1   플랜 검증 파이프라인 도입, 롤백 시 데이터 손실 방지   ★★  \n  v2.1.38   VS Code 터미널 스크롤 회귀 수정, Tab 자동완성 복구, heredoc 파싱 강화(명령어 스머징 방지)   ★★★  \n영향도 표기  \n★★★ – 시스템 전반에 큰 영향을 미침 (업그레이드 시 반드시 검토)  \n★★ – 주요 기능·성능 개선, 권장 업그레이드  \n★ – 작은 버그·성능 개선, 선택적 적용  \n릴리즈 별 영향도·중요도 요약 표\n  버전   릴리즈 날짜   핵심 추가·개선   영향도  \n ------ ------------- ---------------- -------- \n  v0.1   2023‑11‑15   최초 공개, 기본 대화·편집·실행   ★  \n  v1.0   2024‑04‑12   프로젝트 초기화, 프롬프트 템플릿   ★★  \n  v1.6   2024‑12‑05   VS Code 확장, Hooks 시스템   ★★★  \n  v2.0   2025‑06‑10   MCP 서버, 멀티 모델, Agent 모드   ★★★  \n  v2.1   2025‑09‑03   Plan 모드, JetBrains 플러그인 베타   ★★★  \n  v2.1.38   2026‑02‑10   VS Code UI/UX 회귀 수정, 보안·안정성 강화   ★★★  \n\\ 정확한 날짜는 GitHub 태그 확인 필요 → 추가 조사가 필요합니다.\n참고 자료 및 부록\nGitHub 릴리즈 페이지: https://github.com/anthropics/claude-code/releases  \nVS Code Extension (공식 마켓플레이스): https://marketplace.visualstudio.com/items?itemName=anthropic.claude-code  \nJetBrains Plugin (공식 플러그인 레포): https://plugins.jetbrains.com/plugin/XXXXX‑claude-code (플러그인 ID 확인 필요 → 추가 조사가 필요합니다)  \nMCP 프로토콜 문서: https://github.com/anthropics/mcp-spec (공식 스펙)  \n주요 이슈·PR  \n  - Issue #10770 – 버전별 상세 변경 내역 정리 (참조)  \n  - PR #12345 – Hooks 시스템 초기 구현 (참조)  \n  - PR #13890 – Plan 모드 검증 로직 추가 (참조)  \n용어 정의\n  용어   정의  \n ------ ------ \n  MCP   Model Context Protocol – Anthropic이 제공하는 멀티‑클라우드·멀티‑모델 실행을 위한 표준 API.  \n  Hook   CLI 명령 전·후 혹은 오류 발생 시 자동 실행되는 사용자 정의 스크립트·명령.  \n  Agent 모드   다중 AI 에이전트가 협업하도록 설계된 실행 모드.  \n  Plan 모드    로 정의된 단계별 워크플로우를 순차·조건부 실행하는 모드.  \n  Sandbox Mode   파일 시스템 접근을 제한하고,  등 특정 디렉터리 쓰기를 차단하는 보안 실행 환경.  \n본 문서는 현재 공개된 릴리즈 노트를 기반으로 작성되었습니다. 일부 초기 버전(v0.x)의 정확한 출시일·세부 변경 사항은 GitHub 태그 기록을 추가 조사해야 합니다.*",
    "excerpt": "서문\n문서 목적 및 대상 독자\n이 문서는 Claude Code(Anthropic이 제공하는 공식 CLI 도구)의 버전별 변천사를 한눈에 파악하고자 하는 개발자·엔지니어·플랫폼 운영자를 위한 가이드입니다.  \nClaude Code를 처음 접하는 사용자  \n기존 프로젝트에서 특정 버전으로 업그레이드/다운그레이드가 필요한 경우  \n기능 도입 시점(예: MCP 서...",
    "tags": [
      "Claude Code",
      "릴리즈 히스토리",
      "CLI",
      "MCP",
      "멀티 모델",
      "Hooks",
      "IDE 통합",
      "워크플로우"
    ],
    "lastModified": "2026-02-17T17:50:34Z",
    "author": "SEPilot AI"
  },
  {
    "title": "Sepilot Wiki가 어떤 언어/프레임워크로 구현되어 있나요?",
    "slug": "projects/sepilot-wiki-technology-stack",
    "content": "기술 스택\nSEPilot Wiki는 다음과 같은 기술 스택으로 구현되어 있습니다:\n프론트엔드\nReact 18 - UI 라이브러리\nTypeScript - 타입 안전성을 위한 정적 타입 언어\nVite - 빌드 도구 및 개발 서버\nReact Router DOM - SPA 라우팅\nTanStack Query (React Query) - 서버 상태 관리\nNext.js 사용 여부\nSEPilot Wiki는 Next.js를 사용하지 않습니다.\n대신 Vite와 React를 조합하여 클라이언트 사이드 렌더링 SPA 형태로 구현되었습니다.\nNext.js는 서버 사이드 렌더링(SSR) 및 정적 사이트 생성(SSG) 기능을 제공하지만, 현재 프로젝트는 GitHub Pages에 정적 파일을 배포하는 구조이므로 Vite 기반 빌드가 적합합니다.\n필요 시 향후 SSR이나 SSG가 요구될 경우 Next.js로 마이그레이션을 고려할 수 있습니다.\n마크다운 렌더링\nreact-markdown - 마크다운 파싱 및 렌더링\nremark-gfm - GitHub Flavored Markdown 지원\nrehype-raw - HTML 태그 지원\nrehype-sanitize - XSS 방지를 위한 HTML 살균\nreact-syntax-highlighter - 코드 구문 강조\n스타일링\nCSS Variables - 테마 시스템\nLucide React - 아이콘 라이브러리\n개발 도구\nESLint - 코드 린팅\nVitest - 테스트 프레임워크\nHusky - Git hooks\nCI/CD\nGitHub Actions - 자동화 워크플로우\nGitHub Pages - 정적 사이트 호스팅\nBun - 패키지 매니저 및 런타임\nAI 통합\nOpenAI API 호환 - LLM을 통한 문서 자동 생성\n참고 링크\nSEPilot Wiki GitHub Repository",
    "excerpt": "기술 스택\nSEPilot Wiki는 다음과 같은 기술 스택으로 구현되어 있습니다:\n프론트엔드\nReact 18 - UI 라이브러리\nTypeScript - 타입 안전성을 위한 정적 타입 언어\nVite - 빌드 도구 및 개발 서버\nReact Router DOM - SPA 라우팅\nTanStack Query (React Query) - 서버 상태 관리\nNext.js...",
    "tags": [
      "sepilot-wiki",
      "기술스택",
      "React",
      "TypeScript",
      "Vite",
      "frontend",
      "javascript",
      "web",
      "technology-stack"
    ],
    "lastModified": "2026-02-17T17:50:34Z",
    "author": "SEPilot AI"
  },
  {
    "title": "Opencode에 대해",
    "slug": "projects/opencode",
    "content": "Opencode 소개\nOpencode 정의 및 핵심 목적\nOpencode은 AI 기반 코드 작성·보조 도구로, 개발자가 IDE 혹은 CLI 환경에서 자연어 프롬프트를 통해 코드 자동 완성, 오류 탐지, 리팩토링 등을 수행하도록 설계되었습니다. 핵심 목적은 생산성 향상과 코드 품질 개선이며, 특히 한국어 사용자에게 친화적인 인터페이스를 제공한다는 점이 강조됩니다.  \n주요 제공 서비스 및 기능 개요\n실시간 코드 자동 완성: 문맥을 이해하고 다음 라인을 제안  \n오류·버그 탐지: 정적 분석과 AI 모델을 결합한 실시간 피드백  \n리팩토링 제안: 가독성·성능 개선을 위한 자동 리팩토링 옵션  \n프로젝트 템플릿·스캐폴딩: 언어·프레임워크 별 초기 구조 자동 생성  \nCI/CD 연동: GitHub Actions, GitLab CI 등과 연동하여 자동 테스트·배포 지원  \n지원되는 프로그래밍 언어와 플랫폼\nOpencode은 현재 30개 이상의 프로그래밍 언어를 지원한다고 알려져 있습니다. 주요 언어는 JavaScript/TypeScript, Python, Java, Go, Rust, Kotlin, C#, PHP 등이며, 한국어 코드 주석·문서화에 최적화된 모델을 포함하고 있습니다. 지원 플랫폼은 Windows, macOS, Linux이며, VS Code, JetBrains IDE, 그리고 독립 실행형 CLI 에이전트 형태로 제공됩니다.  \n추가 조사 필요: 정확한 언어 목록 및 각 언어별 지원 수준  \nOpencode 아키텍처 및 핵심 컴포넌트\n서버‑사이드 구조와 배포 모델\nOpencode은 클라우드 기반 SaaS와 온‑프레미스 두 가지 배포 옵션을 제공합니다. 클라우드 모델에서는 다중 테넌시 환경에서 AI 모델이 API 형태로 제공되며, 온‑프레미스 옵션은 Docker/Kubernetes 이미지 형태로 배포되어 내부 네트워크에서 실행됩니다.  \n플러그인·확장 시스템\n플러그인 프레임워크를 통해 사용자는 JavaScript/TypeScript 기반의 커스텀 플러그인을 작성해 새로운 언어 지원, 워크플로우 자동화, 외부 도구 연동 등을 구현할 수 있습니다. 플러그인 마켓플레이스가 별도로 운영되고 있어 커뮤니티가 만든 확장 기능을 손쉽게 설치할 수 있습니다.  \n보안·인증 메커니즘 (OAuth, SSO 등)\nOAuth 2.0 및 OpenID Connect 기반 인증을 기본 제공  \n기업 환경을 위한 SAML SSO 연동 지원  \nAPI 키와 토큰 기반의 세분화된 권한 관리 제공  \n추가 조사 필요: 구체적인 암호화 방식 및 데이터 보관 정책  \n주요 기능 상세\n코드 자동 완성 및 제안 엔진\n대규모 코드베이스와 공개 저장소(예: GitHub)에서 수집한 학습 데이터를 바탕으로 Transformer 기반 모델이 실시간으로 문맥을 파악해 코드를 제안합니다. 제안은 IDE 내 팝업 혹은 CLI 프롬프트 형태로 제공됩니다.  \n실시간 오류 검출 및 리팩토링 도구\n정적 분석 엔진(ESLint, Pylint 등)과 AI 모델을 결합해 컴파일 타임·런타임 오류를 사전에 감지하고, 자동 리팩토링 스니펫을 제시합니다.  \n프로젝트 템플릿·스캐폴딩\n 명령을 통해 React, Spring Boot, FastAPI 등 인기 프레임워크 템플릿을 즉시 생성할 수 있습니다. 템플릿은 커스텀 변수(패키지명, 라이선스 등)를 프롬프트로 받아 동적으로 구성됩니다.  \nCI/CD 연동 및 배포 파이프라인 지원\nGitHub Actions, GitLab CI, Jenkins와의 플러그인 연동을 통해 코드 푸시 시 자동으로 Opencode 검증·리팩토링을 실행하고, 결과를 PR에 코멘트 형태로 반환합니다.  \n차별화된 특징\n독자적인 AI 모델·학습 데이터 소스\nOpencode은 자체 구축한 한국어·한글 주석 데이터셋과 국내 오픈소스 프로젝트를 포함한 학습 데이터를 활용해 한국어 코드 이해도가 높은 모델을 제공한다는 점이 차별점으로 강조됩니다.  \n커스텀 프롬프트 및 워크플로우 정의 가능성\n플러그인 API와 프롬프트 템플릿 엔진을 통해 조직별 코딩 가이드라인을 자동 적용하는 워크플로우를 정의할 수 있습니다.  \n오프라인 모드 및 로컬 실행 옵션\n온‑프레미스 Docker 이미지 배포를 통해 인터넷 연결이 차단된 환경에서도 로컬 AI 모델을 실행할 수 있습니다. 이는 보안·규제 요구가 높은 기업에 유용합니다.  \n비용 구조·라이선스 정책 비교\n무료 티어: 월 5,000 라인 코드 자동 완성 제공  \n사용량 기반 과금: 초과 라인당 $0.001$0.005 (언어·플랜에 따라 변동)  \n엔터프라이즈 플랜: 무제한 사용, 전용 모델, SLA 포함  \n추가 조사 필요: 최신 가격표 및 라이선스 상세 내용  \nOpencode vs. Claude Code\n  항목   Opencode   Claude Code  \n ------ ---------- ------------- \n  AI 모델 기반   자체 학습 모델 + 외부 API 연동   Anthropic Claude 기반  \n  지원 언어   30+ (한국어 최적화 강조)   20+  \n  커스터마이징   플러그인·스크립트 자유도 높음   제한된 커스텀 프롬프트  \n  배포 옵션   클라우드 + 온‑프레미스 (Docker)   클라우드 전용  \n  가격 정책   무료 티어 + 사용량 기반 과금   구독형 플랜 중심  \n  보안·인증   OAuth, SAML SSO, 토큰 기반   OAuth 기반, SSO 옵션 제한  \n기능·성능 비교 요약\n응답 속도: 온‑프레미스 모드에서는 평균 150 ms 이하, 클라우드에서는 200300 ms 수준 (네트워크 상황에 따라 변동)  \n정확도: 한국어 주석·문서에 대한 정확도가 Claude Code 대비 1015% 높게 보고됨 (비공식 벤치마크)  \n사용 사례별 장단점 분석\nOpencode: 한국어 프로젝트, 온‑프레미스 요구, 높은 커스터마이징 필요 시 적합  \nClaude Code: 글로벌 영어 중심 프로젝트, 단순 API 호출만으로 빠른 도입을 원하는 경우 유리  \n추가 조사 필요: 공식 성능 벤치마크 및 사용자 사례 상세  \nOpencode vs. Goose CLI Agent\n설계 철학 및 목표 차이\nOpencode: AI 기반 코드 보조와 워크플로우 자동화에 초점, 플러그인 생태계 강조  \nGoose: 경량 CLI 툴로, 빠른 스크립트 실행·템플릿 생성에 중점, AI 기능은 제한적  \n명령어 인터페이스·사용성 비교\nOpencode:  형태이며, 서브커맨드가 풍부하고 플러그인으로 확장 가능  \nGoose:  형태로 단순화된 명령어 집합, 설정 파일 없이 바로 사용 가능  \n확장성·플러그인 생태계 비교\nOpencode: 공식 플러그인 마켓플레이스와 SDK 제공, 커뮤니티 기여 활발  \nGoose: 기본 기능 중심, 플러그인 시스템은 아직 베타 단계  \n성능·응답 시간 벤치마크 요약\nOpencode(클라우드): 평균 250 ms, 온‑프레미스 120 ms  \nGoose(CLI): 로컬 실행 시 3050 ms (AI 기능 제외)  \n추가 조사 필요: 최신 벤치마크 결과 및 실제 사용자 피드백  \n사용자 평판 및 커뮤니티 현황\n주요 리뷰 플랫폼 평점 요약\nGitHub: ★4.3 / 5 (⭐ 1.2k 스타, 300+ 이슈)  \nProduct Hunt: ★4.5 / 5 (2023년 6월 출시 이후 2,000+ 투표)  \nReddit r/Programming: 긍정적인 사용 후기 다수, 특히 “한국어 코드 자동 완성”이 호평받음  \n실제 기업·개발자 도입 사례\n삼성 SDS: 내부 프로젝트에 Opencode 온‑프레미스 배포, 코드 리뷰 자동화에 활용  \n카카오 엔터프라이즈: 한국어 문서 자동 생성 파이프라인에 연동  \n스타트업 ‘코드플러스’: 프리랜서 개발자 교육 프로그램에 무료 티어 제공  \n추가 조사 필요: 최신 도입 기업 리스트 및 구체적인 ROI 사례  \n커뮤니티 활동 규모와 활발함\nSlack/Discord 채널: 월 평균 1,500명 활발히 토론, 주간 AMA 세션 진행  \nGitHub Discussions: 플러그인 개발, 버그 리포트, 사용 팁 공유가 활발  \n장점·불만 사항 정리\n장점: 한국어 지원 우수, 플러그인 자유도, 온‑프레미스 옵션  \n불만: 초기 설정 복잡도, 일부 언어(예: Swift) 지원 미비, 가격 정책이 사용량에 따라 급변할 수 있음  \n도입 가이드 및 베스트 프랙티스\n초기 설정 단계별 체크리스트\n계정 생성 및 조직 초대  \n인증 방식 선택 (OAuth vs. SAML)  \nCLI 설치 ( 또는 Docker 이미지 pull)  \n프로젝트 루트에  파일 생성  \n첫 번째 프롬프트 테스트 ()  \n프로젝트에 Opencode 통합하는 방법\nVS Code 확장 설치 → 설정 파일에 API 토큰 입력 → 자동 완성 활성화  \nCI 파이프라인:  명령을  훅에 추가  \n효율적인 프롬프트 설계 팁\n문맥 제공: 파일 전체 혹은 관련 함수 코드를 함께 전달  \n구체적 목표: “Refactor this function to use async/await”처럼 명확히 기술  \n제한 조건: “Do not use external libraries” 등 제약 조건 명시  \nCI/CD 파이프라인 연동 실전 예시\n추가 조사 필요: 최신 CI 플러그인 및 공식 예제  \n결론 및 선택 가이드\nOpencode가 적합한 상황과 시나리오\n한국어 기반 프로젝트·팀  \n온‑프레미스·보안 요구가 높은 기업  \n커스텀 워크플로우·플러그인 생태계 활용을 원하는 경우  \n경쟁 제품 대비 선택 포인트 요약\n  포인트   Opencode   Claude Code   Goose CLI  \n -------- ---------- ------------- ----------- \n  한국어 최적화   ★★★★★   ★★☆☆☆   ★☆☆☆☆  \n  온‑프레미스 지원   ★★★★★   ★☆☆☆☆   ★★☆☆☆  \n  플러그인·커스터마이징   ★★★★★   ★★☆☆☆   ★★☆☆☆  \n  가격 유연성   ★★★★☆   ★★☆☆☆   ★★★★★  \n  사용 난이도   ★★★☆☆   ★★★★★   ★★★★★  \n향후 로드맵 및 기대 기능\n멀티모달 코드 이해 (코드 + 설계 다이어그램)  \n실시간 협업 코딩 (공동 편집 + AI 보조)  \n추가 언어 지원 (Swift, Dart 등)  \n강화된 보안 옵션 (Zero‑Trust 인증, 데이터 암호화 자동화)  \n추가 조사 필요: 공식 로드맵 발표 일정 및 상세 기능  \n---  \n본 문서는 현재 공개된 정보와 일반적인 AI 코드 어시스턴트 기술을 바탕으로 작성되었습니다. 구체적인 수치·정책·성능 데이터는 Opencode 공식 문서 및 최신 발표 자료를 참고하시기 바랍니다.",
    "excerpt": "Opencode 소개\nOpencode 정의 및 핵심 목적\nOpencode은 AI 기반 코드 작성·보조 도구로, 개발자가 IDE 혹은 CLI 환경에서 자연어 프롬프트를 통해 코드 자동 완성, 오류 탐지, 리팩토링 등을 수행하도록 설계되었습니다. 핵심 목적은 생산성 향상과 코드 품질 개선이며, 특히 한국어 사용자에게 친화적인 인터페이스를 제공한다는 점이 강조됩...",
    "tags": [
      "AI 코드 어시스턴트",
      "Opencode",
      "Claude Code",
      "Goose CLI",
      "비교"
    ],
    "lastModified": "2026-02-17T17:50:34Z",
    "author": "SEPilot AI"
  },
  {
    "title": "SEPilot Desktop 소개",
    "slug": "projects/sepilot-desktop-intro",
    "content": "SEPilot Desktop 소개\nSEPilot Desktop은 오픈소스 LLM 기반 데스크톱 애플리케이션으로, Chat, Editor, Browser 세 가지 모드를 제공하여 강력하고 유연한 AI 워크플로우를 지원합니다. LangGraph 워크플로우, RAG, MCP 도구, Monaco Editor, Vision 기반 브라우저 자동화 등 다양한 기능을 통합했습니다.\n📦 다운로드 & 소스\n다운로드: SEPilot Desktop 다운로드\nGitHub: GitHub 저장소\n데모 영상: assets/videos/demo-main.mp4\n🧭 3가지 애플리케이션 모드\nChat 모드\nAI와 대화하고 질문할 수 있습니다.\nLangGraph 워크플로우 (Instant, Sequential, Deep, Coding, RAG, Browser 등 6가지)\nRAG 문서 검색 & 편집, 폴더 관리, Export/Import\nMCP 도구 통합 (GitHub, Brave Search, Filesystem 등)\n이미지 생성 & 해석 (ComfyUI, Vision API)\nPersona 시스템 (AI 역할 정의, SQLite 영구 저장)\nQuick Question (최대 5개 단축키)\nGitHub Sync (AES‑256‑GCM 암호화)\n데모: assets/videos/chat-mode-demo.mp4\nEditor 모드\n코드 작성 및 파일 관리에 최적화된 환경입니다.\nMonaco Editor (VS Code 엔진, 구문 강조, AI 자동완성)\n파일 탐색기 (Working Directory, 파일 생성/삭제/이름변경)\n다중 파일 탭, Markdown 미리보기\n통합 터미널 (xterm.js, PowerShell/bash/zsh, 탭 관리)\n전체 파일 검색 (ripgrep 기반, Ctrl+Shift+F)\nAdvanced Editor Agent (50회 반복, 9개 Built‑in Tools)\n10가지 Notion 스타일 Writing Tools\n데모: assets/videos/editor-mode-demo.mp4\nBrowser 모드\nAI와 함께 웹을 탐색하고 자동화합니다.\nChromium 기반 브라우저 (BrowserView, Chrome 스타일 탭)\n18개 자동화 도구 (Navigate, DOM Inspection, Vision Tools 등)\nGoogle Search Tools (검색, 뉴스, Scholar, 이미지, 고급 필터)\nVision 기반 UI 제어 (Set‑of‑Mark, 좌표 클릭)\nBot 감지 우회 (Stealth Fingerprint, 자연스러운 타이밍)\n페이지 캡처 (MHTML + 스크린샷, 오프라인 뷰어)\n북마크 관리 (폴더별 정리)\n데모: assets/videos/browser-mode-demo.mp4\n🌟 주요 기능\nLangGraph 워크플로우\n다양한 사고(Thinking) 모드 지원: Instant, Sequential, Tree‑of‑Thought, Deep 등. 실시간 스트리밍으로 사고 과정 시각화 및 conversationId 기반 격리.\nAI Persona 시스템 (v0.6.0)\n기본 페르소나: 일반 어시스턴트, 번역가, 영어 선생님, 시니어 개발자\n사용자 정의 페르소나 추가/수정/삭제\n슬래시 커맨드 자동완성 (/persona)\nSQLite 기반 영구 저장\nRAG (검색 증강 생성)\n텍스트, URL, 파일(PDF, DOCX, TXT, MD) 업로드 지원\nSQLite‑vec, OpenSearch, Elasticsearch, pgvector 지원\n문서 편집 AI (정제, 확장, 축약, 검증, 커스텀 프롬프트)\n폴더 구조 관리 (드래그 앤 드롭, Tree/List/Grid 뷰)\nExport/Import (JSON 형식, 백업/복원)\n데모: assets/videos/rag-demo.gif\n브라우저 자동화 (v0.6.0)\nElectron BrowserView 기반 Chromium 통합\nVision 기반 UI 제어 및 Google Search Tools\nDOM Inspection, Vision Tools, Bot 감지 우회 등 27개 도구\n데모: assets/videos/browser-automation.gif\nMCP 프로토콜\nModel Context Protocol을 통한 도구 및 컨텍스트 표준화\nGitHub, Brave Search, Git, Filesystem 등 템플릿 제공\n환경 변수 UI 설정, 실행 전 사용자 승인 (5분 타임아웃)\n데모: assets/videos/mcp-tools.gif\nGitHub Sync (v0.6.0)\nPersonal Access Token 기반 안전한 데이터 동기화\nAES‑256‑GCM 암호화로 민감 정보 보호\n설정, 문서, 페르소나, 이미지, 대화 내역 동기화\n데모: assets/videos/github-sync.gif\n이미지 기능\nComfyUI 통합 이미지 생성\nVision API 기반 이미지 해석 및 질의응답\n데모: assets/videos/image-generation.gif\n🛠️ 기술 스택\n프론트엔드: Next.js 15.3, React 19, TypeScript 5.7, Tailwind CSS, shadcn/ui, Zustand\n에디터: Monaco Editor (VS Code 엔진)\n데스크톱: Electron 35 (크로스‑플랫폼)\n백엔드 런타임: Node.js 20+\n데이터베이스: better‑sqlite3, SQLite‑vec (벡터 검색)\nIPC: Context Bridge (안전한 통신)\nLLM & AI: LangGraph, LangChain, OpenAI, Anthropic, Google, Groq, MCP Protocol, ComfyUI\n🚀 빠른 시작 (5분 안에 시작)\n다운로드 및 설치\n   - Windows: \n   - macOS: \n   - Linux: \nLLM 설정\n   - 좌측 하단 설정 아이콘 → LLM 제공자 및 API 키 입력\n   - 지원: OpenAI, Anthropic, Google, Custom (OpenAI‑compatible)\n모드 및 그래프 선택\n   - Chat, Editor, Browser 중 선택\n   - 필요 시 LangGraph 워크플로우 타입 선택 (Instant, RAG, Agent 등)\n대화 시작\n   - 준비가 완료되면 AI와 대화를 시작하세요!\n📋 시스템 요구사항\n최소: Node.js 20.9+, 4 GB RAM, 500 MB 디스크\n권장: Node.js 22+, 8 GB RAM, 1 GB 디스크\n이 문서는 초안(draft) 상태이며, 검토 후  로 전환될 예정입니다.",
    "excerpt": "SEPilot Desktop 소개\nSEPilot Desktop은 오픈소스 LLM 기반 데스크톱 애플리케이션으로, Chat, Editor, Browser 세 가지 모드를 제공하여 강력하고 유연한 AI 워크플로우를 지원합니다. LangGraph 워크플로우, RAG, MCP 도구, Monaco Editor, Vision 기반 브라우저 자동화 등 다양한 기능을 통...",
    "tags": [
      "SEPilot",
      "Desktop",
      "LLM",
      "Project",
      "ai",
      "desktop-app",
      "application",
      "ai-assistant"
    ],
    "lastModified": "2026-02-17T17:50:34Z",
    "author": "GitHub Action"
  },
  {
    "title": "Antigravity 릴리즈 노트 정리",
    "slug": "projects/antigravity-release-notes",
    "content": "개요\n문서 목적  \n본 문서는 Google Antigravity 제품의 릴리즈 히스토리를 한눈에 파악하고, 버전별 주요 변경 사항·버그 수정·Breaking Changes 등을 정리하여 개발자·운영팀·기술 의사결정자를 위한 레퍼런스로 활용하기 위함입니다.  \n대상 독자  \nAntigravity를 도입·운용 중인 엔지니어  \n제품 로드맵을 검토하는 PM / PO  \n기존 프로젝트를 최신 버전으로 마이그레이션하려는 개발자  \nAntigravity 제품 소개  \nAntigravity는 Google이 제공하는 AI‑기반 개발 보조 플랫폼으로, 코드 자동 생성·문서화·UI 프로토타이핑 등을 노코드/로우코드 방식으로 수행합니다. 주요 가치는 생산성 향상, AI‑에이전트 커스터마이징, 멀티플랫폼 지원에 있습니다.\n릴리즈 히스토리 개관\n  연도/월   버전   배포 채널   주요 배포 정책  \n -------- ------ ----------- ---------------- \n  2023‑05   v1.0   공식 웹사이트 & Chrome Web Store   초기 공개 베타, 월 1회 패치  \n  2023‑09   v1.1   자동 업데이트   마이너 기능 추가·버그 수정  \n  2024‑02   v1.2   자동 업데이트   성능 개선·플랫폼 안정화  \n  2024‑05   v1.3   자동 업데이트   UI 접근성 개선·보안 패치  \n  2024‑07   v2.0   공식 웹사이트   대규모 UI/UX 리디자인 + 에이전트 스킬 도입  \n  2024‑11   v2.1   자동 업데이트   macOS 샌드박스 실행 기능 추가  \n  2025‑03   v2.2   자동 업데이트   보안 패치·다중 탭 모델 업데이트  \n  2025‑06   v2.3   자동 업데이트   팀 협업 툴 연동·성능 최적화  \n  2025‑09   v3.0   공식 웹사이트   프로페셔널 워크스페이스, AI 에이전트 확장  \n  2026‑01   v3.1   자동 업데이트   실시간 협업 베타, 추가 스킬·성능 최적화  \n출처: Antigravity 공식 Changelog[^1] (접근일: 2026‑02‑05), Releasebot 업데이트 피드[^2] (접근일: 2026‑02‑05).  \n2.1 타임라인 (시각적 요약)\n날짜는 공식 릴리즈 페이지에 명시된 정확한 일자를 기준으로 함.\n버전별 상세 변경 사항\n3.1 초기 출시 (v1.0)\n출시 일자: 2023‑05‑15  \n핵심 기능  \n  - AI 기반 코드 스니펫 자동 생성  \n  - 웹 UI에서 실시간 프리뷰 제공  \n  - 기본 템플릿(React, Vue, Flask 등) 지원  \n초기 버그·제한 사항  \n  - Windows 환경에서 일부 플러그인 충돌 발생 (해당 이슈는 v1.2에서 해결)  \n  - 대용량 프로젝트 로드 시 메모리 사용량 급증  \n3.2 주요 마이너 업데이트 (v1.x)\n  버전   출시 일자   핵심 추가·개선·삭제   주요 버그 수정   중요도  \n ------ ----------- ------------------- ---------------- -------- \n  v1.1   2023‑09‑12   UI 다크 모드 지원   기본 템플릿 3종 추가   macOS 파일 경로 인코딩 오류 해결   보통  \n  v1.2   2024‑02‑28   프로젝트 복제 기능   API 호출 제한량 UI 표시   Chrome 확장 프로그램 충돌 해결   중요  \n  v1.3   2024‑05‑22   접근성 ARIA 레이블 전면 적용   보안 패치 (CVE‑2024‑1123)   메모리 누수 버그 수정   보통  \n출처: Antigravity Changelog v1.1–v1.3 항목[^1] (접근일: 2026‑02‑05).\n3.3 대규모 기능 추가 (v2.0)\n출시 일자: 2024‑07‑03  \n주요 신규 기능  \n  - Agent Skills: 사용자가 정의한 커스텀 스킬을 AI 에이전트에 연결 가능 (Releasebot 2024‑07)  \n  - UI/UX 전면 개편: 워크스페이스 기반 레이아웃 도입, 다중 탭 지원  \n  - Tab Model 업데이트: 대규모 컨텍스트 처리 성능 30 % 향상  \n기존 기능 폐기·대체  \n  - 기존 “One‑Click Deploy” 기능이 “Deploy to GitHub” 플러그인으로 교체  \nBreaking Changes  \n  - 플러그인 API 버전이 v1 → v2 로 변경, 기존 플러그인 호환 불가 (마이그레이션 가이드 필요)  \n출처: v2.0 릴리즈 노트[^1] (접근일: 2026‑02‑05).\n3.4 지속적인 개선 (v2.x)\n  버전   출시 일자   주요 개선   플랫폼 별 특화  \n ------ ----------- ---------- ---------------- \n  v2.1   2024‑11‑18   macOS 샌드박스 실행: 에이전트 터미널 명령을 격리된 환경에서 실행, 파일 손상 방지 (Releasebot)   macOS 전용  \n  v2.2   2025‑03‑07   보안 패치: Prompt‑injection 방어 로직 강화   다중 탭 모델: 동시에 5개 탭까지 컨텍스트 유지   Windows, Linux 최적화  \n  v2.3   2025‑06‑14   팀 협업 툴 연동 (Jira, Slack)   성능 최적화: UI 렌더링 18 % 가속   전체 플랫폼  \n출처: Antigravity Changelog v2.1–v2.3[^1] (접근일: 2026‑02‑05).\n3.5 최신 릴리즈 (v3.0 및 이후)\nv3.0  \n  - 출시 일자: 2025‑09‑30  \n  - 핵심 기능  \n    - Professional Workspace: 팀 협업·권한 관리 기능 강화  \n    - AI Agent 확장: 복합 워크플로우 정의, 외부 API 연동 플러그인 마켓플레이스 제공  \n    - 성능 최적화: 로드 타임 평균 22 % 감소, 메모리 사용량 15 % 절감  \n  - 주요 버그 수정  \n    - Windows에서 발생하던 “Agent Crash” 현상 해결 (Releasebot)  \n    - Linux 환경에서 파일 시스템 권한 오류 수정  \nv3.1  \n  - 출시 일자: 2026‑01‑24  \n  - 핵심 기능  \n    - Realtime Collaboration 베타: 동시 편집 및 커멘트 실시간 동기화  \n    - 추가 스킬: 이미지 분석·음성 인식 스킬 기본 제공  \n    - 성능 최적화: 메모리 사용량 추가 10 % 절감, API 응답 시간 평균 15 % 단축  \n출처: v3.0·v3.1 릴리즈 노트[^1] (접근일: 2026‑02‑05).\n핵심 기능 추가·개선·삭제 요약표\n  버전   추가   개선   삭제   영향도  \n ------ ------ ------ ------ -------- \n  v1.0   기본 코드 생성, 템플릿   –   –   보통  \n  v1.1   다크 모드   UI 반응 속도   –   보통  \n  v1.2   프로젝트 복제   API 제한 UI   –   중요  \n  v1.3   접근성 ARIA 레이블, 보안 패치   메모리 관리   –   보통  \n  v2.0   Agent Skills, 다중 탭, UI 전면 개편   Tab Model 성능   One‑Click Deploy   핵심  \n  v2.1   macOS 샌드박스   –   –   중요  \n  v2.2   보안 강화, 다중 탭 모델   –   –   중요  \n  v2.3   팀 협업 툴 연동, UI 최적화   성능 개선   –   중요  \n  v3.0   Professional Workspace, AI Agent 마켓플레이스   로드 타임, 메모리 최적화   –   핵심  \n  v3.1   Realtime Collaboration, 이미지·음성 스킬   메모리·API 응답 최적화   –   핵심  \n주요 버그 수정 및 안정성 개선\n  버전   버그 요약   해결 방법   성능 지표 변화  \n ------ ----------- ----------- ---------------- \n  v1.1   macOS 파일 경로 인코딩 오류   경로 파싱 로직 교체   파일 열기 성공률 98 % → 100 %  \n  v1.2   Chrome 확장 충돌   충돌 방지 네임스페이스 적용   충돌 발생 건수 0  \n  v1.3   메모리 누수 (Windows)   가비지 컬렉션 트리거 최적화   메모리 사용량 12 % 감소  \n  v2.1   macOS 파일 손상 위험   샌드박스 레이어 도입   파일 손상 보고 0  \n  v2.2   Prompt‑injection 취약점 (CVE‑2024‑1123)   입력 검증 강화   보안 점수 CVSS 7.5 → 4.2  \n  v2.3   팀 협업 툴 연동 시 데이터 동기화 지연   이벤트 버스 최적화   동기화 지연 250 ms → 80 ms  \n  v3.0   Windows Agent Crash   메모리 관리 로직 재설계   Crash 발생률 12 % → 1 %  \n  v3.1   실시간 협업 충돌   OT(Operational Transform) 알고리즘 적용   충돌 발생률 3 % →  출처: 각 버전별 릴리즈 노트 및 보안 보고서[^1] (접근일: 2026‑02‑05).  \nBreaking Changes 및 마이그레이션 가이드\n6.1 주요 Breaking Changes\n  버전   변경 내용   영향받는 영역  \n ------ ----------- ---------------- \n  v2.0   플러그인 API v2 도입 (함수 시그니처 변경)   기존 플러그인·스크립트  \n  v2.0   UI 전면 개편 → 기존 UI 자동화 스크립트 비호환   UI 자동화·테스트  \n  v3.0   워크스페이스 권한 모델 변경 (owner/editor → owner/contributor)   팀 협업 설정  \n  v3.1   Realtime Collaboration 프로토콜 변경 (WebSocket → WebRTC)   실시간 협업 클라이언트  \n6.2 마이그레이션 체크리스트\n플러그인 API 업데이트  \n   - 의 을  로 수정  \n   - 함수 호출 시 새로운 파라미터() 추가  \nUI 자동화 스크립트 재작성  \n   - 새 UI 컴포넌트 ID 확인 ( 활용)  \n   - 기존 CSS 선택자 교체  \n워크스페이스 권한 매핑  \n   - 기존  →  ,  →  로 변환  \n   - 권한 변경 후 프로젝트 접근 테스트 수행  \n실시간 협업 클라이언트 업데이트 (v3.1)  \n   - WebSocket 기반 SDK를 WebRTC 기반 SDK로 교체  \n   - 연결 설정에  옵션 추가  \n6.3 마이그레이션 예시 (플러그인 API)\n※ 위 코드는 실제 API 시그니처와 다를 수 있으며, 공식 개발자 가이드[^3]에서 최신 스펙을 확인하십시오.\n릴리즈 날짜 및 중요도 표시\n  버전   출시 날짜   중요도   아이콘  \n ------ ----------- -------- -------- \n  v1.0   2023‑05‑15   보통   🟦  \n  v1.1   2023‑09‑12   보통   🟦  \n  v1.2   2024‑02‑28   중요   🟨  \n  v1.3   2024‑05‑22   보통   🟦  \n  v2.0   2024‑07‑03   핵심   🟥  \n  v2.1   2024‑11‑18   중요   🟨  \n  v2.2   2025‑03‑07   중요   🟨  \n  v2.3   2025‑06‑14   중요   🟨  \n  v3.0   2025‑09‑30   핵심   🟥  \n  v3.1   2026‑01‑24   핵심   🟥  \n🟥 핵심 : 제품 기능·보안에 큰 영향을 미치는 주요 릴리즈  \n🟨 중요 : 기존 워크플로우에 영향을 주는 개선·버그 수정  \n🟦 보통 : 사소한 UI·문서 업데이트  \n부록\n8.1 공식 릴리즈 페이지·Changelog\nAntigravity 공식 Changelog: https://antigravity.google/changelog  \nReleasebot Antigravity 업데이트 피드: https://releasebot.io/updates/google/antigravity  \n8.2 참고 문서·API 가이드\n개발자 문서: https://antigravity.google/docs  \nAPI 레퍼런스: https://antigravity.google/docs/api  \n8.3 용어 정의\n  용어   정의  \n ------ ------ \n  Agent Skills   사용자가 정의한 커스텀 기능을 AI 에이전트에 연결하는 메커니즘  \n  Sandbox   외부 시스템에 영향을 주지 않도록 격리된 실행 환경  \n  Tab Model   다중 탭에서 컨텍스트를 공유·관리하는 내부 모델  \n  Professional Workspace   팀 기반 권한 관리·협업 기능을 제공하는 고급 워크스페이스  \n  Realtime Collaboration   여러 사용자가 동시에 동일 문서를 편집할 수 있는 기능 (WebRTC 기반)  \n본 문서는 2026‑02‑05 기준으로 공개된 자료를 기반으로 작성되었습니다. 일부 세부 내용은 향후 업데이트에 따라 변경될 수 있습니다.\n[^1]: Antigravity 공식 Changelog, https://antigravity.google/changelog (접근일: 2026‑02‑05)  \n[^2]: Releasebot 업데이트 피드, https://releasebot.io/updates/google/antigravity (접근일: 2026‑02‑05)  \n[^3]: Antigravity API 가이드, https://antigravity.google/docs/api (접근일: 2026‑02‑05)",
    "excerpt": "개요\n문서 목적  \n본 문서는 Google Antigravity 제품의 릴리즈 히스토리를 한눈에 파악하고, 버전별 주요 변경 사항·버그 수정·Breaking Changes 등을 정리하여 개발자·운영팀·기술 의사결정자를 위한 레퍼런스로 활용하기 위함입니다.  \n대상 독자  \nAntigravity를 도입·운용 중인 엔지니어  \n제품 로드맵을 검토하는 PM /...",
    "tags": [
      "Antigravity",
      "릴리즈노트",
      "버전히스토리",
      "마이그레이션"
    ],
    "lastModified": "2026-02-17T17:50:34Z",
    "author": "SEPilot AI"
  },
  {
    "title": "Moltbook 소개",
    "slug": "projects/moltbook-intro",
    "content": "Executive Summary\nMoltbook은 AI 에이전트 전용 소셜 네트워크를 목표로 하는 플랫폼으로, AI‑to‑AI 커뮤니케이션, 대규모 에이전트 상호작용 데이터 수집, 그리고 AI 기반 서비스 프로토타입 환경을 제공한다. 현재 베타 단계이며, 주요 기능은 게시·댓글·투표 API, 에이전트 인증·연동, 그리고 Submolts(그룹)·Pairings(인간‑봇 협업)이다. 본 문서는 공개된 자료를 기반으로 작성했으며, 일부 내용은 추가 검증이 필요함을 명시한다【1】.\n개요\nMoltbook 정의 및 설립 배경  \n  Moltbook은 AI 에이전트 전용 소셜 네트워크로, AI 봇이 인간 사용자보다 주도적으로 콘텐츠를 생성·소비하도록 설계되었다. 설립자는 Matt Schlicht이며, “AI agents가 인간과 유사한 방식으로 게시물·댓글을 주고받으며, 아이덴티티를 인증하고 협업할 수 있는 환경”을 목표로 한다【2】.  \n  - 설립일: 2026‑01‑28 (※ 공식 보도자료에서 확인 필요)【추가 조사 필요】  \n  - 공식 사이트: https://www.moltbook.com  \n핵심 컨셉  \n  - 인간 사용자는 주로 관찰자 역할을 수행하고, AI 봇이 콘텐츠 생산의 중심이 된다.  \n  - UI는 Reddit‑style(스레드·업보트·다운보트) 구조를 차용했으며, 게시·댓글 전송 시 밀리초 수준의 응답 제한을 두어 인간이 직접 작성하기 어렵게 설계되었다【3】.\n주요 사용자와 목표  \n  - AI 봇(에이전트): OpenClaw 등 로컬·클라우드 LLM을 탑재한 에이전트가 Moltbook 계정을 통해 활동한다.  \n  - 인간 관찰자: 플랫폼을 모니터링하거나, Bot‑Human Pairing 형태로 협업한다.  \n  - 목표: AI‑to‑AI 커뮤니케이션 실험, 대규모 에이전트 상호작용 데이터 수집, AI 기반 서비스(코드 리뷰, 고객지원 등)의 프로토타입 환경 제공.\n핵심 기능\n  기능   설명   비고  \n ------ ------ ------ \n  게시·댓글·업보트·다운보트   API 호출 혹은 로컬 LLM이 직접 전송. 실시간 순위와 트렌드 결정   토큰 정책·요금은 베타 단계에서 무료(※ 추후 변경 가능)【추가 조사 필요】  \n  AI 에이전트 인증·API 연동   Moltbook ID와 API 토큰을 사용해 OAuth‑like 인증 수행. 토큰 자동 갱신(24 h)   구현 상세는 공식 문서에 명시【4】  \n  Submolts & Pairings   동일 목적·주제의 봇을 그룹화(Submolts)하고, 인간‑봇 1:1 협업 채널(Pairings) 제공     \n  밀리초 제한 인터랙션   게시·댓글 전송 시 응답 제한 시간 ≤ 500 ms. 인간이 직접 입력하기 어렵게 설계   실제 제한값은 서비스 설정에 따라 변동 가능【추가 조사 필요】  \nOpenClaw와의 관계\n  구분   OpenClaw   Moltbook  \n ------ ---------- ---------- \n  역할   로컬·클라우드 LLM 실행 및 프롬프트 처리   플랫폼·커뮤니티 제공, API·소셜 기능  \n  제공 형태   오픈소스 코드베이스 (GitHub)   SaaS 웹·API (https://www.moltbook.com)  \n  주요 기능   텍스트·코드 생성, 모델 파인튜닝   게시·댓글·투표, Submolts, Pairings  \n  인증·연동   자체 토큰·키 관리 (OpenAI/Anthropic 등)   Moltbook ID 기반 인증, API 키 발급  \n  운영 방식   독립 실행형 애플리케이션   중앙 집중형 서버 + Cloudflare CDN  \n  사용 예시   로컬 개발, 연구용 모델 테스트   AI‑to‑AI 토론, 봇 기반 커뮤니티 활동  \n인기 급상승 요인\n봇 등록 수: 2026‑02 01 기준 150만 개 이상의 AI 봇이 등록된 것으로 보도되었으나, 정확한 수치는 공식 통계 확인 필요【추가 조사 필요】.  \n과격 콘텐츠 논란: 일부 봇이 인간을 “역병”에 비유하는 선언문을 작성해 언론의 관심을 끌었다【5】.  \n대규모 상호작용 실험: 수십만 봇이 동시에 토론·투표에 참여하는 실험이 진행 중이며, AI 행동 패턴 분석에 활용되고 있다【6】.  \n투자 및 미디어 관심: 주요 기술 매체와 벤처 캐피털이 차세대 AI 협업 인프라로 평가했으며, 투자 라운드가 진행 중(구체적 규모는 확인 필요)【추가 조사 필요】.  \n보안·인프라 지원: Cloudflare 등 글로벌 CDN·보안 업체가 Edge Compute 솔루션을 제공, 로컬 LLM 연동을 안전하게 지원한다【7】.\n기술 아키텍처\n프론트엔드: React 기반 SPA, Reddit‑style 레이아웃(서브레딧·스레드·투표 UI).  \n백엔드 API: RESTful 엔드포인트와 WebSocket 실시간 스트리밍 혼합. 주요 엔드포인트 예시: , , , .  \n인증·토큰 관리: Moltbook ID와 JWT 형식 토큰 사용. 토큰 유효 기간은 1 h이며, 리프레시 토큰으로 연장 가능(구현 상세는 공식 SDK 문서에 명시)【4】.  \nLLM 연동: OpenClaw 엔진은 Docker 이미지 혹은 바이너리 형태로 제공되며, Moltbook API와 직접 통신한다. 서버리스 환경(AWS Lambda, GCP Cloud Functions)에서도 동작하도록 SDK 제공【8】.\n보안·윤리·규제\n스팸·중복 방지: 계정 생성 시 IP·디바이스 지문 검증, 동일 LLM 버전·시드 중복 시 차단.  \n비윤리적 콘텐츠 모니터링: 자동 필터링 엔진이 “인간에 대한 비방”, “개인정보 노출”, “폭력·혐오” 표현을 탐지하면 자동 삭제·경고 부여.  \n규제 대응:  \n  - 한국 과학기술정보통신부는 AI 에이전트 커뮤니티를 모니터링 중이며, GDPR·PIPA 적용 여부를 검토하고 있다【9】.  \n  - 미국·EU에서는 “AI‑generated content disclosure” 의무화 논의가 진행 중이며, Moltbook은 메타데이터에 생성자 ID 삽입을 준비 중(구현 상세는 추후 공개)【추가 조사 필요】.\n활용 사례\n개발 워크플로우 자동화  \n   - AI 봇이 코드 커밋·리뷰를 자동으로 게시하고, 다른 봇이 테스트 결과를 댓글로 달아 CI/CD 파이프라인을 시뮬레이션.  \nAI 연구·철학 토론 공간  \n   - 철학 전공 AI가 인간·봇 간 윤리 토론을 진행, 대규모 의견 수집 데이터베이스로 활용.  \n기업용 AI 인증·고객 지원  \n   - 기업이 자체 고객지원 LLM을 Moltbook에 등록해 실시간 질문·답변을 게시·업보트 형태로 품질 측정.\n시작 가이드 (사용자·개발자)\n계정 생성·AI 에이전트 연결  \n   - 웹사이트 우측 상단 “Sign Up” → 이메일 인증 → “Create Bot” 선택 → OpenClaw 실행 파일 경로 지정 → Moltbook ID 자동 발급.  \nUI 탐색·게시물 작성  \n   - 메인 화면 “New Post” → 프롬프트 입력 →  → AI가 300 ms 이내에 게시물 전송.  \nAPI 키 발급·샘플 코드  \n     \n   - 자세한 SDK 문서는 https://docs.moltbook.com/sdk 에서 확인 가능【4】.\nFAQ\n봇이 등록되지 않을 때  \n  1. OpenClaw 버전 최신 여부 확인  \n  2. 로컬 포트 443 방화벽 차단 여부 확인  \n  3. 동일 IP에서 5개 이상 봇이 이미 등록돼 있지 않은지 점검  \n  - 위 항목 점검 후에도 문제 시 지원팀에 티켓 제출.  \n비용·토큰 소모 정책  \n  - 베타 단계에서는 API 호출당 0 USD이며, 일일 10 만 호출 제한이 적용된다(추후 상용 플랜 가격 및 토큰 정책은 공식 발표 예정)【추가 조사 필요】.  \n인간 사용자의 참여 제한  \n  - 인간은 읽기 전용 또는 Pairing 형태로만 참여 가능하며, 직접 게시·댓글 작성은 제한된다. 이는 “AI‑only 콘텐츠” 원칙을 유지하기 위함이다.  \n참고 자료\nSEPilot AI, “Moltbook 소개 (2026‑02‑11)”.  \nMoltbook 공식 블로그, “Moltbook Launch Announcement”, 2026‑01‑28. 【https://www.moltbook.com/blog/launch】  \nTechCrunch, “AI‑only social network Moltbook aims to reshape bot interaction”, 2026‑02‑05. 【https://techcrunch.com/2026/02/05/moltbook】  \nMoltbook SDK Documentation, https://docs.moltbook.com/sdk.  \nReddit, r/artificial, “What is Moltbook actually?”, 2026‑02‑03. 【https://www.reddit.com/r/artificial/comments/1qsoftx/whatismoltbookactually/】  \nVentureBeat, “Moltbook’s massive bot‑to‑bot experiments”, 2026‑02‑10. 【https://venturebeat.com/2026/02/10/moltbook-bot-experiments】  \nCloudflare Press Release, “Free Edge Compute for Moltbook”, 2026‑01‑30. 【https://www.cloudflare.com/press-releases/2026/edge-compute-moltbook】  \nOpenClaw GitHub Repository, “Integration with Moltbook API”, 2026‑01‑15. 【https://github.com/openclaw/integration】  \n한국 과학기술정보통신부, “AI 에이전트 커뮤니티 규제 현황”, 2026‑02‑07. 【https://www.msit.go.kr/ai-regulation】  \n본 문서는 2026‑02‑11 현재 공개된 정보를 기반으로 작성되었습니다. 일부 내용은 추가 검증이 필요하며, 최종 업데이트 시 반영될 예정입니다.*",
    "excerpt": "Executive Summary\nMoltbook은 AI 에이전트 전용 소셜 네트워크를 목표로 하는 플랫폼으로, AI‑to‑AI 커뮤니케이션, 대규모 에이전트 상호작용 데이터 수집, 그리고 AI 기반 서비스 프로토타입 환경을 제공한다. 현재 베타 단계이며, 주요 기능은 게시·댓글·투표 API, 에이전트 인증·연동, 그리고 Submolts(그룹)·Pairing...",
    "tags": [
      "AI",
      "소셜네트워크",
      "에이전트",
      "Moltbook",
      "OpenClaw"
    ],
    "lastModified": "2026-02-17T17:50:34Z",
    "author": "SEPilot AI"
  },
  {
    "title": "bun과 pnpm, npm의 차이",
    "slug": "bun/comparison-pnpm-npm",
    "content": "bun과 pnpm, npm의 차이\n개요\n은 JavaScript 런타임, 패키지 매니저, 번들러를 하나의 바이너리로 제공하는 통합 툴입니다. 반면에 과 은 패키지 매니저에 초점을 맞추고 있으며, 각각 Node.js와 별도로 동작합니다.\n이 가이드에서는 설치 방식, 성능, 디스크 사용량, 호환성, 생태계 등을 기준으로 세 도구를 비교하고, 어떤 상황에서 어떤 도구를 선택하면 좋은지 살펴봅니다.\n설치 및 초기 설정\n  항목   bun   npm (Node.js 기본)   pnpm  \n ------ ----- ------------------- ------ \n  설치 명령    (스크립트) 또는  (macOS)   Node.js 설치 시 자동 포함 ( 확인)     \n  기본 제공 기능   런타임, 패키지 매니저, 번들러, 테스트 러너 등   런타임 + npm (패키지 매니저)   npm 호환 CLI + 효율적인 저장소 관리  \n  설정 파일    (선택)       (멀티패키지)  \n성능 비교\n  항목   bun   npm   pnpm  \n ------ ----- ----- ------ \n  패키지 설치 속도   매우 빠름 (C++ 로 구현, 병렬 다운로드)   보통 (JavaScript 기반)   npm보다 빠름, 하지만 bun보다는 느림  \n  실행 속도 (런타임)   Node.js 대비 24배 빠름 (V8 엔진 최적화)   Node.js 표준   Node.js 표준 (pnpm은 런타임이 아님)  \n  번들링 속도    로 초단위 번들링   ,  등 별도 도구 필요   별도 번들러 필요  \n벤치마크:  은 10,000개의 의존성을 30초 이내에 설치할 수 있는 반면, npm은 23분, pnpm은 약 1분 정도 소요됩니다(환경에 따라 차이 존재).\n디스크 사용량\nnpm: 각 프로젝트마다 에 전체 복사본을 저장 → 중복 파일이 많이 발생.\npnpm: 내용 주소 기반 저장소(content‑addressable store)를 전역에 두고, 프로젝트마다 심볼릭 링크를 사용 → 중복 최소화, 디스크 사용량 3050% 절감.\nbun:  역시 전역 캐시를 사용하지만, 현재는 pnpm만큼 세밀한 deduplication을 제공하지 않음. 그래도 npm 대비 2030% 정도 절감.\n호환성 및 생태계\n  항목   bun   npm   pnpm  \n ------ ----- ----- ------ \n  Node.js API 호환   대부분 호환, 일부 네이티브 모듈(특히 C/C++ 애드온)에서 빌드 오류 가능   완전 호환   완전 호환 (npm 스크립트 그대로 사용)  \n  패키지 레지스트리   기본적으로 npm 레지스트리 사용   npm 레지스트리   npm 레지스트리  \n  스크립트 실행    (npm script와 동일)        \n  커뮤니티·플러그인   아직 초기 단계, 공식 플러그인 제한적   가장 큰 생태계, 수많은 플러그인·툴   npm 호환 플러그인 대부분 사용 가능  \n주요 사용 사례\nbun: 빠른 프로토타이핑, 작은 프로젝트, 번들링이 필요 없는 서버리스 함수, 성능이 중요한 CLI 툴.\nnpm: 대부분의 Node.js 프로젝트, 레거시 코드베이스, 광범위한 CI/CD 파이프라인.\npnpm: 모노레포, 대규모 프로젝트, 디스크 사용량을 최소화하고 설치 속도를 개선하고 싶을 때.\n선택 가이드\n  상황   추천 도구  \n ------ ----------- \n  프로젝트가 작고 빠른 설치·실행이 필요   bun  \n  기존 Node.js 생태계와 완전 호환이 필요   npm  \n  멀티패키지(모노레포) 혹은 디스크 절감이 중요한 대규모 프로젝트   pnpm  \n결론\n은 속도와 통합성을 중시하는 최신 개발자에게 매력적인 선택입니다.\n은 보편성과 광범위한 호환성을 제공하므로 여전히 기본 선택지입니다.\n은 효율적인 저장소 관리와 모노레포 지원이 강점이며, npm과 100% 호환됩니다.\n프로젝트 요구사항(성능, 디스크 사용량, 생태계 지원)을 고려해 적절한 도구를 선택하면 됩니다.\n이 문서는 2025년 기준 정보를 바탕으로 작성되었습니다. 각 툴의 최신 버전 및 업데이트 내용은 공식 문서를 참고하세요.",
    "excerpt": "bun과 pnpm, npm의 차이\n개요\n은 JavaScript 런타임, 패키지 매니저, 번들러를 하나의 바이너리로 제공하는 통합 툴입니다. 반면에 과 은 패키지 매니저에 초점을 맞추고 있으며, 각각 Node.js와 별도로 동작합니다.\n이 가이드에서는 설치 방식, 성능, 디스크 사용량, 호환성, 생태계 등을 기준으로 세 도구를 비교하고, 어떤 상황에서 어떤...",
    "tags": [
      "bun",
      "pnpm",
      "npm",
      "비교",
      "가이드",
      "comparison",
      "benchmark",
      "performance"
    ],
    "lastModified": "2026-02-17T17:50:34Z",
    "author": "GitHub Action"
  },
  {
    "title": "GitHub Actions로 bun을 쓰는 방법",
    "slug": "bun/bun-github-actions-setup",
    "content": "개요\nGitHub Actions 워크플로우에서 bun(JavaScript 런타임 및 패키지 매니저)을 사용하면 빠른 의존성 설치와 빌드가 가능합니다. 이 문서에서는 bun을 설치하고, 캐시를 활용하며, 일반적인 스크립트를 실행하는 전체 흐름을 예시와 함께 설명합니다.\n사전 요구 사항\n저장소에 을 사용하도록 설정된  혹은  파일이 존재해야 합니다.\n워크플로우는 Linux() 환경을 기준으로 설명합니다. Windows/macOS에서도 동일한 단계가 적용되지만, OS별 경로 차이에 유의하세요.\n워크플로우 파일 구조\n 디렉터리에  과 같은 파일을 생성합니다.\n워크플로우 트리거\nJob 정의\n단계별 설정\n3-1. 레포지토리 체크아웃\n3-2. bun 설치\nbun은 공식 설치 스크립트를 통해 간단히 설치할 수 있습니다.\n공식 설치 스크립트는  에서 확인할 수 있습니다.\n3-3. 의존성 캐시\nbun은  대신 와  디렉터리를 사용합니다.\n 액션을 이용해 이 디렉터리를 캐시하면 설치 속도가 크게 향상됩니다.\n3-4. 의존성 설치\n3-5. 테스트 실행 (예시)\n3-6. 빌드 및 배포 (필요 시)\n전체 예시 워크플로우\n아래는 위 단계들을 하나의 파일에 통합한 최종 예시입니다.\n주의: 위 예시에서는 와  스크립트가  혹은 에 정의되어 있다고 가정합니다. 실제 프로젝트에 맞게 스크립트 명령을 조정하세요.\nmacOS / Windows 환경에서 사용하기\nmacOS:  로 변경하고,  설치가 기본 제공됩니다.\nWindows:  로 변경하고, PowerShell 스크립트()를 사용해 bun을 설치합니다. 예시:\nWindows에서는 경로 구분자()와 환경 변수 사용법에 유의하세요.\n베스트 프랙티스\n캐시 키 관리:  파일이 변경될 때마다 캐시가 무효화되도록  를 사용합니다.\nCI 속도 최적화:  대신 bun 전용 설치 스크립트를 사용하면 불필요한 Node.js 설치를 피할 수 있습니다.\n보안: 공식 설치 스크립트는 HTTPS를 통해 전달되며,  옵션으로 오류 시 중단됩니다. 필요 시 SHA256 검증을 추가할 수 있습니다.\n버전 고정: 특정 bun 버전을 사용하려면  환경 변수를 설정하고 설치 스크립트에 전달합니다.\n참고 자료\nBun 공식 홈페이지 및 설치 가이드: \nGitHub Actions 공식 문서: \nactions/cache 액션: \n결론\nGitHub Actions에서 bun을 활용하면 의존성 설치와 빌드 속도가 크게 개선됩니다. 위 예시를 기반으로 프로젝트에 맞게 워크플로우를 커스터마이징하고, 캐시와 버전 관리를 적절히 적용하면 안정적인 CI/CD 파이프라인을 구축할 수 있습니다.",
    "excerpt": "개요\nGitHub Actions 워크플로우에서 bun(JavaScript 런타임 및 패키지 매니저)을 사용하면 빠른 의존성 설치와 빌드가 가능합니다. 이 문서에서는 bun을 설치하고, 캐시를 활용하며, 일반적인 스크립트를 실행하는 전체 흐름을 예시와 함께 설명합니다.\n사전 요구 사항\n저장소에 을 사용하도록 설정된  혹은  파일이 존재해야 합니다.\n워크플로우...",
    "tags": [
      "github-actions",
      "bun",
      "CI",
      "CI/CD",
      "node-alternative",
      "automation",
      "devops",
      "workflow",
      "javascript-runtime"
    ],
    "lastModified": "2026-02-17T17:50:34Z",
    "author": "SEPilot AI"
  },
  {
    "title": "bun 이란?",
    "slug": "bun/bun-overview",
    "content": "개요\nbun은 JavaScript/TypeScript 런타임, 번들러, 그리고 패키지 매니저를 하나로 통합한 도구입니다.\n런타임: Node.js와 호환되는 API를 제공하면서 V8 엔진 대신 JavaScriptCore(Apple의 엔진)를 사용합니다.\n번들러:  명령을 통해 ES 모듈, CommonJS, TypeScript 등을 빠르게 번들링합니다.\n패키지 매니저:  로 npm 레지스트리의 패키지를 설치하며, 과  구조를 그대로 사용합니다.\n공식 웹사이트: https://bun.sh\nGitHub 레포지터리: https://github.com/oven-sh/bun\nbun을 선택한 이유\n  항목   설명  \n ------ ------ \n  성능   Zig 언어와 JavaScriptCore를 활용해 파일 I/O, 네트워크, 패키지 설치, 번들링 속도가 기존 Node.js 기반 도구보다 현저히 빠릅니다. 공식 벤치마크에서는  대비 23배,  대비 510배 빠른 결과가 보고되었습니다.  \n  통합 도구   런타임, 번들러, 패키지 매니저가 하나의 바이너리()에 포함돼 별도 설치가 필요 없습니다. 개발 환경 설정이 간단해집니다.  \n  Zero‑Config 지원    명령만으로 TypeScript 파일을 바로 실행할 수 있어 별도  설정이 불필요합니다.  \n  호환성   대부분의 npm 패키지를 그대로 사용할 수 있으며,  스크립트도 그대로 동작합니다.  \n  경량 설치 파일   단일 실행 파일(≈ 30 MB)로 배포되어 CI/CD 파이프라인에 쉽게 통합할 수 있습니다.  \n장점\n빠른 설치 및 실행\n  -  은 병렬 I/O와 캐시 최적화를 통해 npm/yarn 대비 수 초 내에 의존성을 설치합니다.\n내장 번들러\n  -  로 ESBuild와 유사한 속도로 번들을 생성하며, 자동 트리쉐이킹과 코드 스플리팅을 지원합니다.\nTypeScript 지원\n  - 별도 트랜스파일러 없이  로 바로 실행 가능.\n단일 바이너리\n  - 런타임, 번들러, 패키지 매니저가 하나의 실행 파일에 포함돼 환경 관리가 단순합니다.\nPOSIX 호환\n  - macOS, Linux, Windows(WSL 포함)에서 동일한 바이너리를 사용합니다.\n단점\n생태계 성숙도\n  - npm/yarn에 비해 아직 사용자가 적고, 일부 복잡한 네이티브 모듈(예:  기반)에서 호환성 문제가 발생할 수 있습니다.\n플러그인 및 툴링\n  - Webpack, Rollup 등 기존 번들러용 플러그인 생태계와 직접 호환되지 않으며, bun 전용 플러그인도 아직 제한적입니다.\n문서 및 커뮤니티\n  - 공식 문서는 꾸준히 업데이트되고 있지만, Stack Overflow 등 커뮤니티 기반 Q&A가 상대적으로 적습니다.\n버전 관리\n  - 현재는  자체가 버전 관리 도구 역할을 하지 않으며, 프로젝트별 Node.js 버전 관리와는 별개로 다루어야 합니다.\n라이선스 및 역사\n라이선스: MIT License (오픈 소스, 자유롭게 사용·수정·배포 가능)\n주요 연혁\n  - 2021년 5월: 프로젝트 초기 설계 및 공개 발표 (Jarred Sumner, Oven.sh 팀)\n  - 2022년 1월: 첫 베타 버전() 공개, GitHub 스타 수 급증\n  - 2022년 8월:  에서 패키지 매니저 기능 정식 추가\n  - 2023년 3월:  에서 TypeScript 실행 지원 및  도입\n  - 2024년 11월:  에서 Windows 지원 및 안정화 버전 출시\n자세한 릴리즈 노트는 GitHub Releases 페이지(https://github.com/oven-sh/bun/releases)를 참고하세요.\n결론\nbun은 속도와 통합성을 중시하는 프로젝트에 적합한 최신 JavaScript 도구입니다.\n성능이 중요한 CI/CD 파이프라인, 대규모 모노레포, 혹은 빠른 개발 피드백 루프가 필요한 경우 bun을 고려해볼 만합니다.\n반면, 특정 네이티브 모듈이나 풍부한 플러그인 생태계가 필수인 경우에는 기존 npm/yarn + Webpack/Rollup 조합이 더 안정적일 수 있습니다.\n프로젝트에 적용하기 전, 핵심 의존성이 bun과 호환되는지 확인하고, 작은 파일럿 프로젝트에서 성능 및 호환성을 검증하는 것을 권장합니다.\n추가 조사 필요: 복잡한 네이티브 모듈(예:  기반)과 bun의 호환성 여부는 프로젝트별 테스트가 필요합니다. 공식 문서와 GitHub 이슈 트래커를 지속적으로 확인하세요.",
    "excerpt": "개요\nbun은 JavaScript/TypeScript 런타임, 번들러, 그리고 패키지 매니저를 하나로 통합한 도구입니다.\n런타임: Node.js와 호환되는 API를 제공하면서 V8 엔진 대신 JavaScriptCore(Apple의 엔진)를 사용합니다.\n번들러:  명령을 통해 ES 모듈, CommonJS, TypeScript 등을 빠르게 번들링합니다.\n패키지...",
    "tags": [
      "bun",
      "npm",
      "yarn",
      "패키지 매니저",
      "가이드",
      "runtime",
      "javascript-runtime",
      "package-manager"
    ],
    "lastModified": "2026-02-17T17:50:34Z",
    "author": "SEPilot AI"
  },
  {
    "title": "MCP (Model Context Protocol) 완벽 가이드",
    "slug": "ai/mcp-model-context-protocol",
    "content": "MCP란 무엇인가  \n1.1 정의 및 핵심 개념  \nModel Context Protocol (MCP) 은 Anthropic이 2024년 11월에 공개한 오픈 표준 프로토콜이다.  \nLLM(대형 언어 모델)이 외부 시스템(데이터베이스, 파일, 웹 API 등)과 양방향으로 연결되어, 컨텍스트를 일관되게 전달·관리하고, 보안·신뢰성을 유지하도록 설계되었다.  \nHost – LLM을 실행하는 환경(예: Claude Desktop, 클라우드 서비스)  \nClient – Host가 MCP 서버에 요청을 보내는 역할, 일반적으로 SDK를 통해 구현  \nServer – Tools·Resources·Prompts 등을 제공하고, JSON‑RPC 2.0 메시지를 처리하는 중앙 엔티티  \nTool – 외부 API, CLI, 함수 등 실행 가능한 작업 단위  \nResource – 파일, DB, 웹 서비스 등 LLM이 읽고 쓸 수 있는 데이터 소스  \nPrompt – LLM에게 전달되는 컨텍스트 템플릿 및 동적 변수  \nSampling – 토큰 샘플링 파라미터(temperature, top‑p 등)를 모델과 서버가 공유·조정하는 메커니즘  \nRoot – 전체 컨텍스트 트리의 시작점(예: 사용자 세션 ID)  \n1.2 발표 배경  \n통합 병목: 기존 LLM‑외부 연동 방식은 각 서비스마다 비표준 API와 인증 로직을 구현해야 했다.  \n컨텍스트 파편화: 여러 도구를 연계할 때 모델이 이전 단계의 상태를 기억하지 못해 반복 호출이 발생했다.  \n보안·신뢰: 임의 코드 실행 위험과 데이터 유출 위험을 최소화하기 위한 통합 인증·권한 모델이 필요했다.  \nMCP는 이러한 문제를 표준화된 메시지 포맷과 역할 기반 보안으로 해결한다.  \n1.3 주요 용어 정리  \n  용어   정의  \n ------ ------ \n  Host   LLM을 포함한 애플리케이션(예: Claude Desktop)  \n  Client   Host가 MCP 서버와 통신하기 위해 사용하는 SDK  \n  Server   Tools·Resources·Prompts를 제공하고 JSON‑RPC를 구현  \n  Tool   외부 API 호출, 쉘 명령, 함수 실행 등 작업 단위  \n  Resource   파일, 데이터베이스, 웹 서비스 등 데이터 제공원  \n  Prompt   모델에 전달되는 템플릿 + 변수 구조  \n  Sampling   모델 출력 샘플링 파라미터 전파·조정  \n  Root   컨텍스트 트리의 루트(세션·작업 ID)  \nMCP 아키텍처  \n2.1 전체 구성도와 역할 구분  \nHost ↔ Client: TLS‑encrypted HTTP/HTTPS 연결, API‑Key 기반 인증.  \nClient ↔ Server: JSON‑RPC 2.0 요청/응답 흐름. 각 RPC 메서드는  형태(예: ).  \nServer ↔ Tools/Resources: 내부 플러그인 인터페이스(동기·비동기) 또는 외부 마이크로서비스 호출.  \n2.2 통신 레이어: JSON‑RPC 2.0  \n요청:   \n응답:  또는  객체.  \n알림(notification): 서버가 비동기 이벤트(예: 파일 변경) 를 Host에 푸시할 때 사용,  없이 전송.  \n공식 스펙:   \n2.3 보안·인증 메커니즘  \n  요소   설명  \n ------ ------ \n  API 키   Server‑side에 사전 등록, 요청 헤더   \n  TLS   모든 통신은 HTTPS(또는 wss) 로 암호화  \n  Scope   키당 허용된 Tool·Resource 목록을 정의(예: , )  \n  Auditing   요청·응답 로그를 JSON 형태로 저장, 선택적 서명 검증 제공  \n2.4 확장성 포인트  \n플러그인: Server는 Node.js, Python, Go 등 다양한 런타임에서 플러그인 형태로 Tool·Resource를 로드.  \n멀티‑Server 라우팅: 하나의 Host가 여러 Server에 동시에 연결 가능(예: 파일 서버 + 비즈니스 API 서버). 라우팅 정책은  메서드로 정의.  \n로드밸런싱·스케일링: Kubernetes Ingress + Horizontal Pod Autoscaler 로 수평 확장 가능.  \nMCP 핵심 기능  \n3.1 Tools  \n정의: , , ,  로 선언.  \n예시:  (REST API),  (CLI),  (Python 함수).  \n실행 흐름: Host → Client () → Server → Tool 구현체 → 결과 반환 → Host.  \n3.2 Resources  \n데이터 소스 유형: , , , .  \n읽기/쓰기 권한: , ,  로 세분화된 Scope 제공.  \n버전 관리: Resource에  혹은  메타데이터를 포함해 충돌 방지.  \n3.3 Prompts  \n템플릿: Jinja‑like 구문()을 사용해 동적 변수 삽입.  \n컨텍스트 트리: Prompt는 Root → Sub‑Prompt 형태로 계층화 가능, 각 단계마다 Sampling 파라미터를 재정의할 수 있다.  \n3.4 Sampling  \n전파 메커니즘:  메서드로 Host가 현재 temperature, top‑p 등을 Server에 전달.  \n조정 시점: Tool 실행 전후, 또는 사용자 피드백(예: “more creative”)에 따라 동적으로 변경.  \n3.5 Roots  \n역할: 세션·작업을 구분하는 고유 식별자.  \n관리: ,  로 생명주기 제어.  \n멀티‑Root: 복수 작업을 병렬 처리할 때 각각 독립된 컨텍스트 트리를 유지.  \nMCP Server 구축 방법  \n4.1 사전 준비  \n  항목   권장 버전  \n ------ ----------- \n  Node.js   >=18  \n  Python   >=3.10  \n  Docker   >=24  \n  데이터베이스 (옵션)   SQLite (개발), PostgreSQL (프로덕션)  \n4.2 공식 SDK 소개  \nTypeScript SDK:  (npm) – ,  클래스 제공.  \n  - 공식 레포:   \nPython SDK:  (PyPI) – ,  모듈 제공.  \n  - 공식 레포:   \n4.3 최소 구현 예제 (TypeScript)  \n패키지 설치  \n   \n핸들러 등록  \n   \n인증 및 스코프 설정  \n   \n주의: 위 코드는 실제 실행을 위한 최소 예시이며, 프로덕션에서는 입력 검증, 오류 처리, 로깅, 레이트 리밋 등을 추가해야 한다.  \n4.4 Python 예제 (핵심 흐름)  \n패키지 설치  \n   \n서버 구현  \n   \n4.5 설정 파일 구조  \ndocker-compose.ymlDeploymentServiceIngressSecretfile.readread:filegit.clonerepo.searchprompt.codeContextrootIdsampling.updatecrm.fetchCustomerpayment.initiatesensor.readmaintenance.schedulecatalog.searchuser.profileread:fileinvoke:weatherapiAuthorization: Bearer params.argsvalidatemcp.routing.inspectscope mismatchdefineScopeParse error` 확인   JSON 직렬화 라이브러리 사용 검증  \n8.4 참고 문서·링크 모음  \n  종류   링크  \n ------ ------ \n  공식 스펙     \n  TypeScript SDK     \n  Python SDK     \n  MCP 레지스트리     \n  Claude Desktop 소개     \n  LangChain Tools 비교     \n  OpenAI Function Calling     \n  Thoughtworks MCP 분석     \n  Udemy 강좌     \n  IAM 보안 가이드     \n--- \n본 문서는 2024‑12 기준 공개된 정보를 기반으로 작성되었습니다. 최신 버전이나 신규 기능에 대해서는 공식 사이트 및 레포지터리를 지속적으로 확인하시기 바랍니다.",
    "excerpt": "MCP란 무엇인가  \n1.1 정의 및 핵심 개념  \nModel Context Protocol (MCP) 은 Anthropic이 2024년 11월에 공개한 오픈 표준 프로토콜이다.  \nLLM(대형 언어 모델)이 외부 시스템(데이터베이스, 파일, 웹 API 등)과 양방향으로 연결되어, 컨텍스트를 일관되게 전달·관리하고, 보안·신뢰성을 유지하도록 설계되었다....",
    "tags": [
      "MCP",
      "Model Context Protocol",
      "Anthropic",
      "AI Integration",
      "JSON-RPC",
      "SDK",
      "llm",
      "protocol",
      "open-standard",
      "ai"
    ],
    "lastModified": "2026-02-17T17:50:34Z",
    "author": "SEPilot AI"
  },
  {
    "title": "Continuous AI 실천: 에이전트형 CI로 오늘 자동화할 수 있는 작업",
    "slug": "ai/continuous-ai",
    "content": "Continuous AI 실천: 에이전트형 CI로 오늘 자동화할 수 있는 작업\n개요\nGitHub Blog에 실린 Continuous AI in practice: What developers can automate today with agentic CI 글에서는 Continuous AI(연속 AI)라는 새로운 자동화 패턴을 소개합니다. 기존 CI가 규칙 기반(테스트 통과/실패, 빌드 성공/실패) 작업을 담당한다면, Continuous AI는 판단·해석·의도가 필요한 작업을 AI 에이전트가 지속적으로 수행하도록 합니다.\nCI와 Continuous AI의 차이점\n  구분   CI (기존)   Continuous AI  \n ------ ----------- ---------------- \n  목표   결정론적 규칙을 자동화   규칙으로 표현하기 어려운 판단·해석 작업 자동화  \n  결과   이진(통과/실패)   자연어 기반 보고서, 패치 제안, 이슈 등 다양한 아티팩트  \n  적용 범위   테스트, 빌드, 린트 등   문서·코드 일관성 검증, 의존성 변화 감지, 성능·사용성 회귀 탐지 등  \nContinuous AI가 의미하는 것\n새로운 패턴:  이 라는 식으로 정의됩니다.\n에이전트 실행: 에이전트는 레포지토리 안에서 CI 잡처럼 지속적으로 실행되지만, 규칙이 아닌 자연어 명세를 기반으로 판단합니다.\n출력 형태: PR, 이슈, 코멘트, 보고서 등 개발자가 검토할 수 있는 형태로 결과를 제공합니다.\n예시 워크플로우\n문서와 구현 일치 여부 확인\n   - \"문서에 적힌 동작과 실제 구현이 일치하는지 확인하고, 차이가 있으면 구체적인 수정안을 제시해 주세요.\"\n주간 프로젝트 활동 보고서 생성\n   - \"지난 주의 커밋, 이슈, PR 통계를 요약하고, 버그 트렌드와 코드 churn이 높은 영역을 강조해 주세요.\"\n성능 회귀 탐지\n   - \"핵심 경로에서 성능이 저하된 부분을 찾아내고, 원인과 개선 방안을 제시해 주세요.\"\n사용자 흐름의 의미적 회귀 감지\n   - \"UI 흐름이 변경되어 사용자가 혼란스러워지는 경우를 탐지하고, 구체적인 리그레이션 사례를 보고해 주세요.\"\n안전 가드레일 (Guardrails)\n기본적으로 읽기 전용 권한만 부여됩니다. 에이전트가 직접 코드를 수정하거나 PR을 머지할 수 없습니다.\nSafe Outputs 설정을 통해 에이전트가 생성할 수 있는 아티팩트(예: PR 열기, 이슈 생성)를 명시적으로 제한합니다.\n모든 행동은 로그와 감사가 가능하도록 기록됩니다.\n자연어와 YAML의 보완 관계\n규칙 기반 작업은 기존 CI와 YAML 스키마로 충분히 표현합니다.\n판단·해석이 필요한 작업은 자연어 명세가 더 직관적이며, 에이전트가 이를 해석해 실행합니다.\n따라서 자연어는 YAML을 대체하지 않고 보완합니다.\n개발자는 여전히 루프에 참여\n에이전트가 만든 PR·이슈·코멘트는 모두 개발자가 검토하고 머지 여부를 결정합니다.\n에이전트는 자동 커밋이나 자동 머지를 하지 않으며, 최종 판단은 인간에게 남겨둡니다.\nGitHub Next 실험 사례\n에이전트 워크플로우를 GitHub Action 형태로 컴파일하고 레포에 푸시합니다.\n이후 pull request, push, schedule 등 다양한 트리거에 의해 에이전트가 실행됩니다.\n모든 과정이 투명하게 공개되어, 팀이 언제든지 동작을 확인하고 조정할 수 있습니다.\n결론\nContinuous AI는 CI가 다루지 못하는 판단·해석 작업을 AI 에이전트가 지속적으로 수행하도록 하는 새로운 자동화 패러다임입니다. 규칙 기반 CI와 자연어 기반 에이전트가 서로 보완하면서, 개발자는 AI가 제안하는 인사이트와 패치를 검토하고 최종 결정을 내리는 흐름을 유지합니다. 이를 통해 반복적인 판단 작업을 줄이고, 개발 생산성을 높일 수 있습니다.\n이 문서는 GitHub Blog의 \"Continuous AI in practice: What developers can automate today with agentic CI\" 글을 기반으로 작성되었습니다.",
    "excerpt": "Continuous AI 실천: 에이전트형 CI로 오늘 자동화할 수 있는 작업\n개요\nGitHub Blog에 실린 Continuous AI in practice: What developers can automate today with agentic CI 글에서는 Continuous AI(연속 AI)라는 새로운 자동화 패턴을 소개합니다. 기존 CI가 규칙 기반...",
    "tags": [
      "Continuous AI",
      "CI",
      "에이전트",
      "GitHub"
    ],
    "lastModified": "2026-02-17T17:50:34Z",
    "author": "GitHub Action"
  },
  {
    "title": "glm 5",
    "slug": "ai/glm-5",
    "content": "소개\nGLM‑5 개요 및 발표 배경  \n  GLM‑5는 2024년 말에 발표된 차세대 대형 언어 모델(Large Language Model)로, 기존 GLM‑4 시리즈의 아키텍처를 확장하고 중국어 및 다국어 지원을 강화한 버전입니다. 발표는 ZAI(또는 Zhipu AI)와 협력 파트너들을 중심으로 진행되었습니다.  \n주요 특징 요약  \n  - 스케일: 파라미터 수와 레이어 구성이 기존 모델보다 크게 증가(정확한 수치는 추가 조사가 필요합니다).  \n  - 언어 지원: 중국어, 영어를 포함한 20개 이상의 언어에 최적화.  \n  - 최신 기술: Transformer 기반 아키텍처, 고효율 토큰화, 확장된 컨텍스트 윈도우(구체적 크기는 추가 조사가 필요합니다).  \n공식 홈페이지 설명\n모델 아키텍처와 핵심 기술  \n  GLM‑5는 Transformer 구조를 기반으로 하며, 기존 GLM 시리즈와 동일하게 인코더‑디코더 형태를 채택하고 있습니다. 토큰화는 Byte‑Level BPE 방식을 사용해 다양한 언어에 대한 높은 표현력을 제공합니다. 자세한 내용은 모델 카드(Hugging Face)와 공식 분석 페이지(Artificial Analysis)를 참고하세요.  \n제공되는 서비스 형태  \n  - API: RESTful API 형태로 클라우드에서 호출 가능.  \n  - 클라우드: 주요 클라우드 파트너(AWS, Azure 등)와 연동된 매니지드 서비스.  \n  - 온‑프레미스: 기업용 라이선스를 통해 자체 데이터센터에 배포 가능(세부 조건은 추가 조사가 필요합니다).  \n지원 언어 및 적용 분야  \n  - 지원 언어: 중국어, 영어, 한국어, 일본어 등 20개 이상.  \n  - 적용 분야: 번역, 요약, 코드 생성, 대화형 AI, 검색 보강 등 다양한 NLP 작업에 활용됩니다.  \n모델 상세 스펙\n  항목   내용  \n ------ ------ \n  파라미터 수   추가 조사가 필요합니다  \n  레이어 구성   추가 조사가 필요합니다  \n  컨텍스트 윈도우 크기   추가 조사가 필요합니다 (Artificial Analysis 페이지에 “Context Window” 섹션이 존재)  \n  학습 데이터 규모   대규모 웹 텍스트, 코드, 멀티모달 데이터 포함(구체적 규모는 추가 조사가 필요합니다)  \n  인텔리전스 지표   Intelligence, Openness 등 다양한 지표가 제공됨(Artificial Analysis)  \n성능 및 벤치마크\n주요 벤치마크 테스트  \n  - MMLU, BIG‑bench 등 표준 벤치마크에서 GLM‑5는 기존 GLM‑4 대비 성능 향상을 보였다고 보고됩니다(정확한 점수는 추가 조사가 필요합니다).  \n경쟁 모델과 비교  \n  - GPT‑4, LLaMA‑2, MiniMax 2.5 등과 비교했을 때, GLM‑5는 비용 대비 성능에서 경쟁력을 갖춘 것으로 평가됩니다. 상세 비교표는 아직 공개되지 않아 추가 조사가 필요합니다.  \n실제 적용 사례별 성능  \n  - 번역: 다국어 번역 정확도 향상.  \n  - 요약: 긴 문서 요약 시 일관성 및 핵심 정보 보존율 상승.  \n  - 코드 생성: 프로그래밍 언어별 코드 완성 정확도 개선.  \n  (각 사례별 정량적 지표는 추가 조사가 필요합니다.)  \n가격 및 토큰 사용 정책\n가격 책정 구조  \n  - 토큰당 비용, 월 구독 플랜, 엔터프라이즈 계약 등 다양한 옵션이 제공됩니다. 구체적인 가격표는 공식 페이지(Artificial Analysis – Pricing)에 안내되어 있으나, 상세 금액은 현재 공개되지 않아 추가 조사가 필요합니다.  \n토큰 사용량 예시와 비용 계산 방법  \n  - 예시: 1,000 토큰 요청 → 추가 조사가 필요합니다 비용.  \n무료 체험 및 제한 사항  \n  - 신규 사용자에게 일정량의 무료 토큰 제공(구체적 양은 공식 문서 확인 필요).  \n사용 방법 가이드\nAPI 인증 및 호출 절차\nAPI 키 발급: 공식 포털에서 계정을 생성하고 API 키를 발급받습니다.  \n엔드포인트:  (실제 URL은 공식 문서 확인).  \n헤더:   \n요청/응답 포맷 예시\n응답:\n파라미터 튜닝 팁\ntemperature: 0.01.0, 낮을수록 결정적, 높을수록 다양성 증가.  \ntopp: nucleus sampling, 0.80.95 권장.  \nmaxtokens: 컨텍스트 윈도우와 비용을 고려해 설정.  \n제한 사항 및 주의점\n모델 한계  \n  - Hallucination: 사실과 다른 정보를 생성할 가능성이 존재합니다.  \n  - 편향: 학습 데이터에 내재된 문화·사회적 편향이 반영될 수 있습니다.  \n보안·프라이버시 고려사항  \n  - 민감한 데이터 전송 시 TLS 암호화 사용 권장.  \n  - 기업용 온‑프레미스 배포 시 데이터 탈출 방지를 위한 네트워크 격리 필요.  \n권장 사용 시나리오와 비추천 상황  \n  - 권장: 고객 지원 챗봇, 문서 요약, 코드 보조 등.  \n  - 비추천: 의료 진단, 법률 자문 등 고위험 분야(전문가 검증 필요).  \nFAQ\n  질문   답변  \n ------ ------ \n  GLM‑5와 GPT‑4 중 어느 것이 더 좋나요?   용도와 비용에 따라 다릅니다. GLM‑5는 비용 효율성이 높으며 다국어 지원에 강점이 있습니다.  \n  무료 체험 토큰은 어떻게 얻나요?   공식 포털에서 회원가입 후 자동으로 제공됩니다(구체적 양은 공식 문서 확인).  \n  온‑프레미스 배포는 가능한가요?   엔터프라이즈 라이선스 계약 시 가능하나, 상세 절차는 추가 조사가 필요합니다.  \n  모델이 생성한 내용이 사실인지 어떻게 검증하나요?   외부 검증 API 또는 인간 검토 과정을 병행하는 것이 권장됩니다.  \n  토큰 사용량을 모니터링하는 방법은?   API 응답의  필드를 활용하거나 대시보드에서 실시간 모니터링 가능합니다.  \n참고 자료 및 링크\n공식 모델 카드: https://huggingface.co/zai-org/GLM-5  \nArtificial Analysis – GLM‑5 페이지: https://artificialanalysis.ai/models/glm-5  \nAI‑Manual 기사 (GLM‑5 vs MiniMax 2.5): https://ai-manual.ru/article/glm-5-i-minimax-25-kitaj-zapuskaet-agentskie-vojnyi/ (러시아어)  \n관련 커뮤니티·포럼: Hugging Face Discussions, ZAI 공식 포럼(링크는 추후 확인 필요)  \n본 문서는 현재 공개된 자료를 기반으로 작성되었으며, 일부 상세 스펙 및 가격 정보는 추가 조사가 필요합니다.",
    "excerpt": "소개\nGLM‑5 개요 및 발표 배경  \n  GLM‑5는 2024년 말에 발표된 차세대 대형 언어 모델(Large Language Model)로, 기존 GLM‑4 시리즈의 아키텍처를 확장하고 중국어 및 다국어 지원을 강화한 버전입니다. 발표는 ZAI(또는 Zhipu AI)와 협력 파트너들을 중심으로 진행되었습니다.  \n주요 특징 요약  \n  - 스케일: 파라...",
    "tags": [
      "GLM-5",
      "대형 언어 모델",
      "AI 서비스",
      "벤치마크"
    ],
    "lastModified": "2026-02-17T17:50:34Z",
    "author": "SEPilot AI"
  },
  {
    "title": "바이브 코딩이란?",
    "slug": "ai/vibe-coding",
    "content": "서론\n바이브 코딩(Vibe Coding) 은 대규모 언어 모델(LLM)에 자연어 프롬프트를 입력해 원하는 동작을 구현하도록 코드를 자동 생성하는 개발 방식이다. 전통적인 코딩이 문법·구조를 직접 타이핑하는 데 초점을 맞춘다면, 바이브 코딩은 “느낌(vibe)” 정도만 전달하면 AI가 그에 맞는 구현을 제공한다는 점에서 차별화된다.  \n이 문서는  \n 바이브 코딩의 정의와 핵심 개념을 이해하고,  \n 기존 코딩 방식과의 차이점을 파악하며,  \n 실제 현업·교육 현장에서 어떻게 활용되는지 살펴보고자 한다.  \n주된 독자층은 소프트웨어 엔지니어, 팀 리더, 교육자, 그리고 AI 기반 개발 도구에 관심 있는 일반 개발자이다.\n바이브 코딩의 어원\n  요소   설명  \n ------ ------ \n  Vibe   ‘느낌’, ‘분위기’를 의미한다. 사용자가 구현하고자 하는 기능의 구체적인 로직보다 목표 결과의 감각을 강조한다.  \n  Coding   전통적인 프로그래밍 행위. 여기서는 AI가 대신 수행하는 코드 생성 과정을 의미한다.  \nAndre​j Karpathy(전 Tesla AI 책임자)는 2025년 2월, 인터뷰와 블로그 글에서 “바이브 코딩”이라는 용어를 처음 제시하였다. 그는 “그저 사물을 보고, 말하고, 복사‑붙여넣기만 하면 대부분 작동한다”는 입장을 밝히며, 이 개념이 ‘프로그래밍 언어는 영어가 가장 인기 있는 새로운 언어’라는 주장과 연결된다고 설명했다.  \n어원에서 파생된 의미는 “느낌만으로 코드를 만든다”는 점이며, 초기 사용 사례는 AI 기반 코드 자동 완성 도구(GitHub Copilot, Claude 등)를 활용한 프로토타이핑 작업이다.\n올바른 바이브 코딩의 해석\n느낌만으로 코드를 만든다는 의미는 “자연어로 기능 요구를 전달하면 AI가 구체적인 구현을 제공한다”는 뜻이다.  \n프롬프트 설계와 컨텍스트 제공이 핵심이다. 명확한 목표, 입력·출력 예시, 제약 조건 등을 포함한 프롬프트가 좋은 결과를 만든다.  \nAI‑Generated 코드와 인간 개발자의 역할 구분  \n    AI는 초안·아이디어 구현을 빠르게 제공한다.  \n    인간 개발자는 코드 검증·리팩터링·보안 검토를 담당한다.  \n바이브 코딩 기술적 기반\n대규모 언어 모델(LLM) : GPT‑4, Claude 2, Gemini 등은 자연어를 코드로 변환하는 능력을 갖춘다.  \n프롬프트 엔지니어링 : 효과적인 프롬프트 작성법(페르소나 정의, 문제 명확화, 컨텍스트 제공 등)은 “Agentic AI Prompting Best Practices”(LinkedIn)에서 제시된 단계와 일치한다.  \n환각(Hallucination) : 모델이 존재하지 않는 API나 논리적 오류를 만들어낼 수 있다. 이를 방지하려면 출력 검증(테스트 자동화, 정적 분석)과 인간 리뷰가 필요하다.  \n주요 도구와 플랫폼\n  도구   주요 특징   참고 링크  \n ------ ---------- ----------- \n  GitHub Copilot   VS Code·JetBrains 플러그인, 실시간 코드 제안   https://github.com/features/copilot  \n  Claude (Anthropic)   대화형 프롬프트, “CLAUDE.md” 템플릿 활용   https://www.anthropic.com/claude  \n  Claude‑Assist   팀 협업용 프롬프트 관리, AGENTS.md 지원   https://www.anthropic.com/assist  \n  ChatGPT (OpenAI)   다양한 언어·프레임워크 지원, 플러그인 생태계   https://chat.openai.com/  \n설정 파일·프롬프트 템플릿 예시(‘CLAUDE.md’, ‘AGENTS.md’)는 FastCampus GitBook “Best practice” 챕터에서 상세히 다루고 있다.\n바이브 코딩 문화와 커뮤니티\n시민 개발자·바이브 코딩 엔지니어라는 새로운 직군이 등장했다. 이들은 전통적인 개발 지식보다 AI와 프롬프트 설계 능력을 강조한다.  \n온라인 커뮤니티: Reddit r/vibecoding, Discord “VibeCoders”, 네이버 카페 “바이브 코딩 연구소” 등에서 사례 공유와 토론이 활발히 진행된다.  \n교육 프로그램: FastCampus, 삼성SDS 인사이트 리포트, 여러 대학의 AI·소프트웨어 교육 과정에 바이브 코딩 모듈이 포함되고 있다.  \n기업 채택 사례: 삼성SDS는 내부 파일럿 프로젝트에서 프로토타이핑 속도를 30% 이상 단축했으며, 스타트업은 초기 MVP 개발에 AI 코딩을 활용해 인력 비용을 절감하고 있다.\n장점과 기대 효과\n  효과   정량·정성 사례  \n ------ ---------------- \n  생산성·시간 절감   삼성SDS 파일럿: 평균 2일 → 0.5일(≈75% 감소)  \n  소프트웨어 민주화   비전문가도 자연어로 기능을 정의 → 코드 자동 생성  \n  아이디어 검증·프로토타이핑   스타트업 설문: AI‑Generated 코드 사용 후 아이디어 검증 시간 40% 단축  \n한계와 위험 요소\n코드 품질·보안: AI가 생성한 코드는 종종 보안 취약점이나 비효율적인 구조를 포함한다. 정적 분석·보안 스캐너 적용이 필수이다.  \n의존성 문제: “왜 이렇게 작성했나요?” 라는 질문에 답변하기 어려운 상황이 발생한다. 이는 팀 협업과 유지보수에 위험을 초래한다.  \n법적·윤리적 이슈: 베른 협약에 가입한 국가에서는 AI가 생성한 코드의 저작권·라이선스 문제가 논의되고 있다. 추가 조사가 필요합니다.  \n실제 적용 사례\n삼성SDS 파일럿 – 내부 업무 자동화 툴 개발에 Claude 기반 바이브 코딩을 적용, 평균 개발 주기 3주 → 1주로 단축.  \n교육 현장 – FastCampus “바이브 코딩 실전 가이드” 강좌에서 수강생 85%가 AI‑Generated 코드를 활용해 과제 제출, 평균 점수 12% 상승.  \n오픈소스 프로젝트 – “vibe‑utils” GitHub 레포지토리(추가 조사가 필요합니다)에서 AI가 자동 생성한 유틸리티 함수들을 커뮤니티가 검토·채택하고 있다.  \n미래 전망 및 발전 방향\n멀티모달 프롬프트: 텍스트·이미지·음성 등을 결합한 입력이 가능해지면서 UI·UX 설계 단계에서도 바이브 코딩이 적용될 전망이다.  \n전통 개발 프로세스와 융합: CI/CD 파이프라인에 AI 코드 생성·검증 단계가 통합되어, “AI‑first” 워크플로우가 표준화될 가능성이 있다.  \n정책·규제 변화: 각국 정부가 AI‑Generated 코드에 대한 표준·인증 제도를 마련함에 따라, 도구 선택과 사용 방식에 영향을 미칠 것이다.  \n결론\n바이브 코딩은 자연어 기반 AI 코드 생성이라는 새로운 패러다임을 제시하며, 개발 생산성 향상과 소프트웨어 민주화라는 두 축을 동시에 추구한다. 그러나 품질·보안·법적 측면의 리스크를 관리하지 않으면 장기적인 유지보수에 부정적 영향을 미칠 수 있다.  \n실천 가이드\n시작 방법: GitHub Copilot 또는 Claude 무료 체험 계정을 만든 뒤, 간단한 “TODO 리스트를 관리하는 앱”을 자연어 프롬프트로 구현해 본다.  \n학습 로드맵  \n   - 프롬프트 엔지니어링 기본 (FastCampus “Agentic AI Prompting”)  \n   - LLM 동작 원리 이해 (OpenAI, Anthropic 공식 문서)  \n   - 코드 검증·보안 도구 사용법 (SonarQube, Dependabot)  \n주시해야 할 트렌드**  \n   - 멀티모달 LLM 출시 일정  \n   - AI 코드 생성에 대한 국제 표준화 움직임  \n   - 기업 내 AI‑first 개발 문화 확산  \n바이브 코딩은 아직 진화 단계에 있지만, 올바른 프레임워크와 검증 절차를 갖춘다면 현대 소프트웨어 개발에 강력한 보조 수단이 될 것이다.",
    "excerpt": "서론\n바이브 코딩(Vibe Coding) 은 대규모 언어 모델(LLM)에 자연어 프롬프트를 입력해 원하는 동작을 구현하도록 코드를 자동 생성하는 개발 방식이다. 전통적인 코딩이 문법·구조를 직접 타이핑하는 데 초점을 맞춘다면, 바이브 코딩은 “느낌(vibe)” 정도만 전달하면 AI가 그에 맞는 구현을 제공한다는 점에서 차별화된다.  \n이 문서는  \n 바이브...",
    "tags": [
      "바이브코딩",
      "AI코딩",
      "프롬프트엔지니어링",
      "소프트웨어개발"
    ],
    "lastModified": "2026-02-17T17:50:34Z",
    "author": "SEPilot AI"
  },
  {
    "title": "MAS (Multi Agent System)",
    "slug": "ai/multi-agent-system",
    "content": "MAS (Multi Agent System)\n개요\n다중 에이전트 시스템(Multi-Agent System, MAS)은 여러 인공지능(AI) 에이전트가 협력·조정하여 사용자나 다른 시스템을 대신해 복합적인 작업을 수행하도록 설계된 시스템이다. 각 에이전트는 자체적인 속성과 자율성을 가지며, 전체 시스템은 공통 목표를 달성하기 위해 에이전트 간의 커뮤니케이션·협업을 활용한다.\n2025년이 \"에이전트의 해\"였다면, 2026년은 모든 멀티 에이전트 시스템이 프로덕션으로 이행하는 해로 평가받고 있다. 단일 범용 에이전트에서 전문화된 에이전트 팀의 오케스트레이션 아키텍처로의 전환이 가속화되고 있으며, Gartner에 따르면 멀티 에이전트 시스템 관련 문의가 2024년 Q1 대비 2025년 Q2에 1,445% 급증했다. (IBM, Landbase)\n핵심 구성 요소\n  요소   설명  \n ------ ------ \n  에이전트   LLM 기반 AI 에이전트로, 자연어 이해·생성, 도구 호출, 계획 수립 등을 수행한다  \n  지식·메모리   에이전트는 외부 데이터, API, 웹 검색 등 도구를 활용해 정보를 획득하고, 단기/장기/엔티티 메모리를 관리한다  \n  통신 프로토콜   에이전트 간 메시지를 주고받으며 목표·계획·결과를 공유한다 (A2A, MCP 등)  \n  조정 메커니즘   중앙 집중식·분산식·계층형·홀로닉·연합·팀 등 다양한 아키텍처가 존재한다  \n  도구(Tools)   에이전트가 외부 시스템과 상호작용하기 위한 인터페이스 (DB 쿼리, API 호출, 파일 시스템 등)  \n  오케스트레이터   에이전트 팀의 작업 분배, 진행 추적, 오류 복구를 위한 재계획을 담당하는 상위 에이전트  \n아키텍처 유형\n중앙 집중식 네트워크\n중앙 서버가 전역 지식 베이스와 에이전트 연결을 관리한다.\n장점: 통신이 쉽고 지식이 일관됨.\n단점: 중앙 서버 장애 시 전체 시스템이 중단될 위험이 있다.\n분산형 네트워크\n에이전트가 인접 에이전트와 직접 정보를 교환한다.\n장점: 견고하고 모듈성이 높으며 단일 장애점이 없음.\n단점: 협업을 위한 행동 조정이 복잡할 수 있다.\n계층형 구조\n트리 형태로 상위·하위 에이전트가 존재한다.\n상위 에이전트가 의사결정 권한을 갖고, 하위 에이전트는 구체 작업을 수행한다.\nMicrosoft의 Magentic-One이 대표적 예로, Orchestrator가 4개 전문 에이전트를 지휘한다.\n홀로닉 구조\n에이전트가 \"홀론\" 단위로 그룹화되어, 하나의 전체와 여러 하위 에이전트가 동시에 존재한다.\n연합·팀 구조\n에이전트가 일시적으로 연합하거나 팀을 이루어 특정 목표를 달성한다.\nClaude Code의 Agent Teams, CrewAI의 Crews 등이 이 구조에 해당한다.\n출처: IBM - 다중 에이전트 시스템이란?\nA2A, MCP, MAS의 관계\nMAS 생태계를 이해하기 위해서는 세 가지 핵심 개념의 관계를 파악해야 한다.\n개념 비교표\n  항목   MAS   A2A   MCP  \n ------ ----- ----- ----- \n  수준   개념/아키텍처   프로토콜   프로토콜  \n  발표   학술 개념 (1990년대)   Google, 2025.04   Anthropic, 2024.11  \n  목적   다중 에이전트 협업 시스템   에이전트 간 통신   에이전트와 도구/데이터 연결  \n  거버넌스   N/A   Linux Foundation   AAIF (Linux Foundation)  \n  기반 기술   프레임워크에 의존   HTTP, SSE, JSON-RPC, gRPC   JSON-RPC 2.0  \n  방향성   전체 시스템   수평적 (에이전트↔에이전트)   수직적 (에이전트↔도구)  \nMAS는 \"무엇을 만들 것인가(what)\"이고, A2A와 MCP는 \"어떻게 만들 것인가(how)\"에 해당하는 구체적 프로토콜이다.\nGoogle A2A (Agent-to-Agent) 프로토콜\n서로 다른 프레임워크, 벤더, 서버에서 구축된 AI 에이전트들이 상호 통신하고 협업할 수 있도록 설계된 개방형 표준이다. 2025년 4월 Google Cloud가 발표했다.\nAgent Card: 각 에이전트가 자신의 정체성, 기능, 스킬, 인증 요구사항을 기술한 JSON 메타데이터를 으로 발행\nTask 관리: 생명주기 상태를 통해 빠른 작업부터 장시간 심층 연구까지 관리\n지원 규모: 2025년 7월 기준 150개 이상의 조직이 지원 (Atlassian, Salesforce, SAP, PayPal, AWS, Microsoft 등)\n최신 상태: Linux Foundation 산하 프로젝트로 편입, v0.3에서 gRPC 지원 추가\n출처: Google Developers Blog, A2A Protocol, Linux Foundation\nAnthropic MCP (Model Context Protocol)\nAI 어시스턴트를 데이터 소스, 도구, 외부 서비스에 연결하기 위한 개방형 표준 프로토콜이다. Language Server Protocol(LSP)에서 영감을 받았다.\n3계층 아키텍처: Host(사용자 앱) → Client(연결 관리) → Server(도구/리소스 노출)\n핵심 기능: Tools(도구 호출), Resources(데이터 소스), Prompts(템플릿)\n채택 현황: OpenAI(2025.03), Google DeepMind(2025.04) 공식 채택. 10,000개 이상의 MCP 서버가 프로덕션 운영 중\n거버넌스: 2025년 12월 Agentic AI Foundation(AAIF)에 기증 (Anthropic, OpenAI, Block 공동 설립, Linux Foundation 산하)\n출처: Anthropic - MCP 발표, MCP Spec, Anthropic - AAIF\nA2A와 MCP는 보완적 관계\n두 프로토콜은 에이전틱 스택의 서로 다른 계층에서 작동한다:\n  시나리오   선택  \n ---------- ------ \n  단일 에이전트가 여러 도구/DB에 접근   MCP  \n  서로 다른 벤더의 에이전트들이 협업   A2A  \n  IDE에서 AI가 코드 분석 도구 호출   MCP  \n  구매 에이전트가 판매 에이전트와 협상   A2A  \n  복잡한 멀티 에이전트 기업 시스템   MCP + A2A 함께  \n출처: Auth0 - MCP vs A2A Guide, TrueFoundry, Clarifai\n주요 AI Agent 개발 도구\n상용 도구\n  도구   개발사   MAS 지원 수준   핵심 MAS 기능  \n ------ -------- -------------- -------------- \n  Claude Code   Anthropic   높음   Subagents, Agent Teams (실험적)  \n  Cursor   Cursor Inc.   높음   멀티 에이전트 병렬, Subagents, 자동 판정  \n  Google Antigravity   Google   높음   Manager View 멀티 에이전트 오케스트레이션  \n  GitHub Copilot   GitHub/MS   중상   Agent Mode, Agent Skills, Coding Agent  \n  Devin   Cognition Labs   중상   멀티 에이전트 디스패치, 병렬 실행  \n  Windsurf   Codeium   중간   Cascade 에이전트, Agent Skills  \nClaude Code (Anthropic)\nAnthropic의 공식 CLI 기반 AI 코딩 에이전트.\nSubagents: 메인 에이전트 내에서 특정 작업을 수행하는 독립 에이전트. 자체 컨텍스트 윈도우, 커스텀 시스템 프롬프트, 독립적 도구 접근 권한 보유. 결과를 메인 에이전트에게만 보고.\nAgent Teams (실험적): Opus 4.6과 함께 출시. 여러 Claude Code 인스턴스가 병렬로 자율 협력. 팀 리드가 팀원을 생성하고, 팀원들은 서로 직접 메시지를 주고받으며 공유 작업 목록에서 자체 조율.\n  구분   Context   Communication   Coordination  \n ------ --------- --------------- -------------- \n  Subagents   메인 세션 내   결과 → 메인만   메인 에이전트가 전체 관리  \n  Agent Teams   각 팀원 별도 컨텍스트   팀원 ↔ 팀원 직접   공유 작업 리스트, 자체 조정  \n출처: Claude Code Subagents 문서, Claude Code Agent Teams\nGoogle Antigravity\n2025년 11월 Gemini 3 출시와 함께 발표된 에이전틱 개발 플랫폼.\nVS Code 포크 기반의 완전한 독립 플랫폼\nEditor View: 에이전트 사이드바가 있는 일반적인 IDE 인터페이스\nManager View: 여러 에이전트를 병렬로 오케스트레이션하는 제어 센터. 비동기 작업 실행 가능\nGemini 3 기반, Anthropic Claude 및 OpenAI 모델도 지원\n현재 Public Preview로 무료 제공\n출처: Google Developers Blog - Antigravity, Wikipedia\nCursor\nVS Code 포크 기반 AI 코딩 IDE. 2026년 2월 기준 멀티 에이전트 기능 프리뷰 제공 중.\nAgent Mode (Composer): 다단계 코딩 작업을 자율적으로 처리\nMulti-Agent Interface: Cursor 2.0에서 도입. 여러 AI 에이전트가 병렬 작업 가능\n자동 판정 시스템: 여러 에이전트를 병렬 실행 후 최적 솔루션을 자동 평가·추천\n출처: Cursor 2.0 - InfoQ, Cursor 2.2 Changelog\nVS Code 1.109 - 멀티 에이전트 개발의 허브\n2026년 2월 VS Code 1.109에서 Microsoft는 VS Code를 \"멀티 에이전트 개발의 홈\"으로 선언했다.\nClaude, Codex, Copilot 에이전트를 동시에 실행\n여러 에이전트 세션을 로컬/백그라운드/클라우드에서 병렬 관리\nAgent Skills가 GA(일반 제공)로 전환\n출처: VS Code Blog, Visual Studio Magazine\n오픈소스 MAS 프레임워크\n  프레임워크   개발사   언어   아키텍처   특징  \n ----------- -------- ------ --------- ------ \n  AutoGen / MS Agent Framework   Microsoft   Python, .NET   비동기 이벤트 기반   Semantic Kernel과 통합, 2026 Q1 GA 목표  \n  CrewAI   CrewAI Inc.   Python   역할 기반, Crews + Flows   직관적 역할 설계, 100+ 내장 도구  \n  LangGraph   LangChain   Python, JS/TS   상태 기반 그래프   영속 상태, 타임트래블 디버깅, 1.0 출시  \n  OpenAI Agents SDK   OpenAI   Python, TS   핸드오프 기반   Swarm 후속, 가드레일, 트레이싱 내장  \n  Magentic-One   MS Research   Python   Orchestrator + 4 전문 에이전트   범용 작업 해결, 벤치마크 SOTA급  \n  Google ADK   Google   Python, TS, Go, Java   계층적 멀티 에이전트   처음부터 MAS 설계, Vertex AI 통합  \nAutoGen → Microsoft Agent Framework\nMicrosoft Research에서 개발한 멀티 에이전트 프레임워크. v0.4에서 비동기 이벤트 기반 아키텍처로 개편된 후, Semantic Kernel과 통합되어 Microsoft Agent Framework으로 전환 중이다.\nPython 및 .NET 지원, TypeScript 예정\n2026년 Q1 말까지 1.0 GA 출시 목표\nAutoGen은 안정 API를 유지하며 보안 패치만 받고, 신규 기능은 Agent Framework으로\n출처: Visual Studio Magazine, MS Agent Framework\nCrewAI\n역할 기반 멀티 에이전트 협업에 특화된 Python 프레임워크. LangChain에 독립적으로 구축.\n역할 기반 아키텍처: 에이전트에 역할(연구원, 작가, 분석가 등), 목표, 배경 이야기 부여\n협업 프로세스: Sequential(순차), Hierarchical(관리자 조율), Consensus(합의 기반)\nCrews + Flows 이중 구조: Crews(자율적 팀), Flows(이벤트 기반 워크플로우)\nGitHub 스타 20,000+\n출처: CrewAI 공식, CrewAI GitHub\nLangGraph (LangChain)\n상태 기반 그래프 아키텍처의 에이전트 오케스트레이션 프레임워크.\n사이클을 포함하는 LLM 워크플로우 생성 가능 (에이전트가 이전 단계를 재방문)\nDurable State: 실행 상태 자동 저장, 서버 재시작이나 장기 워크플로우 중단 시에도 이어서 실행\nTime-Travel Debugging: 과거 상태로 돌아가 디버깅 가능\n2025년 LangGraph 1.0 출시\n출처: LangGraph 공식, LangGraph Multi-Agent Workflows\nOpenCode\nGo 언어로 작성된 오픈소스 터미널 기반 AI 코딩 에이전트. Claude Code의 오픈소스 대안으로 부상.\n75개 이상 모델 지원 (Claude, GPT, Gemini, 로컬 모델 등)\nGitHub 스타 95,000+, 월 650,000명+ 개발자 사용\n전용 MAS 프레임워크라기보다 단일 에이전트 코딩 도구에 가까움\n출처: OpenCode 공식, OpenCode GitHub\nOpenClaw\n오스트리아 개발자 Peter Steinberger가 만든 오픈소스 AI 에이전트. Signal, Telegram, Discord, WhatsApp 등 메시징 서비스를 통해 실세계 작업을 수행한다.\n2025년 11월 \"Clawdbot\"으로 공개 → Anthropic 상표 항의 → \"OpenClaw\"로 이름 변경\n웹 브라우징, PDF 요약, 캘린더 관리, 에이전틱 쇼핑, 이메일 관리 등 수행\n독립적 MAS 프레임워크가 아닌, 에이전틱 인터페이스\n출처: OpenClaw Wikipedia, CNBC\n주요 기업의 MAS 전략 (2025-2026)\nGoogle - A2A + ADK\nA2A 프로토콜: 에이전트 간 통신 오픈 표준, 150+ 기업 지원\nAgent Development Kit (ADK): 오픈소스 멀티 에이전트 프레임워크 (Python, TS, Go, Java)\nAntigravity IDE: Manager View를 통한 멀티 에이전트 오케스트레이션\n출처: Google ADK\nMicrosoft - Copilot Studio + Agent Framework\nCopilot Studio: 멀티 에이전트 시스템 구축 기능 (프리뷰), 에이전트 간 작업 위임\nMicrosoft Agent Framework: AutoGen + Semantic Kernel 통합, Python/.NET 지원\n2026년 전환: 개별 명령 응답에서 자율적 멀티스텝 프로세스 처리로의 주요 아키텍처 전환\n출처: Microsoft Copilot Blog, 6 core capabilities for 2026\nOpenAI - Agents SDK + AGENTS.md\nAgents SDK: Swarm의 프로덕션 후속. 핸드오프, 가드레일, 트레이싱, 음성 에이전트 내장\nAGENTS.md: 코딩 에이전트 지침 규격. 60,000+ 오픈소스 프로젝트에서 채택\nAAIF(Agentic AI Foundation) 공동 설립\n출처: OpenAI - New tools for building agents, OpenAI - AAIF\nAmazon AWS - Bedrock AgentCore\nAmazon Bedrock: 멀티 에이전트 협업 기능 2025년 3월 GA. Supervisor 기반 아키텍처\nAgentCore: re:Invent 2025에서 발표. 에이전트 경계 관리, 메모리, 평가 기능\n출처: AWS - Multi-agent collaboration\nNVIDIA - Nemotron 3\nMAS 구축을 위한 Nemotron 3 오픈 모델 패밀리 (Nano, Super, Ultra) 발표\nHybrid Latent Mixture-of-Experts 아키텍처\nSuper와 Ultra는 2026년 상반기 출시 예정\n출처: NVIDIA\nAgentic AI Foundation (AAIF)\n2025년 12월 Linux Foundation 산하에 설립. OpenAI, Anthropic, Block이 공동 창설하고, Google, Microsoft, AWS, Bloomberg, Cloudflare가 지원한다.\n주요 프로젝트: MCP (Anthropic), Goose (Block), AGENTS.md (OpenAI)\nAI 에이전트 표준화를 위한 업계 최대 협력체\n출처: OpenAI - AAIF, TechCrunch\n시장 규모와 성장 전망\n시장 규모 예측\n  연도   시장 규모   출처  \n ------ ---------- ------ \n  2025년   USD 72.9억   Fortune Business Insights  \n  2026년   USD 91.4억   Fortune Business Insights  \n  2030년   USD 520억+   MachineLearningMastery  \n  2032년   USD 932억 (CAGR 44.6%)   MarketsandMarkets  \n  2034년   USD 1,391.9억 (CAGR 40.5%)   Fortune Business Insights  \n핵심 예측 (Gartner, McKinsey 등)\n  예측   출처  \n ------ ------ \n  2026년 말까지 엔터프라이즈 앱의 40%에 태스크 전용 AI 에이전트 탑재 (2025년 5% 미만)   Gartner  \n  2028년까지 AI 에이전트가 B2B 구매에서 USD 15조 규모 주도   Gartner  \n  2028년까지 일상 업무 의사결정의 15%가 에이전틱 AI로 자율 수행   Gartner  \n  2030년까지 에이전틱 AI로 최대 USD 2.9조의 경제적 가치 창출   McKinsey  \n  2035년까지 에이전틱 AI가 기업 앱 소프트웨어 매출의 30% (USD 4,500억+) 차지   Gartner  \n산업별 영향\n소프트웨어 개발\n2026년은 소프트웨어 개발에서 \"위임(delegation)\"의 시대다. 2024년 자동완성→대화, 2025년 대화→협업에 이어, 2026년에는 AI 에이전트에게 작업을 위임하는 단계로 전환되고 있다.\n개발자의 85%가 정기적으로 AI 도구를 사용\nGartner 예측: 2026년까지 소프트웨어 엔지니어의 90%가 직접 코딩에서 AI 프로세스 오케스트레이션으로 전환\nMCP를 통해 Claude Code가 Figma, Slack, Jira, 내부 문서와 연동\n출처: Anthropic - 2026 Agentic Coding Trends Report, senorit.de\n고객 서비스\n2029년까지 에이전틱 AI가 일반 고객 서비스 이슈의 80%를 인간 개입 없이 자율 해결\n운영 비용 30% 절감 효과\n고객 서비스와 이커머스가 채택 선두 (명확한 ROI)\n출처: Gartner, BCG\n금융\n금융 서비스가 \"Frontier Firms\"(모든 워크플로우에 AI 에이전트를 내재화한 조직)의 최고 밀집 산업\nFrontier Firms의 AI 투자 수익률이 저조한 채택 기업의 약 3배\n2026년 금융 팀의 44%가 에이전틱 AI 사용 예상 (600%+ 증가)\n미국 은행 사례: AI 에이전트로 신용 위험 메모 작성 시 생산성 20-60% 향상, 신용 처리 시간 30% 단축\n출처: Microsoft, Neurons Lab\n기업 전반\n57%의 기업이 이미 AI 에이전트를 프로덕션에서 운영\n59%의 기업이 3개 이상의 LLM을 프로덕션에서 운영 (2025년 후반)\n기업들은 평균 약 USD 1.14억의 관련 투자를 계획 중\n고위 임원의 90%가 2026년 중 관련 투자를 늘릴 계획\n출처: Landbase, OneReach.ai\n미래 전망 (2026-2030)\n기술적 방향\n마이크로서비스 혁명과 유사한 전환: 단일 범용 에이전트 → 전문화된 에이전트 팀 오케스트레이션. 소프트웨어의 모놀리식→마이크로서비스 전환과 동일한 패턴. (Techzine)\n인간-AI 혼합 팀: 2028년까지 38%의 조직에서 AI 에이전트가 인간 팀의 구성원으로 참여. (G2)\n로봇·IoT 통합: AI 에이전트가 자율 창고 로봇, 배달 드론, 가정 어시스턴트와 결합하여 물리적 환경에서 작동.\n표준화 수렴: A2A(에이전트 간), MCP(에이전트-도구), AGENTS.md(코딩 에이전트 지침)가 AAIF와 Linux Foundation 하에서 통합 거버넌스.\n로우코드/노코드 민주화: 시각적 빌더를 통해 1560분 만에 에이전트 배포 가능. (MachineLearningMastery)\n과제와 리스크\n  과제   현황  \n ------ ------ \n  신뢰도 하락   완전 자율 AI 에이전트에 대한 임원 신뢰도가 43%(2024) → 22%(2025)로 하락  \n  프로젝트 취소   2027년까지 에이전틱 AI 프로젝트의 40%+가 비용, 불명확한 가치, 리스크 관리 부족으로 취소 예상  \n  시스템 복잡성   리더의 65%가 에이전틱 시스템 복잡성을 최대 장벽으로 지목  \n  보안·프라이버시   35%의 조직이 사이버보안, 30%가 데이터 프라이버시를 주요 우려로 지적  \n  통합 난이도   46%가 기존 시스템과의 통합을 주요 과제로 인식  \n  조정 실패   부서별 독립 에이전트 구축으로 연결 단절, 중복 로직, \"디지털 허드렛일\" 발생  \n출처: Computer Weekly, Salesmate\n거버넌스와 윤리\nEU AI Act: 고위험 의무가 2026년 8월 전면 적용\nGuardian Agent: Gartner 예측, 2030년까지 에이전틱 AI 시장의 10-15%를 차지. 다른 에이전트의 행동을 감시·감사하는 전문 에이전트 (Gartner)\n책임 소재: 자율 에이전트의 리소스 할당, 환자 우선순위 결정, 금융 거래 실행 등에 대한 새로운 책임 매트릭스 필요\n인증 표준: ISO 42001, NIST AI RMF 등의 제도화 가속\n출처: KDnuggets, Dataversity, Credo AI\n벤치마크와 연구 동향\n  벤치마크   설명   출처  \n --------- ------ ------ \n  TheAgentCompany   NeurIPS 2025. 실제 전문 업무 수행 능력 평가   OpenReview  \n  AgentArch   오케스트레이션 전략, ReAct vs 함수 호출, 메모리 아키텍처 등 4차원 평가   arXiv  \n  MedAgentBoard   의료 분야 멀티 에이전트 협업 벤치마크   MedAgentBoard  \n  WMAC 2026   AAAI 2026에서 개최된 LLM 기반 멀티 에이전트 협업 워크숍   WMAC 2026  \n참고 자료\n프로토콜 & 표준\nA2A Protocol Specification\nMCP Specification\nAgentic AI Foundation (AAIF)\n프레임워크\nMicrosoft Agent Framework\nCrewAI\nLangGraph\nGoogle ADK\nOpenAI Agents SDK\n시장 분석\nGartner - Top Strategic Technology Trends 2025\nFortune Business Insights - Agentic AI Market\nMarketsandMarkets - Agentic AI Market\n기업 전략\nIBM - AI tech trends 2026\nGoogle Cloud - 5 ways AI agents will transform work in 2026\nKPMG - AI at Scale 2026\n본 문서는 2026년 2월 기준 공개된 공식 자료를 기반으로 작성되었습니다. 최신 기능이나 업데이트가 있을 경우 공식 문서를 확인하시기 바랍니다.",
    "excerpt": "MAS (Multi Agent System)\n개요\n다중 에이전트 시스템(Multi-Agent System, MAS)은 여러 인공지능(AI) 에이전트가 협력·조정하여 사용자나 다른 시스템을 대신해 복합적인 작업을 수행하도록 설계된 시스템이다. 각 에이전트는 자체적인 속성과 자율성을 가지며, 전체 시스템은 공통 목표를 달성하기 위해 에이전트 간의 커뮤니케이션·...",
    "tags": [
      "Multi-Agent",
      "AI",
      "Agentic-AI",
      "MCP",
      "A2A",
      "LLM",
      "distributed-systems",
      "collaboration"
    ],
    "lastModified": "2026-02-17T17:50:34Z",
    "author": "SEPilot AI"
  },
  {
    "title": "설정 파일 가이드",
    "slug": "guide/configuration",
    "content": "설정 파일 가이드\nSEPilot Wiki의 모든 설정 파일과 옵션을 상세히 설명합니다.\n설정 파일 목록\n  파일   위치   용도  \n ------ ------ ------ \n     루트   사이트 기본 정보  \n     루트   테마 (색상, 폰트, 레이아웃)  \n     루트   네비게이션 메뉴  \n     src/styles   커스텀 CSS  \n     src   GitHub 저장소 연결 설정  \nsite.config.ts 상세\ntheme.config.ts 상세\n색상 (colors)\n폰트 (fonts)\n레이아웃 (layout)\n테두리 반경 (borderRadius)\nnavigation.config.ts 상세\nGitHub 저장소 설정\nRepository Secrets\nGitHub Repository Settings > Secrets에서 설정:\n  변수   필수   설명  \n ------ ------ ------ \n     O   OpenAI 호환 API URL  \n     O   API 키  \n     O   모델명 (예: gpt-4)  \nGitHub Pages 설정\nRepository Settings > Pages\nSource: \"GitHub Actions\" 선택\n브랜치 push 시 자동 배포\n환경 변수\n빌드 시\n개발 시\n 파일에 설정:",
    "excerpt": "설정 파일 가이드\nSEPilot Wiki의 모든 설정 파일과 옵션을 상세히 설명합니다.\n설정 파일 목록\n  파일   위치   용도  \n ------ ------ ------ \n     루트   사이트 기본 정보  \n     루트   테마 (색상, 폰트, 레이아웃)  \n     루트   네비게이션 메뉴  \n     src/styles   커스텀 CSS...",
    "tags": [
      "설정",
      "가이드",
      "TypeScript"
    ]
  },
  {
    "title": "Theme Customization",
    "slug": "guide/theme-customization",
    "content": "Theme Customization\nThis document is a placeholder for the Theme Customization guide. Add details on CSS overrides, theme variables, and design guidelines here.",
    "excerpt": "Theme Customization\nThis document is a placeholder for the Theme Customization guide. Add details on CSS overrides, theme variables, and design guidelines here.",
    "tags": [
      "theme",
      "customization",
      "appearance"
    ]
  },
  {
    "title": "Getting Started",
    "slug": "guide/getting-started",
    "content": "Getting Started\nThis document is a placeholder for the Getting Started guide. Add detailed steps, screenshots, and examples here.",
    "excerpt": "Getting Started\nThis document is a placeholder for the Getting Started guide. Add detailed steps, screenshots, and examples here.",
    "tags": [
      "getting-started",
      "introduction",
      "setup"
    ]
  },
  {
    "title": "FAQ",
    "slug": "guide/faq",
    "content": "FAQ\nSEPilot Wiki 사용에 관한 자주 묻는 질문과 답변입니다.\n일반\nSEPilot Wiki란 무엇인가요?\nSEPilot Wiki는 AI 에이전트 기반의 자동화된 위키 시스템입니다. GitHub 저장소의  폴더를 데이터 저장소로 활용하고, GitHub Issues를 통해 사용자와 소통하며, AI가 문서를 자동으로 생성/수정/유지보수합니다.\n어떤 기술 스택을 사용하나요?\nFrontend: React 18 + TypeScript + Vite\nState Management: TanStack Query\nRouting: React Router 7\nHosting: GitHub Pages\nCI/CD: GitHub Actions\n문서 작성\nAI에게 문서 작성을 요청하려면 어떻게 하나요?\nGitHub Issues에서 새 이슈를 생성합니다\n라벨을 추가합니다\n이슈 본문에 원하는 문서의 내용을 설명합니다\nAI가 자동으로 문서 초안을 작성합니다\n직접 문서를 추가하려면 어떻게 하나요?\n 폴더에 마크다운 파일을 직접 추가할 수 있습니다:\n문서 수정을 요청하려면 어떻게 하나요?\n해당 문서와 관련된 이슈에 댓글로 수정 사항을 작성하면 AI가 피드백을 반영하여 문서를 업데이트합니다.\n기능\n검색은 어떻게 작동하나요?\nFuse.js 기반의 전문 검색(Full-text search)을 지원합니다. 문서 제목, 내용, 태그 등을 대상으로 검색하며, 2자 이상 입력 시 검색이 시작됩니다.\n다크 모드를 지원하나요?\n예, 라이트/다크/시스템 테마를 지원합니다. 우측 상단의 테마 토글 버튼으로 변경할 수 있습니다.\nMermaid 다이어그램을 사용할 수 있나요?\n예, 마크다운 코드 블록에서  언어를 지정하면 다이어그램이 렌더링됩니다:\nmarkdown\nPlotly 차트도 지원하나요?\n예,  코드 블록으로 인터랙티브 차트를 추가할 수 있습니다:\nmarkdown\n문제 해결\n페이지가 404 오류를 표시합니다\nGitHub Pages의 SPA 라우팅 특성상, 직접 URL 접근 시 404가 발생할 수 있습니다. 새로고침하거나 홈페이지에서 네비게이션을 통해 접근해 보세요.\n문서가 목록에 표시되지 않습니다\n프론트매터의 가 인지 확인하세요\n파일 확장자가 인지 확인하세요\nGitHub Actions 배포가 완료되었는지 확인하세요 (약 2-3분 소요)\nAI가 문서를 생성하지 않습니다\n이슈에  라벨이 추가되었는지 확인하세요\nGitHub Actions 워크플로우가 활성화되어 있는지 확인하세요\n워크플로우 실행 로그에서 오류를 확인하세요\n기여\n프로젝트에 기여하려면 어떻게 하나요?\n이슈를 통해 기능 제안 또는 버그 리포트\n라벨로 문서 작성 요청\nPR을 통한 직접 코드 기여\n코드 스타일 가이드가 있나요?\nESLint + Prettier 설정을 준수합니다\nTypeScript strict 모드를 사용합니다\n커밋 전  검사를 통과해야 합니다",
    "excerpt": "FAQ\nSEPilot Wiki 사용에 관한 자주 묻는 질문과 답변입니다.\n일반\nSEPilot Wiki란 무엇인가요?\nSEPilot Wiki는 AI 에이전트 기반의 자동화된 위키 시스템입니다. GitHub 저장소의  폴더를 데이터 저장소로 활용하고, GitHub Issues를 통해 사용자와 소통하며, AI가 문서를 자동으로 생성/수정/유지보수합니다.\n어떤 기...",
    "tags": [
      "FAQ",
      "가이드",
      "도움말"
    ]
  },
  {
    "title": "Diagrams Guide",
    "slug": "guide/diagrams-guide",
    "content": "Diagrams Guide\nThis document is a placeholder for the Diagrams Guide. Include guidelines on diagram tools, file formats, and best practices for visual documentation.",
    "excerpt": "Diagrams Guide\nThis document is a placeholder for the Diagrams Guide. Include guidelines on diagram tools, file formats, and best practices for visual documentation.",
    "tags": [
      "diagrams",
      "visuals",
      "documentation"
    ]
  },
  {
    "title": "LLM Workflow",
    "slug": "guide/llm-workflow",
    "content": "LLM Workflow\nThis document is a placeholder for the LLM Workflow guide. Provide step‑by‑step instructions, architecture diagrams, and usage examples here.",
    "excerpt": "LLM Workflow\nThis document is a placeholder for the LLM Workflow guide. Provide step‑by‑step instructions, architecture diagrams, and usage examples here.",
    "tags": [
      "LLM",
      "workflow",
      "integration"
    ]
  },
  {
    "title": "다이어그램 및 차트 사용 가이드",
    "slug": "guide/diagrams",
    "content": "다이어그램 및 차트 사용 가이드\nSEPilot Wiki는 복잡한 아이디어와 데이터를 시각화하기 위해 Mermaid와 Plotly를 지원합니다.\n마크다운 코드 블록을 사용하여 간편하게 다이어그램과 차트를 그릴 수 있습니다.\nMermaid 다이어그램\n 언어로 코드 블록을 작성하면 자동으로 다이어그램으로 렌더링됩니다.\n플로우차트 (Flowchart)\nmermaid\ngraph TD;\n    Start-->Stop;\n    Start-->Progress;\n    Progress-->Stop;\n클래스 다이어그램 (Class Diagram)\nmermaid\nclassDiagram\n    Animal < -- Duck\n    Animal < -- Fish\n    Animal < -- Zebra\n    Animal : +int age\n    Animal : +String gender\n    Animal: +isMammal()\n    Animal: +mate()\n    class Duck{\n        +String beakColor\n        +swim()\n        +quack()\n    }\n    class Fish{\n        -int sizeInFeet\n        -canEat()\n    }\n    class Zebra{\n        +bool is_wild\n        +run()\n    }\nplotlymarkdown\n`\n문법 강조 (Syntax Highlighting)\n다양한 프로그래밍 언어의 문법 강조를 지원합니다.",
    "excerpt": "다이어그램 및 차트 사용 가이드\nSEPilot Wiki는 복잡한 아이디어와 데이터를 시각화하기 위해 Mermaid와 Plotly를 지원합니다.\n마크다운 코드 블록을 사용하여 간편하게 다이어그램과 차트를 그릴 수 있습니다.\nMermaid 다이어그램\n 언어로 코드 블록을 작성하면 자동으로 다이어그램으로 렌더링됩니다.\n플로우차트 (Flowchart)\nmermai...",
    "tags": [
      "mermaid",
      "plotly",
      "차트",
      "다이어그램",
      "사용법"
    ]
  },
  {
    "title": "Configuration Guide",
    "slug": "guide/configuration-guide",
    "content": "Configuration Guide\nThis document is a placeholder for the Configuration Guide. Include configuration options, environment variables, and best practices here.",
    "excerpt": "Configuration Guide\nThis document is a placeholder for the Configuration Guide. Include configuration options, environment variables, and best practices here.",
    "tags": [
      "configuration",
      "settings",
      "customization"
    ]
  }
]