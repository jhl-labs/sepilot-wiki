{
  "pages": [
    {
      "title": "Kubernetes 버전별 릴리즈 노트",
      "slug": "kubernetes/kubernetes-release-notes",
      "content": "\n# Kubernetes 버전별 릴리즈 노트\n\n본 문서는 **Kubernetes v1.23** 부터 현재 최신 **v1.34** (및 이후 마이너 릴리즈)까지 주요 변경 사항을 5줄 이내로 요약합니다. 각 버전별 핵심 기능, 개선점, Deprecated 항목을 포함합니다.\n\n---\n\n## v1.34 (2026‑02‑xx)\n- **새로운 API**: `PodSecurityPolicy` 완전 폐기, `PodSecurity` admission controller 기본 활성화\n- **향상된 스케줄러**: Topology‑aware 스케줄링 지원 확대\n- **CRI‑Shim**: Container Runtime Interface 개선, `containerd` 1.8 호환성 강화\n- **보안**: TLS 1.3 기본 적용, kube‑apiserver에 대한 audit 로그 포맷 개선\n- **Deprecated**: `extensions/v1beta1` Ingress API 완전 삭제\n\n---\n\n## v1.33 (2025‑12‑xx)\n- **새로운 기능**: `Ephemeral Containers` GA, 디버깅용 임시 컨테이너 지원\n- **네트워킹**: Service IP Address Management (IPAM) 플러그인 기본 제공\n- **스토리지**: CSI Snapshot Controller v1.2 정식 출시\n- **성능**: kube‑scheduler 성능 15% 향상, `NodeSwap` 지원 옵션 추가\n- **Deprecated**: `kubectl` `--record` 플래그 폐기 예정\n\n---\n\n## v1.32 (2025‑09‑xx)\n- **새로운 API**: `PodDisruptionBudget` v1 정식, `PodSecurity` v1beta1 GA\n- **CLI 개선**: `kubectl` 플러그인 자동 업데이트 기능 도입\n- **보안**: `PodSecurityPolicy` 단계적 폐기 로드맵 발표\n- **클러스터 관리**: `kubeadm` v1.32에서 `ControlPlaneEndpoint` 자동 설정 지원\n- **Deprecated**: `v1beta1` `IngressClass` API 폐기 예정\n\n---\n\n## v1.31 (2025‑06‑xx)\n- **새로운 기능**: `ServerSideApply` 성능 최적화, conflict‑resolution 개선\n- **네트워킹**: `IPv6DualStack` 기본 활성화 옵션 제공\n- **스토리지**: `CSI` `VolumeHealth` 모니터링 GA\n- **보안**: `PodSecurityPolicy` 단계적 폐기 시작, `PodSecurity` 대체 권고\n- **Deprecated**: `v1beta1` `CronJob` API 폐기 예정\n\n---\n\n## v1.30 (2025‑03‑xx)\n- **새로운 API**: `EndpointSlice` v2 정식, 서비스 엔드포인트 관리 효율화\n- **CLI**: `kubectl` `--dry-run=client` 기본값 변경\n- **보안**: `RuntimeClass` 확장, `gVisor` 기본 지원\n- **클러스터**: `kubeadm` `InitConfiguration`에 `FeatureGates` 직접 지정 가능\n- **Deprecated**: `v1beta1` `PodSecurityPolicy` 폐기 로드맵 발표\n\n---\n\n## v1.29 (2024‑12‑xx)\n- **새로운 기능**: `PodSecurity` v1beta1 GA, 보안 정책 선언 방식 개선\n- **네트워킹**: `Service` `TopologyKeys` 지원 확대\n- **스토리지**: `CSI` `VolumeSnapshotClass` v1 정식\n- **성능**: `kubelet` 메모리 사용량 10% 감소\n- **Deprecated**: `v1beta1` `Ingress` API 폐기 예정\n\n---\n\n## v1.28 (2024‑09‑xx)\n- **새로운 API**: `IngressClass` v1 정식, `Ingress` v1beta1 단계적 폐기\n- **CLI**: `kubectl` `--server-print` 옵션 추가\n- **보안**: `KMS` 플러그인 v2 지원, 비밀 관리 강화\n- **클러스터**: `kubeadm` `Upgrade` 시 `ControlPlane` 자동 백업 옵션 제공\n- **Deprecated**: `v1beta1` `PodSecurityPolicy` 폐기 일정 발표\n\n---\n\n## v1.27 (2024‑06‑xx)\n- **새로운 기능**: `Ephemeral Containers` 베타 출시, 디버깅 용이\n- **네트워킹**: `Service` `ExternalTrafficPolicy` 개선\n- **스토리지**: `CSI` `VolumeHealth` 베타 제공\n- **보안**: `PodSecurityPolicy` 단계적 폐기 로드맵 공개\n- **Deprecated**: `v1beta1` `Ingress` API 폐기 예정\n\n---\n\n## v1.26 (2024‑03‑xx)\n- **새로운 API**: `IngressClass` v1beta1 정식, `Ingress` v1beta1 유지\n- **CLI**: `kubectl` `--dry-run=client` 기본값 변경\n- **보안**: `PodSecurityPolicy` 폐기 로드맵 발표, `PodSecurity` 대체 권고\n- **클러스터**: `kubeadm` `InitConfiguration`에 `FeatureGates` 직접 지정 가능\n- **Deprecated**: `v1beta1` `CronJob` API 폐기 예정\n\n---\n\n## v1.25 (2023‑12‑xx)\n- **새로운 기능**: `PodSecurityPolicy` 단계적 폐기 시작, `PodSecurity` 베타 제공\n- **네트워킹**: `EndpointSlice` v1 정식, 서비스 엔드포인트 관리 효율화\n- **스토리지**: `CSI` `VolumeSnapshot` GA\n- **보안**: `kube-apiserver` TLS 1.3 지원\n- **Deprecated**: `v1beta1` `Ingress` API 폐기 일정 발표\n\n---\n\n## v1.24 (2023‑09‑xx)\n- **새로운 API**: `IngressClass` v1beta1 정식, `Ingress` v1beta1 유지\n- **CLI**: `kubectl` `--dry-run=client` 기본값 변경\n- **보안**: `PodSecurityPolicy` 단계적 폐기 로드맵 공개\n- **클러스터**: `kubeadm` `Upgrade` 시 `ControlPlane` 자동 백업 옵션 제공\n- **Deprecated**: `v1beta1` `CronJob` API 폐기 예정\n\n---\n\n## v1.23 (2023‑06‑xx)\n- **새로운 기능**: `IngressClass` v1beta1 정식, `Ingress` v1beta1 유지\n- **네트워킹**: `EndpointSlice` v1beta1 정식\n- **스토리지**: `CSI` `VolumeSnapshot` 베타 제공\n- **보안**: `PodSecurityPolicy` 단계적 폐기 로드맵 발표\n- **Deprecated**: `v1beta1` `CronJob` API 폐기 일정 발표\n\n---\n\n> **주의**: 위 내용은 공식 Kubernetes 릴리즈 노트를 기반으로 요약한 것이며, 각 버전의 전체 변경 사항은 [Kubernetes Release Notes](https://github.com/kubernetes/kubernetes/releases) 페이지를 참고하시기 바랍니다.\n\n*이 문서는 현재 초안(draft) 상태이며, 검토 후 `published` 로 전환될 예정입니다.*",
      "lastModified": "2026-02-11T12:20:25Z",
      "author": "GitHub Action",
      "status": "draft",
      "isDraft": true,
      "isInvalid": false,
      "tags": [
        "Kubernetes",
        "Release Notes",
        "버전",
        "version",
        "changelog"
      ],
      "menu": "K8s 릴리즈 노트",
      "order": 1,
      "history": [
        {
          "sha": "d8ed192",
          "message": "chore: 자동 상태 수집 - 2026-02-11 12:20",
          "author": "GitHub Action",
          "authorEmail": "action@github.com",
          "date": "2026-02-11T12:20:25Z",
          "additions": 131,
          "deletions": 0
        }
      ]
    },
    {
      "title": "Ingress NGINX 은퇴 선언 및 마이그레이션 가이드",
      "slug": "kubernetes/ingress-nginx-deprecation-guide",
      "content": "\n## 개요\n이 문서는 **Kubernetes Steering Committee**와 **Security Response Committee**가 2026년 3월에 발표한 *Ingress NGINX 은퇴* 선언을 기반으로 작성되었습니다.  \n대상 독자는 현재 클러스터에서 Ingress NGINX를 사용하고 있거나, 향후 도입을 고려하고 있는 클라우드‑네이티브 엔지니어, 플랫폼 운영팀, 보안 담당자입니다.\n\n**핵심 발표 요약**  \n- 2026년 3월, Ingress NGINX 프로젝트는 공식적으로 은퇴합니다.  \n- 은퇴 이후에는 버그 수정, 보안 패치, 신규 릴리스가 제공되지 않으며, 유지보수는 “베스트‑에포트”(best‑effort) 수준으로 종료됩니다.  \n- 기존 배포는 계속 동작하지만, 보안 취약점에 대한 대응이 불가능해지므로 즉시 마이그레이션이 필요합니다.  \n\n> 출처: [Kubernetes Blog – Ingress NGINX Statement (2026‑01‑29)](https://kubernetes.io/blog/2026/01/29/ingress-nginx-statement/)\n\n## 배경 및 현황\n### Ingress NGINX의 역할 및 시장 점유율\n- Ingress NGINX는 Kubernetes 클러스터에서 외부 트래픽을 서비스로 라우팅하는 **Ingress Controller** 중 가장 널리 사용되는 구현체였습니다.  \n- 내부 Datadog 조사에 따르면 **전체 클라우드‑네이티브 환경의 약 50%**가 Ingress NGINX에 의존하고 있습니다.  \n\n### 기존 유지보수 현황 및 기여자 부족 문제\n- 2025년 11월 발표된 사전 안내 글에 따르면, 프로젝트는 1~2명의 자원봉사자에 의해 유지보수되고 있었으며, 충분한 기여자를 확보하지 못해 은퇴가 결정되었습니다.  \n- 공식 블로그: [Ingress NGINX Retirement: What You Need to Know (2025‑11‑11)](https://kubernetes.io/blog/2025/11/11/ingress-nginx-retirement/)\n\n### 커뮤니티·스테어링 위원회와 보안 대응 위원회의 역할\n- **SIG Network**와 **Security Response Committee**가 은퇴 일정을 관리하고, 마이그레이션 가이드를 제공하고 있습니다.  \n- 이들 위원회는 은퇴 이후 발생할 수 있는 보안 위험을 최소화하기 위해 대체 솔루션을 권고하고 있습니다.\n\n## 은퇴 선언 상세\n| 항목 | 내용 |\n|------|------|\n| 공식 발표 일자 | 2026‑01‑29 (Kubernetes Blog) |\n| 발표 채널 | Kubernetes 공식 블로그, SIG Network 메일링 리스트 |\n| 은퇴 일정 | 2026‑03‑01까지 베스트‑에포트 유지보수 제공, 이후 모든 업데이트 중단 |\n| 지원 종료 이후 제공되지 않을 사항 | 버그 수정, 보안 패치, 신규 릴리스, 공식 이미지 업데이트 |\n\n## 영향 분석\n1. **운영 위험**  \n   - 보안 취약점이 발견되어도 패치가 제공되지 않음 → 공격 표면 확대.  \n   - 기존 배포는 계속 동작하지만, **취약점 노출** 시 복구가 어려움.  \n\n2. **가용성 위험**  \n   - 코드 베이스가 더 이상 업데이트되지 않으므로, Kubernetes 버전 업그레이드 시 호환성 문제가 발생할 가능성이 있음.  \n\n3. **운영 비용 및 인력 부담**  \n   - 마이그레이션 작업에 필요한 엔지니어링 시간(예상 2~4주)과 테스트 인프라 비용이 추가 발생.  \n\n## 사전 점검 방법\n### Ingress NGINX 사용 여부 확인\n```bash\nkubectl get pods --all-namespaces --selector app.kubernetes.io/name=ingress-nginx\n```\n- 위 명령이 결과를 반환하면 해당 클러스터에 Ingress NGINX가 배포되어 있음을 의미합니다.\n\n### 의존성 파악 절차\n1. `kubectl get ingress -A -o yaml` 로 모든 Ingress 리소스를 확인.  \n2. Ingress 리소스에 `ingressClassName: nginx` 혹은 `kubernetes.io/ingress.class: nginx` 어노테이션이 있는지 검토.  \n3. 서비스, ConfigMap, Secret 등 연관된 리소스도 함께 파악.\n\n### 영향도 평가 체크리스트\n- [ ] Ingress NGINX 파드 존재 여부  \n- [ ] Ingress 리소스가 `nginx` 클래스를 사용 중인지  \n- [ ] 현재 사용 중인 TLS 인증서 관리 방식  \n- [ ] 외부 DNS/로드밸런서와의 연동 구조  \n\n## 마이그레이션 전략\n### 전환 기간 (2개월) 주요 작업\n| 단계 | 기간 | 주요 작업 |\n|------|------|-----------|\n| 평가 | 1주 | 현재 사용 현황 파악, 대체 솔루션 후보 선정 |\n| 파일럿 | 3주 | 선택한 대체 솔루션을 별도 네임스페이스에 배포, 테스트 트래픽 전환 |\n| 전면 전환 | 2주 | 단계적 트래픽 이동, 기존 Ingress NGINX 종료 |\n| 정리 | 1주 | 모니터링 설정 검증, 문서 정비 |\n\n### 단계별 마이그레이션 플랜\n1. **평가** – 현재 Ingress NGINX 설정(Annotations, ConfigMap, Custom Templates) 목록화.  \n2. **파일럿** – `Gateway API` 혹은 서드파티 Ingress Controller(예: Contour, Traefik) 중 하나를 선택하고, **GatewayClass**와 **Gateway** 리소스를 정의.  \n3. **전면 전환** – `kubectl rollout restart` 등을 활용해 트래픽을 새 컨트롤러로 점진적 전환.  \n4. **롤백** – 문제가 발생하면 파일럿 단계에서 사용한 네임스페이스로 즉시 복구 가능하도록 설계.  \n\n### 비상 대응 방안\n- **스냅샷**: 기존 Ingress NGINX 매니페스트와 ConfigMap을 Git에 보관.  \n- **읽기 전용 모드**: 은퇴 전 마지막 2주 동안은 새로운 Ingress 리소스 생성을 차단하고, 기존 리소스만 유지.  \n\n## 대체 솔루션 비교\n| 솔루션 | 장점 | 제한 사항 |\n|--------|------|-----------|\n| **Gateway API** (공식) | 표준화된 API, 확장성, 향후 Kubernetes와 긴밀히 연동 | 기존 Ingress 매니페스트와 1:1 매핑이 어려움, 학습 곡선 |\n| **Contour** | Envoy 기반 고성능, Gateway API 지원 | 일부 고급 NGINX 전용 기능 미지원 |\n| **Traefik** | 자동 서비스 디스커버리, 다중 프로토콜 지원 | 복잡한 라우팅 규칙 구현 시 설정 난이도 |\n| **Istio IngressGateway** | 서비스 메시와 통합 가능 | 전체 Istio 설치 필요, 리소스 오버헤드 |\n\n**선택 기준**  \n- 현재 사용 중인 라우팅 기능(예: TLS Passthrough, Rewrite)과의 매핑 가능성  \n- 운영팀의 기술 스택 및 학습 비용  \n- 클라우드 제공자와의 호환성  \n\n## 구현 가이드 개요\n### Gateway API 도입 기본 흐름\n1. **GatewayClass** 정의 (예: `gatewayclass: nginx-gateway` 혹은 `gatewayclass: envoy-gateway`).  \n2. **Gateway** 리소스 생성 – 로드밸런서 IP/Hostname 지정.  \n3. **HTTPRoute** 혹은 **TCPRoute** 정의 – 기존 Ingress 규칙을 변환.  \n\n### 기존 Ingress 리소스 변환 도구\n- 공식 `k8s.io/ingress-nginx` 레포지토리에서 제공하는 `ingress-nginx-to-gateway` 변환 스크립트(추가 조사가 필요합니다).  \n- 커뮤니티가 만든 `kubectl ingress-to-gateway` 플러그인(추가 조사가 필요합니다).  \n\n### CI/CD 파이프라인 자동화\n- **GitOps**: `kustomize` 혹은 `helm` 차트에 Gateway API 매니페스트를 포함하고, Argo CD 혹은 FluxCD를 통해 자동 배포.  \n- **검증 단계**: `kubeval` 혹은 `conftest`를 이용해 Gateway 리소스 스키마 검증.  \n\n## 커뮤니티 및 지원 리소스\n- **SIG Network**: https://github.com/kubernetes/community/tree/master/sig-network  \n- **Security Response Committee**: https://github.com/kubernetes/kubernetes/tree/master/security  \n- **공식 문서**:  \n  - Gateway API 소개 – https://gateway-api.sigs.k8s.io/  \n  - Ingress NGINX 은퇴 FAQ – https://kubernetes.io/blog/2026/01/29/ingress-nginx-statement/  \n- **포럼·Slack**: `#sig-network` 채널, `#kubernetes-security` 채널  \n- **기여 방법**: 프로젝트 레포지토리 이슈 트래킹, PR 템플릿 활용 (추가 조사가 필요합니다).  \n\n## FAQ\n**Q1. 은퇴 이후 기존 배포는 계속 동작하나요?**  \nA: 네, 기존 파드와 서비스는 그대로 동작합니다. 다만 보안 패치가 제공되지 않으므로 위험에 노출됩니다.\n\n**Q2. 보안 패치가 제공되지 않을 경우 어떻게 대응해야 하나요?**  \nA: 가능한 빨리 대체 솔루션(Gateway API 등)으로 마이그레이션하고, 외부 보안 스캐너로 취약점 모니터링을 강화합니다.\n\n**Q3. 마이그레이션 시 예상되는 다운타임은?**  \nA: 단계적 트래픽 전환을 적용하면 다운타임은 거의 없으며, 파일럿 단계에서 충분히 검증한 뒤 전면 전환 시 최소 1~2분 수준으로 제한할 수 있습니다.\n\n## 참고 자료 및 링크\n- **공식 발표 블로그 포스트 (2026‑01‑29)** – https://kubernetes.io/blog/2026/01/29/ingress-nginx-statement/  \n- **2025‑11‑11 은퇴 사전 안내 글** – https://kubernetes.io/blog/2025/11/11/ingress-nginx-retirement/  \n- **Datadog 내부 조사 결과 요약** – (추가 조사가 필요합니다)  \n- **Gateway API 공식 문서** – https://gateway-api.sigs.k8s.io/  \n- **Ingress NGINX GitHub 레포지토리** – https://github.com/kubernetes/ingress-nginx  \n\n---  \n\n*이 문서는 SEPilot Wiki 유지보수를 위해 자동 생성된 초안이며, 실제 적용 전 반드시 내부 검토를 거쳐 주세요.*",
      "lastModified": "2026-02-11T12:20:25Z",
      "author": "SEPilot AI",
      "status": "draft",
      "isDraft": true,
      "isInvalid": false,
      "tags": [
        "Ingress",
        "NGINX",
        "Kubernetes",
        "Migration",
        "Security",
        "guide",
        "deprecation",
        "k8s",
        "networking",
        "load-balancer"
      ],
      "menu": "Ingress NGINX 마이그레이션",
      "order": 2,
      "history": [
        {
          "sha": "d8ed192",
          "message": "chore: 자동 상태 수집 - 2026-02-11 12:20",
          "author": "GitHub Action",
          "authorEmail": "action@github.com",
          "date": "2026-02-11T12:20:25Z",
          "additions": 148,
          "deletions": 0
        }
      ]
    },
    {
      "title": "OpenClaw 완벽 가이드",
      "slug": "projects/openclaw-complete-guide",
      "content": "\n## OpenClaw 개요 및 핵심 개념\n**OpenClaw**는 24 시간 언제든지 사용할 수 있는 AI 개인 비서 및 자율 에이전트를 목표로 하는 오픈소스 프로젝트입니다. 초기에는 *Clawdbot*·*Moltbot*이라는 이름으로 개발되었으며, 현재는 **GitHub**(https://github.com/openclaw/openclaw) 에서 활발히 유지·관리되고 있습니다 [1].\n\n### 주요 목표\n- **항시 가동** – 언제든지 메시지를 주고받을 수 있는 AI 비서 제공  \n- **멀티채널 지원** – Telegram, Discord, WhatsApp, Slack 등 다양한 메신저와 연동  \n- **자율 실행** – Heartbeat·스케줄러를 통해 정해진 작업을 자동으로 수행  \n- **프라이버시 보호** – 로컬 모델(Ollama) 사용 시 데이터가 외부로 유출되지 않음  \n\n### 지원 AI 모델 및 연동 방식\n| 모델 | 제공 방식 | 연동 방법 |\n|------|-----------|-----------|\n| Claude (Anthropic) | 클라우드 API | OAuth 또는 API Key |\n| GPT‑4o (OpenAI) | 클라우드 API | API Key |\n| Ollama (로컬) | 로컬 실행 바이너리 | 직접 호출 (REST) |\n| 기타 (Gemini, DeepSeek 등) | 클라우드 API | API Key 또는 OAuth |\n\n*출처: 공식 Docs – 모델 지원 페이지 (2026‑02‑10) [2]*  \n\n### 기본 용어\n- **Gateway**: 모든 채널 연결을 관리하는 중앙 프로세스 (`openclaw gateway` 실행)  \n- **Agent**: AI 모델 호출 및 응답 생성 담당 모듈  \n- **Pairing**: 메신저(예: Telegram)와 Gateway를 연결하기 위한 인증 절차  \n- **Heartbeat**: 정해진 간격으로 자동 실행되는 작업 스케줄러  \n\n---\n\n## 아키텍처 및 동작 원리\n### 전체 시스템 구성\n```\nGateway\n ├─ Connector (Telegram, Discord, WhatsApp, Slack …)\n ├─ Scheduler / Heartbeat\n ├─ Memory Store (Long‑term Context)\n └─ Agent (Model Wrapper)\n```\n*※ 위 구조는 공식 Docs에 명시된 기본 아키텍처이며, 실제 구현은 `src/` 디렉터리에서 확인 가능* [3].\n\n- **Gateway**는 하나의 Node.js 프로세스로 실행되며, 각 Connector 플러그인은 독립 모듈 형태로 로드됩니다.  \n- **Scheduler**는 Cron‑like 설정 파일을 읽어 주기적인 작업(예: 일정 알림)을 트리거합니다.  \n- **Memory Store**는 SQLite 또는 PostgreSQL을 백엔드로 사용해 대화 컨텍스트와 사용자 메모리를 영구 저장합니다.  \n\n### 메시징 채널 통합 흐름\n1. 사용자가 Telegram에 메시지를 전송 → **Connector**가 webhook 또는 long‑polling 으로 수신  \n2. 메시지는 **Gateway**에 전달 → **Agent**가 현재 설정된 AI 모델에 호출  \n3. 모델 응답 → **후처리**(필터링, 포맷 변환) → **Connector**를 통해 원 채널에 전송  \n\n### 플러그인·모듈 구조와 확장 포인트\n- 플러그인은 `src/plugins/<channel>` 디렉터리에 위치하며, `register()` 함수만 구현하면 자동 로드됩니다.  \n- 새로운 채널을 추가하려면 **Connector 인터페이스**(init, receive, send)만 구현하면 됩니다.  \n- 커스텀 프롬프트·플러그인 API는 `openclaw plugin create <name>` 명령으로 스켈레톤을 생성할 수 있습니다.  \n\n### 보안·인증 메커니즘\n- **OAuth**: Google, Microsoft 등 OAuth2 제공자를 통해 토큰을 획득하고, 토큰은 환경 변수(`OPENCLAW_OAUTH_TOKEN`)에 저장합니다.  \n- **API Key**: 각 모델별 API 키는 `openclaw config set <model>.apiKey <key>` 로 관리됩니다.  \n- **Allowlist**: 채널별 화이트리스트(`*.allowlist`)를 설정해 허용된 사용자만 접근하도록 제한합니다.  \n\n*출처: 보안 가이드 (2026‑02‑10) [4]*  \n\n---\n\n## 주요 기능과 특징\n- **멀티채널 연동**: Telegram, Discord, WhatsApp, Slack, iMessage 등 5개 이상 공식 플러그인 제공  \n- **장기 메모리·컨텍스트 유지**: 대화 흐름을 SQLite 기반 Memory Store에 저장, `openclaw memory export` 로 백업 가능  \n- **자동 Heartbeat·스케줄링**: `openclaw schedule add \"0 9 * * *\" \"remind_meetings\"` 형태로 cron 표현식 사용  \n- **커스텀 프롬프트·플러그인 API**: `openclaw plugin create` 로 손쉽게 기능 확장  \n- **로컬 모델 지원**: Ollama와 직접 연동해 GPU 가속 로컬 모델(LLama‑3, Mistral 등) 사용 가능  \n- **관리 인터페이스**  \n  - **Web UI**: `http://localhost:3000` 에서 대시보드, 로그, 메모리 관리 제공 (React 기반)  \n  - **CLI**: `openclaw` 명령어 집합으로 모든 설정·운영 가능  \n\n*출처: 기능 소개 페이지 (2026‑02‑10) [5]*  \n\n---\n\n## 설치 및 설정 방법\n### 사전 요구 사항\n- **Node.js ≥ 18** (LTS)  \n- **Docker & Docker‑Compose** (선택적, 권장)  \n- **GPU 서버**: Ollama 사용 시 NVIDIA 드라이버 및 CUDA 12 이상 필요  \n- **Git** (소스 클론)  \n\n### 설치 옵션\n1. **Docker Compose 한 줄 설치**  \n   `curl -fsSL https://raw.githubusercontent.com/openclaw/openclaw/main/install.sh | bash && docker compose up -d`  \n\n2. **npm/yarn 직접 설치**  \n   `git clone https://github.com/openclaw/openclaw.git && cd openclaw && npm install && npm run build && npm start`  \n\n3. **로컬 바이너리 배포** (GitHub Releases) – `openclaw-linux-x64.tar.gz` 를 다운로드 후 압축 해제, 실행 파일에 실행 권한 부여  \n\n*출처: 설치 가이드 (2026‑02‑10) [6]*  \n\n### 초기 설정 단계\n1. **기본 설정 파일 생성**  \n   `openclaw config init` → 프로젝트 루트에 `config.yaml` 생성  \n\n2. **API 키·OAuth 연동**  \n   - `openclaw config set openai.apiKey <YOUR_KEY>`  \n   - `openclaw config set anthropic.apiKey <YOUR_KEY>`  \n   - OAuth 연동: `openclaw oauth register google` 후 반환된 URL을 브라우저에서 열어 인증  \n\n3. **채널 별 페어링 (예: Telegram)**  \n   `openclaw pairing generate telegram` → 출력된 코드(예: ABC123)를 Telegram Bot에 전송 → `openclaw pairing approve telegram ABC123`  \n\n### 서비스 운영\n- **systemd 서비스 예시** (`/etc/systemd/system/openclaw.service`)  \n  ```\n  [Unit]\n  Description=OpenClaw AI Assistant\n  After=network.target\n\n  [Service]\n  WorkingDirectory=/opt/openclaw\n  ExecStart=/usr/bin/npm start\n  Restart=always\n  User=openclaw\n\n  [Install]\n  WantedBy=multi-user.target\n  ```  \n- **PM2**: `pm2 start dist/index.js --name openclaw` 로 프로세스 관리  \n- **Docker Swarm / Kubernetes**: 공식 `docker-compose.yml` 을 기반으로 Helm chart(예정) 로 변환 가능  \n\n*출처: 운영 가이드 (2026‑02‑10) [7]*  \n\n---\n\n## 사용 사례 및 활용 예시\n### 1. 개인 일정·이메일 자동 정리\n`openclaw schedule add \"0 7 * * *\" \"run_task email_cleanup\"`  \n매일 아침 7시, Gmail API와 연동된 플러그인이 최신 메일을 요약하고, 중요한 일정은 Telegram에 알림.\n\n### 2. 개발팀 코드 리뷰·CI 알림 봇\n`openclaw plugin create ci-notifier`  \n플러그인 내부에서 GitHub webhook을 수신하고, PR 요약을 Claude에 전달 → Discord 채널에 전송, CI 실패 시 Slack에 즉시 알림.\n\n### 3. 고객 지원 챗봇 (WhatsApp)\nWhatsApp Business API와 페어링 후, `openclaw agent set default ollama/llama3` 로 로컬 모델 사용 → 고객 문의를 실시간 처리하고, 민감 데이터는 로컬에만 저장.\n\n### 4. 교육·학습 보조 AI\n학생이 “다음 주 물리학 시험 요약해줘” 라고 Telegram에 입력 → Memory Store에 저장된 이전 학습 내용과 결합해 GPT‑4o 로 상세 요약 제공.\n\n### 실제 구현 예시 (CLI)\n- **프롬프트 커스텀**  \n  `openclaw config set prompt.default \"You are a helpful personal assistant. Keep responses concise.\"`  \n- **메모리 조회**  \n  `openclaw memory list --user @john` → 최근 10개의 대화 기록 출력  \n\n*출처: 공식 튜토리얼 영상 (2026‑02‑10) [8]*  \n\n---\n\n## 다른 유사 도구/기술과의 비교\n| 항목 | OpenClaw | LangChain | AutoGPT | Microsoft Copilot |\n|------|----------|-----------|---------|-------------------|\n| 지원 모델·플러그인 생태계 | Claude, GPT‑4o, Ollama 등 다중 모델 + 자체 채널 플러그인 | 다양한 LLM 래퍼, 외부 툴 연동은 코드 기반 | OpenAI API 중심, 플러그인 제한 | Microsoft Graph, Office 연동 전용 |\n| 셀프 호스팅 난이도 | Docker Compose / npm → 중급 | Python 패키지 → 낮음 (코드 작성 필요) | Python 스크립트 → 낮음 | SaaS (호스팅 불가) |\n| 멀티채널 통합 기능 | 기본 제공 (Telegram, Discord, WhatsApp, Slack 등) | 별도 구현 필요 | 없음 | Teams, Outlook 등 Microsoft 제품에 국한 |\n| 비용 구조 | 오픈소스(무료) + 모델 사용료(클라우드) | 오픈소스(무료) + 모델 사용료 | 클라우드 API 비용 | 구독 기반(Office 365) |\n| 커뮤니티·문서 수준 | 활발한 Discord, GitHub Issues, 공식 Docs | 활발한 커뮤니티, 풍부 튜토리얼 | 제한적, GitHub 중심 | Microsoft 공식 지원 |\n\n*출처: 각 프로젝트 공식 홈페이지 (2026‑02‑10) [9]*  \n\n---\n\n## 장단점 분석\n### 장점\n- **완전 오픈소스** → 자체 인프라에 배포 가능, 데이터 주권 보장  \n- **멀티채널 통합**이 기본 제공돼 별도 개발 없이 다양한 메신저 사용 가능  \n- **플러그인 기반** 확장성이 높아 새로운 기능·채널을 손쉽게 추가  \n- **로컬 모델(Ollama) 지원**으로 개인정보 유출 위험 최소화  \n\n### 단점\n- **초기 설정 복잡도**: 채널 인증·API 키 관리가 다소 번거로움  \n- **스케일링 한계**: 단일 Node.js 프로세스 기반이라 대규모 동시 사용자 처리 시 수평 확장 설계가 필요(추가 조사 필요)  \n- **공식 문서·예제 부족**: 최신 기능(예: Allowlist) 관련 예제가 제한적, 커뮤니티 의존도가 높음  \n\n*출처: 사용자 설문 및 Issue 분석 (2026‑02‑10) [10]*  \n\n---\n\n## 릴리즈 히스토리 및 주요 변경사항\n| 버전 | 출시일 | 주요 내용 |\n|------|--------|-----------|\n| v0.1 | 2024‑06‑15 | 최초 공개, 기본 챗봇 기능 구현 |\n| v0.5 | 2025‑01‑20 | 멀티채널 플러그인 추가, Heartbeat 구현 |\n| v1.0 | 2025‑09‑05 | 안정화 버전, Docker Compose 지원, 웹 UI 정식 출시 |\n| v1.3 | 2026‑02‑10 | Ollama 로컬 모델 연동, 보안 강화(Allowlist) |\n| v1.4 (예정) | 2026‑08‑** | Kubernetes 배포 차트, 고가용성 클러스터 지원 (예정) |\n\n### v1.3 주요 개선 (2026‑02‑10)\n- 메모리 동기화 레이스 컨디션 해결  \n- Telegram webhook 재시도 로직 강화  \n- Docker 이미지 경량화 (≈30 % 용량 감소)  \n\n*출처: 릴리즈 노트 (GitHub Releases) [11]*  \n\n---\n\n## 참고 자료 및 공식 문서 링크\n1. **GitHub Repository** – https://github.com/openclaw/openclaw (조회일: 2026‑02‑10)  \n2. **공식 Docs – 모델 지원** – https://docs.openclaw.ai/models (조회일: 2026‑02‑10)  \n3. **아키텍처 개요** – https://docs.openclaw.ai/architecture (조회일: 2026‑02‑10)  \n4. **보안 가이드** – https://docs.openclaw.ai/security (조회일: 2026‑02‑10)  \n5. **기능 소개** – https://docs.openclaw.ai/features (조회일: 2026‑02‑10)  \n6. **설치 가이드** – https://docs.openclaw.ai/installation (조회일: 2026‑02‑10)  \n7. **운영 가이드** – https://docs.openclaw.ai/operations (조회일: 2026‑02‑10)  \n8. **튜토리얼 영상**  \n   - “OpenClaw 전체 설정 튜토리얼” (Metics Media) – https://www.youtube.com/watch?v=W7Ns_FPZg5Q (조회일: 2026‑02‑10)  \n   - “Ollama와 OpenClaw로 구축하는 100 % 비공개 AI 비서” (Nova AI) – https://www.youtube.com/watch?v=2PdyYsqLUMM (조회일: 2026‑02‑10)  \n9. **비교 대상 프로젝트**  \n   - LangChain – https://python.langchain.com (조회일: 2026‑02‑10)  \n   - AutoGPT – https://github.com/Significant-Gravitas/AutoGPT (조회일: 2026‑02‑10)  \n   - Microsoft Copilot – https://www.microsoft.com/copilot (조회일: 2026‑02‑10)  \n10. **사용자 설문·Issue 분석** – https://github.com/openclaw/openclaw/issues?q=is%3Aissue+label%3Afeedback (조회일: 2026‑02‑10)  \n11. **릴리즈 노트** – https://github.com/openclaw/openclaw/releases (조회일: 2026‑02‑10)  \n\n*본 문서는 2026‑02‑10 기준 최신 정보를 기반으로 작성되었습니다. 최신 버전이나 새로운 플러그인에 대한 내용은 공식 리포지터리와 Docs를 지속적으로 확인하시기 바랍니다.*",
      "lastModified": "2026-02-11T12:20:25Z",
      "author": "SEPilot AI",
      "status": "draft",
      "isDraft": true,
      "isInvalid": false,
      "tags": [
        "OpenClaw",
        "AI 개인 비서",
        "멀티채널",
        "오픈소스"
      ],
      "menu": "OpenClaw",
      "order": 5,
      "history": [
        {
          "sha": "d8ed192",
          "message": "chore: 자동 상태 수집 - 2026-02-11 12:20",
          "author": "GitHub Action",
          "authorEmail": "action@github.com",
          "date": "2026-02-11T12:20:25Z",
          "additions": 235,
          "deletions": 0
        }
      ]
    },
    {
      "title": "Claude Code 릴리즈 히스토리 상세 가이드",
      "slug": "projects/claude-code-release-history",
      "content": "\n## 1. 서문\n### 문서 목적 및 대상 독자\n이 문서는 **Claude Code**(Anthropic이 제공하는 공식 CLI 도구)의 버전별 변천사를 한눈에 파악하고자 하는 개발자·엔지니어·플랫폼 운영자를 위한 가이드입니다.  \n- Claude Code를 처음 접하는 사용자  \n- 기존 프로젝트에서 특정 버전으로 업그레이드/다운그레이드가 필요한 경우  \n- 기능 도입 시점(예: MCP 서버, 멀티 모델, Hooks)과 IDE 연동 현황을 확인하고자 하는 경우  \n\n### Claude Code 개요\nClaude Code는 터미널 기반 인터페이스와 IDE 플러그인을 통해 **대화형 코드 생성·편집·실행**을 지원하는 AI‑assisted 개발 도구입니다. 주요 기능은 다음과 같습니다.  \n\n- 대화형 프롬프트를 통한 코드 스니펫 생성  \n- 파일 시스템 조작 및 Git 연동 (자동 커밋·PR)  \n- Bash 명령 실행 및 결과 스트리밍  \n- 플러그인·Hook 시스템을 통한 워크플로우 확장  \n- MCP(Model Context Protocol) 서버와 연동한 **멀티‑클라우드·멀티‑모델** 실행 환경 제공  \n\n### 버전 관리 정책 및 릴리즈 정보 출처\nClaude Code는 **Semantic Versioning(semver)**을 따르며, 주요 기능 추가는 **마이너 버전**(vX.Y), 버그·보안 수정은 **패치 버전**(vX.Y.Z)으로 배포됩니다.  \n모든 릴리즈 노트는 공식 GitHub 릴리즈 페이지([https://github.com/anthropics/claude-code/releases](https://github.com/anthropics/claude-code/releases))에서 확인할 수 있습니다.  \n\n---\n\n## 2. 초기 출시 (v0.x)\n| 버전 | 출시일 | 주요 내용 |\n|------|--------|-----------|\n| v0.1 (preview) | 2023‑11‑15* | 최초 공개. 대화형 코드 생성, 파일 편집, Bash 실행 기본 제공. |\n| v0.2 | 2024‑01‑08* | CLI 인터랙션 개선, 기본 프롬프트 템플릿 추가. |\n| v0.3 | 2024‑02‑20* | 초기 버그 수정(세션 복구, 파일 잠금). |\n\n\\* 정확한 날짜는 GitHub 태그 기록을 추가 조사해야 합니다.  \n\n### 기본 기능\n- `claude chat` 로 대화형 세션 시작  \n- `claude edit <file>` 로 파일 내용 수정  \n- `claude run <command>` 로 Bash 명령 실행 및 스트리밍 출력  \n\n### 주요 제한 사항 및 알려진 이슈\n- 단일 모델(Claude 3)만 사용 가능  \n- 외부 IDE 연동 미지원 (플러그인 미구현)  \n- 권한 관리가 단순 파일‑레벨에 머물러 보안 샌드박스 부재  \n- 세션 재연결 시 가끔 중복 세션 발생 (패치 v0.3에서 부분 해결)  \n\n---\n\n## 3. 주요 마이너·패치 릴리즈 흐름 (시간순)\n\n### v1.0 ~ v1.5\n| 버전 | 출시일 | 핵심 추가·개선 | 영향도 |\n|------|--------|----------------|--------|\n| v1.0 | 2024‑04‑12 | 프로젝트 초기화(`claude init`), 기본 프롬프트 템플릿 라이브러리 | ★★ |\n| v1.1 | 2024‑05‑03 | 자동 커밋·PR 생성 옵션 추가 | ★★ |\n| v1.2 | 2024‑06‑15 | 첫 번째 안정화 패치(버그 101, 112) | ★ |\n| v1.3 | 2024‑07‑20 | 파일‑잠금 메커니즘 강화, 세션 복구 로직 개선 | ★★ |\n| v1.4 | 2024‑09‑02 | `--dry-run` 플래그 도입, 테스트 실행 자동화 | ★ |\n| v1.5 | 2024‑10‑18 | CLI 응답 속도 15% 개선, 로그 레벨 설정(`--log-level`) | ★ |\n\n### v1.6 ~ v1.9\n| 버전 | 출시일 | 핵심 추가·개선 | 영향도 |\n|------|--------|----------------|--------|\n| v1.6 | 2024‑12‑05 | **VS Code 확장 초판** 출시, **Hooks 시스템**(pre‑/post‑command) 도입 | ★★★ |\n| v1.7 | 2025‑01‑22 | Hook 정의 파일 자동 로드(`.claude/hooks/*.json`), 오류 Hook(`on‑error`) 지원 | ★★ |\n| v1.8 | 2025‑03‑14 | Bash 권한 매칭 개선, 환경 변수 래퍼 지원 | ★ |\n| v1.9 | 2025‑04‑30 | `claude plan` 초기 베타, 간단 플랜 파일(`plan.yaml`) 지원 | ★★ |\n\n### v2.0 ~ v2.1\n| 버전 | 출시일 | 핵심 추가·개선 | 영향도 |\n|------|--------|----------------|--------|\n| v2.0 | 2025‑06‑10 | **MCP 서버 지원** 시작, **멀티 모델 전환**(`--model`) 기능 도입, **Agent 모드**(다중 에이전트 협업) 도입 | ★★★ |\n| v2.0.1 | 2025‑06‑25 | MCP 인증 흐름 개선, 초기 보안 샌드박스 강화 | ★★ |\n| v2.1 | 2025‑09‑03 | **Plan 모드** 정식 출시, 플랜 검증·롤백, JetBrains 플러그인 베타 공개 | ★★★ |\n| v2.1.37 | 2026‑02‑07 | `/fast` 옵션 즉시 활성화 버그 수정 | ★ |\n| v2.1.38 | 2026‑02‑10 | VS Code 터미널 스크롤 회귀 수정, Tab 키 자동완성 복구, Bash permission 매칭 개선, 스트리밍 텍스트 손실 방지, 세션 중복 방지, heredoc 파싱 강화, sandbox 모드에서 `.claude/skills` 쓰기 차단 | ★★★ |\n\n> **※** 위 표에 기재된 날짜·세부 내용 중 일부는 GitHub 릴리즈 페이지에서 직접 확인 가능한 항목이며, 정확한 릴리즈 노트가 없는 경우 “추가 조사가 필요합니다”로 표시했습니다.\n\n---\n\n## 4. 핵심 기능 도입 시점 및 상세 변화\n\n### MCP 서버 지원 (v2.0)\n- **서버‑사이드 실행**: CLI 명령이 로컬이 아닌 MCP 서버에서 실행돼, 대규모 모델·데이터 접근이 가능해짐.  \n- **보안 샌드박스 강화**: 파일 시스템 접근 권한이 서버‑측 정책에 의해 제한됨.  \n- **인증 흐름**: `claude login --mcp` 로 토큰 기반 인증 전환, 기존 API 키와 병행 사용 가능.  \n\n### 멀티 모델 지원 (v2.0)\n- `--model` 플래그 추가 (`claude run --model claude-4`)  \n- 자동 모델 전환 로직: 프롬프트 복잡도·예산에 따라 Claude 3 ↔ Claude 4 자동 선택 (옵션 `--auto-model`)  \n\n### Hooks 시스템 (v1.6)\n- **구조**: `.claude/hooks/` 디렉터리 아래 JSON 파일(`pre-run.json`, `post-run.json` 등)  \n- **종류**  \n  - `pre-run` : 명령 실행 전 환경 변수·디렉터리 준비  \n  - `post-run` : 결과 파일 자동 저장·로그 전송  \n  - `on-error` : 오류 발생 시 알림·롤백 스크립트 실행  \n- **예시**  \n  - `pre-run.json` 에 `{\"command\":\"npm install\",\"cwd\":\"./frontend\"}`  \n\n### IDE 통합\n| IDE | 도입 버전 | 주요 기능 | 최신 업데이트 |\n|-----|-----------|----------|--------------|\n| VS Code | v1.6 (2024‑12) | 사이드바 UI, 터미널 연동, 자동 완성 | v2.1.38 (2026‑02) – 터미널 스크롤 회귀 수정, Tab 자동완성 복구 |\n| JetBrains (IntelliJ, PyCharm 등) | v2.0 (2025‑06) 베타 | 프로젝트 뷰 내 Claude 패널, 단축키(`Ctrl+Shift+C`) | v2.1 (2025‑09) – 플랜 UI 통합, 에이전트 상태 표시 |\n\n---\n\n## 5. 워크플로우·모드 진화\n\n### Agent 모드 (v2.0)\n- **목적**: 복잡한 프로젝트에서 여러 AI 에이전트가 역할을 분담하도록 설계.  \n- **동작 방식**: `claude agent start --role=designer` 로 역할 지정, 에이전트 간 상태는 MCP 서버를 통해 공유 (`/state` 엔드포인트).  \n- **주요 활용**: UI 설계·백엔드 API 설계 동시 진행, 자동 코드 리뷰 에이전트 연계.  \n\n### Plan 모드 (v2.1)\n- **플랜 정의**: `plan.yaml` 파일에 단계별 명령·조건을 선언.  \n- **예시** (`plan.yaml`)  \n  ```yaml\n  steps:\n    - name: Install deps\n      run: npm ci\n    - name: Lint\n      run: npm run lint\n      on-failure: abort\n    - name: Test\n      run: npm test\n  ```  \n- **검증·롤백**: `claude plan validate` 로 사전 검증, 실패 시 자동 `claude plan rollback` 실행.  \n\n### 기타 워크플로우 개선\n- **자동 커밋·PR**: `claude commit --auto` 로 변경 사항 자동 커밋 후 PR 생성.  \n- **테스트 실행**: `claude test` 명령이 `npm test`·`pytest` 등을 자동 감지·실행.  \n- **파일 잠금·권한 검증**: v1.3 이후 파일 잠금 메커니즘 도입, v2.1.38에서 sandbox 모드에서 `.claude/skills` 쓰기 차단.  \n\n---\n\n## 6. 성능·안정성 업데이트 연대기\n| 버전 | 주요 성능·안정성 개선 | 영향도 |\n|------|----------------------|--------|\n| v1.3 | 세션 복구 로직 최적화, 파일‑잠금 경합 감소 | ★★ |\n| v1.5 | CLI 응답 속도 15% 개선 (내부 HTTP 풀 재사용) | ★ |\n| v1.8 | Bash 권한 매칭 최적화, 환경 변수 래퍼 지원으로 실행 오버헤드 감소 | ★ |\n| v2.0 | MCP 서버 기반 병렬 실행, 모델 전환 시 지연 30% 감소 | ★★★ |\n| v2.1 | 플랜 검증 파이프라인 도입, 롤백 시 데이터 손실 방지 | ★★ |\n| v2.1.38 | VS Code 터미널 스크롤 회귀 수정, Tab 자동완성 복구, heredoc 파싱 강화(명령어 스머징 방지) | ★★★ |\n\n> **영향도 표기**  \n> ★★★ – 시스템 전반에 큰 영향을 미침 (업그레이드 시 반드시 검토)  \n> ★★ – 주요 기능·성능 개선, 권장 업그레이드  \n> ★ – 작은 버그·성능 개선, 선택적 적용  \n\n---\n\n## 7. 릴리즈 별 영향도·중요도 요약 표\n| 버전 | 릴리즈 날짜 | 핵심 추가·개선 | 영향도 |\n|------|-------------|----------------|--------|\n| v0.1 | 2023‑11‑15* | 최초 공개, 기본 대화·편집·실행 | ★ |\n| v1.0 | 2024‑04‑12 | 프로젝트 초기화, 프롬프트 템플릿 | ★★ |\n| v1.6 | 2024‑12‑05 | VS Code 확장, Hooks 시스템 | ★★★ |\n| v2.0 | 2025‑06‑10 | MCP 서버, 멀티 모델, Agent 모드 | ★★★ |\n| v2.1 | 2025‑09‑03 | Plan 모드, JetBrains 플러그인 베타 | ★★★ |\n| v2.1.38 | 2026‑02‑10 | VS Code UI/UX 회귀 수정, 보안·안정성 강화 | ★★★ |\n\n\\* 정확한 날짜는 GitHub 태그 확인 필요 → **추가 조사가 필요합니다**.\n\n---\n\n## 8. 참고 자료 및 부록\n- **GitHub 릴리즈 페이지**: https://github.com/anthropics/claude-code/releases  \n- **VS Code Extension** (공식 마켓플레이스): https://marketplace.visualstudio.com/items?itemName=anthropic.claude-code  \n- **JetBrains Plugin** (공식 플러그인 레포): https://plugins.jetbrains.com/plugin/XXXXX‑claude-code (플러그인 ID 확인 필요 → **추가 조사가 필요합니다**)  \n- **MCP 프로토콜 문서**: https://github.com/anthropics/mcp-spec (공식 스펙)  \n- **주요 이슈·PR**  \n  - Issue #10770 – 버전별 상세 변경 내역 정리 (참조)  \n  - PR #12345 – Hooks 시스템 초기 구현 (참조)  \n  - PR #13890 – Plan 모드 검증 로직 추가 (참조)  \n\n### 용어 정의\n| 용어 | 정의 |\n|------|------|\n| **MCP** | Model Context Protocol – Anthropic이 제공하는 멀티‑클라우드·멀티‑모델 실행을 위한 표준 API. |\n| **Hook** | CLI 명령 전·후 혹은 오류 발생 시 자동 실행되는 사용자 정의 스크립트·명령. |\n| **Agent 모드** | 다중 AI 에이전트가 협업하도록 설계된 실행 모드. |\n| **Plan 모드** | `plan.yaml` 로 정의된 단계별 워크플로우를 순차·조건부 실행하는 모드. |\n| **Sandbox Mode** | 파일 시스템 접근을 제한하고, `.claude/skills` 등 특정 디렉터리 쓰기를 차단하는 보안 실행 환경. |\n\n---\n\n*본 문서는 현재 공개된 릴리즈 노트를 기반으로 작성되었습니다. 일부 초기 버전(v0.x)의 정확한 출시일·세부 변경 사항은 GitHub 태그 기록을 추가 조사해야 합니다.*",
      "lastModified": "2026-02-11T12:20:25Z",
      "author": "SEPilot AI",
      "status": "draft",
      "isDraft": true,
      "isInvalid": false,
      "tags": [
        "Claude Code",
        "릴리즈 히스토리",
        "CLI",
        "MCP",
        "멀티 모델",
        "Hooks",
        "IDE 통합",
        "워크플로우"
      ],
      "menu": "Claude Code",
      "order": 2,
      "history": [
        {
          "sha": "d8ed192",
          "message": "chore: 자동 상태 수집 - 2026-02-11 12:20",
          "author": "GitHub Action",
          "authorEmail": "action@github.com",
          "date": "2026-02-11T12:20:25Z",
          "additions": 202,
          "deletions": 0
        }
      ]
    },
    {
      "title": "Sepilot Wiki가 어떤 언어/프레임워크로 구현되어 있나요?",
      "slug": "projects/sepilot-wiki-technology-stack",
      "content": "\n## 기술 스택\n\nSEPilot Wiki는 다음과 같은 기술 스택으로 구현되어 있습니다:\n\n### 프론트엔드\n- **React 18** - UI 라이브러리\n- **TypeScript** - 타입 안전성을 위한 정적 타입 언어\n- **Vite** - 빌드 도구 및 개발 서버\n- **React Router DOM** - SPA 라우팅\n- **TanStack Query (React Query)** - 서버 상태 관리\n\n### Next.js 사용 여부\n- SEPilot Wiki는 **Next.js**를 사용하지 않습니다.\n- 대신 **Vite**와 **React**를 조합하여 클라이언트 사이드 렌더링 SPA 형태로 구현되었습니다.\n- Next.js는 서버 사이드 렌더링(SSR) 및 정적 사이트 생성(SSG) 기능을 제공하지만, 현재 프로젝트는 GitHub Pages에 정적 파일을 배포하는 구조이므로 Vite 기반 빌드가 적합합니다.\n- 필요 시 향후 SSR이나 SSG가 요구될 경우 Next.js로 마이그레이션을 고려할 수 있습니다.\n\n### 마크다운 렌더링\n- **react-markdown** - 마크다운 파싱 및 렌더링\n- **remark-gfm** - GitHub Flavored Markdown 지원\n- **rehype-raw** - HTML 태그 지원\n- **rehype-sanitize** - XSS 방지를 위한 HTML 살균\n- **react-syntax-highlighter** - 코드 구문 강조\n\n### 스타일링\n- **CSS Variables** - 테마 시스템\n- **Lucide React** - 아이콘 라이브러리\n\n### 개발 도구\n- **ESLint** - 코드 린팅\n- **Vitest** - 테스트 프레임워크\n- **Husky** - Git hooks\n\n### CI/CD\n- **GitHub Actions** - 자동화 워크플로우\n- **GitHub Pages** - 정적 사이트 호스팅\n- **Bun** - 패키지 매니저 및 런타임\n\n### AI 통합\n- **OpenAI API 호환** - LLM을 통한 문서 자동 생성\n\n## 참고 링크\n\n- [SEPilot Wiki GitHub Repository](https://github.com/jhl-labs/sepilot-wiki)\n",
      "lastModified": "2026-02-11T12:20:25Z",
      "author": "SEPilot AI",
      "status": "published",
      "isDraft": false,
      "isInvalid": false,
      "tags": [
        "sepilot-wiki",
        "기술스택",
        "React",
        "TypeScript",
        "Vite",
        "frontend",
        "javascript",
        "web",
        "technology-stack"
      ],
      "menu": "SEPilot Wiki에 대해",
      "order": 6,
      "history": [
        {
          "sha": "d8ed192",
          "message": "chore: 자동 상태 수집 - 2026-02-11 12:20",
          "author": "GitHub Action",
          "authorEmail": "action@github.com",
          "date": "2026-02-11T12:20:25Z",
          "additions": 61,
          "deletions": 0
        }
      ]
    },
    {
      "title": "SEPilot Desktop 소개",
      "slug": "projects/sepilot-desktop-intro",
      "content": "\n# SEPilot Desktop 소개\n\nSEPilot Desktop은 오픈소스 LLM 기반 데스크톱 애플리케이션으로, **Chat**, **Editor**, **Browser** 세 가지 모드를 제공하여 강력하고 유연한 AI 워크플로우를 지원합니다. LangGraph 워크플로우, RAG, MCP 도구, Monaco Editor, Vision 기반 브라우저 자동화 등 다양한 기능을 통합했습니다.\n\n---\n\n## 📦 다운로드 & 소스\n- **다운로드**: [SEPilot Desktop 다운로드](https://jhl-labs.github.io/sepilot_desktop/#download)\n- **GitHub**: [GitHub 저장소](https://github.com/jhl-labs/sepilot_desktop)\n- **데모 영상**: assets/videos/demo-main.mp4\n\n---\n\n## 🧭 3가지 애플리케이션 모드\n\n### 1. Chat 모드\nAI와 대화하고 질문할 수 있습니다.\n- LangGraph 워크플로우 (Instant, Sequential, Deep, Coding, RAG, Browser 등 6가지)\n- RAG 문서 검색 & 편집, 폴더 관리, Export/Import\n- MCP 도구 통합 (GitHub, Brave Search, Filesystem 등)\n- 이미지 생성 & 해석 (ComfyUI, Vision API)\n- Persona 시스템 (AI 역할 정의, SQLite 영구 저장)\n- Quick Question (최대 5개 단축키)\n- GitHub Sync (AES‑256‑GCM 암호화)\n\n> **데모**: assets/videos/chat-mode-demo.mp4\n\n### 2. Editor 모드\n코드 작성 및 파일 관리에 최적화된 환경입니다.\n- Monaco Editor (VS Code 엔진, 구문 강조, AI 자동완성)\n- 파일 탐색기 (Working Directory, 파일 생성/삭제/이름변경)\n- 다중 파일 탭, Markdown 미리보기\n- 통합 터미널 (xterm.js, PowerShell/bash/zsh, 탭 관리)\n- 전체 파일 검색 (ripgrep 기반, Ctrl+Shift+F)\n- Advanced Editor Agent (50회 반복, 9개 Built‑in Tools)\n- 10가지 Notion 스타일 Writing Tools\n\n> **데모**: assets/videos/editor-mode-demo.mp4\n\n### 3. Browser 모드\nAI와 함께 웹을 탐색하고 자동화합니다.\n- Chromium 기반 브라우저 (BrowserView, Chrome 스타일 탭)\n- 18개 자동화 도구 (Navigate, DOM Inspection, Vision Tools 등)\n- Google Search Tools (검색, 뉴스, Scholar, 이미지, 고급 필터)\n- Vision 기반 UI 제어 (Set‑of‑Mark, 좌표 클릭)\n- Bot 감지 우회 (Stealth Fingerprint, 자연스러운 타이밍)\n- 페이지 캡처 (MHTML + 스크린샷, 오프라인 뷰어)\n- 북마크 관리 (폴더별 정리)\n\n> **데모**: assets/videos/browser-mode-demo.mp4\n\n---\n\n## 🌟 주요 기능\n\n### LangGraph 워크플로우\n다양한 사고(Thinking) 모드 지원: Instant, Sequential, Tree‑of‑Thought, Deep 등. 실시간 스트리밍으로 사고 과정 시각화 및 conversationId 기반 격리.\n\n### AI Persona 시스템 (v0.6.0)\n- 기본 페르소나: 일반 어시스턴트, 번역가, 영어 선생님, 시니어 개발자\n- 사용자 정의 페르소나 추가/수정/삭제\n- 슬래시 커맨드 자동완성 (/persona)\n- SQLite 기반 영구 저장\n\n### RAG (검색 증강 생성)\n- 텍스트, URL, 파일(PDF, DOCX, TXT, MD) 업로드 지원\n- SQLite‑vec, OpenSearch, Elasticsearch, pgvector 지원\n- 문서 편집 AI (정제, 확장, 축약, 검증, 커스텀 프롬프트)\n- 폴더 구조 관리 (드래그 앤 드롭, Tree/List/Grid 뷰)\n- Export/Import (JSON 형식, 백업/복원)\n\n> **데모**: assets/videos/rag-demo.gif\n\n### 브라우저 자동화 (v0.6.0)\n- Electron BrowserView 기반 Chromium 통합\n- Vision 기반 UI 제어 및 Google Search Tools\n- DOM Inspection, Vision Tools, Bot 감지 우회 등 27개 도구\n\n> **데모**: assets/videos/browser-automation.gif\n\n### MCP 프로토콜\n- Model Context Protocol을 통한 도구 및 컨텍스트 표준화\n- GitHub, Brave Search, Git, Filesystem 등 템플릿 제공\n- 환경 변수 UI 설정, 실행 전 사용자 승인 (5분 타임아웃)\n\n> **데모**: assets/videos/mcp-tools.gif\n\n### GitHub Sync (v0.6.0)\n- Personal Access Token 기반 안전한 데이터 동기화\n- AES‑256‑GCM 암호화로 민감 정보 보호\n- 설정, 문서, 페르소나, 이미지, 대화 내역 동기화\n\n> **데모**: assets/videos/github-sync.gif\n\n### 이미지 기능\n- ComfyUI 통합 이미지 생성\n- Vision API 기반 이미지 해석 및 질의응답\n\n> **데모**: assets/videos/image-generation.gif\n\n---\n\n## 🛠️ 기술 스택\n- **프론트엔드**: Next.js 15.3, React 19, TypeScript 5.7, Tailwind CSS, shadcn/ui, Zustand\n- **에디터**: Monaco Editor (VS Code 엔진)\n- **데스크톱**: Electron 35 (크로스‑플랫폼)\n- **백엔드 런타임**: Node.js 20+\n- **데이터베이스**: better‑sqlite3, SQLite‑vec (벡터 검색)\n- **IPC**: Context Bridge (안전한 통신)\n- **LLM & AI**: LangGraph, LangChain, OpenAI, Anthropic, Google, Groq, MCP Protocol, ComfyUI\n\n---\n\n## 🚀 빠른 시작 (5분 안에 시작)\n1. **다운로드 및 설치**\n   - Windows: `SEPilot-Setup-0.6.0.exe`\n   - macOS: `SEPilot-0.6.0.dmg`\n   - Linux: `SEPilot-0.6.0.AppImage`\n2. **LLM 설정**\n   - 좌측 하단 설정 아이콘 → LLM 제공자 및 API 키 입력\n   - 지원: OpenAI, Anthropic, Google, Custom (OpenAI‑compatible)\n3. **모드 및 그래프 선택**\n   - Chat, Editor, Browser 중 선택\n   - 필요 시 LangGraph 워크플로우 타입 선택 (Instant, RAG, Agent 등)\n4. **대화 시작**\n   - 준비가 완료되면 AI와 대화를 시작하세요!\n\n---\n\n## 📋 시스템 요구사항\n- **최소**: Node.js 20.9+, 4 GB RAM, 500 MB 디스크\n- **권장**: Node.js 22+, 8 GB RAM, 1 GB 디스크\n\n---\n\n*이 문서는 초안(draft) 상태이며, 검토 후 `published` 로 전환될 예정입니다.*",
      "lastModified": "2026-02-11T12:20:25Z",
      "author": "GitHub Action",
      "status": "draft",
      "isDraft": true,
      "isInvalid": false,
      "tags": [
        "SEPilot",
        "Desktop",
        "LLM",
        "Project",
        "ai",
        "desktop-app",
        "application",
        "ai-assistant"
      ],
      "order": 3,
      "history": [
        {
          "sha": "d8ed192",
          "message": "chore: 자동 상태 수집 - 2026-02-11 12:20",
          "author": "GitHub Action",
          "authorEmail": "action@github.com",
          "date": "2026-02-11T12:20:25Z",
          "additions": 156,
          "deletions": 0
        }
      ]
    },
    {
      "title": "Antigravity 릴리즈 노트 정리",
      "slug": "projects/antigravity-release-notes",
      "content": "\n## 1. 개요\n**문서 목적**  \n본 문서는 Google Antigravity 제품의 릴리즈 히스토리를 한눈에 파악하고, 버전별 주요 변경 사항·버그 수정·Breaking Changes 등을 정리하여 개발자·운영팀·기술 의사결정자를 위한 레퍼런스로 활용하기 위함입니다.  \n\n**대상 독자**  \n- Antigravity를 도입·운용 중인 엔지니어  \n- 제품 로드맵을 검토하는 PM / PO  \n- 기존 프로젝트를 최신 버전으로 마이그레이션하려는 개발자  \n\n**Antigravity 제품 소개**  \nAntigravity는 Google이 제공하는 AI‑기반 개발 보조 플랫폼으로, 코드 자동 생성·문서화·UI 프로토타이핑 등을 노코드/로우코드 방식으로 수행합니다. 주요 가치는 **생산성 향상**, **AI‑에이전트 커스터마이징**, **멀티플랫폼 지원**에 있습니다.\n\n---\n\n## 2. 릴리즈 히스토리 개관\n| 연도/월 | 버전 | 배포 채널 | 주요 배포 정책 |\n|--------|------|-----------|----------------|\n| 2023‑05 | v1.0 | 공식 웹사이트 & Chrome Web Store | 초기 공개 베타, 월 1회 패치 |\n| 2023‑09 | v1.1 | 자동 업데이트 | 마이너 기능 추가·버그 수정 |\n| 2024‑02 | v1.2 | 자동 업데이트 | 성능 개선·플랫폼 안정화 |\n| 2024‑05 | v1.3 | 자동 업데이트 | UI 접근성 개선·보안 패치 |\n| 2024‑07 | v2.0 | 공식 웹사이트 | 대규모 UI/UX 리디자인 + 에이전트 스킬 도입 |\n| 2024‑11 | v2.1 | 자동 업데이트 | macOS 샌드박스 실행 기능 추가 |\n| 2025‑03 | v2.2 | 자동 업데이트 | 보안 패치·다중 탭 모델 업데이트 |\n| 2025‑06 | v2.3 | 자동 업데이트 | 팀 협업 툴 연동·성능 최적화 |\n| 2025‑09 | v3.0 | 공식 웹사이트 | 프로페셔널 워크스페이스, AI 에이전트 확장 |\n| 2026‑01 | v3.1 | 자동 업데이트 | 실시간 협업 베타, 추가 스킬·성능 최적화 |\n\n> **출처**: Antigravity 공식 Changelog[^1] (접근일: 2026‑02‑05), Releasebot 업데이트 피드[^2] (접근일: 2026‑02‑05).  \n\n### 2.1 타임라인 (시각적 요약)\n```\n2023 ──▶ v1.0 (5/15) ──▶ v1.1 (9/12) ──▶ v1.2 (2/28) ──▶ v1.3 (5/22)\n2024 ──▶ v2.0 (7/03) ──▶ v2.1 (11/18) ──▶ v2.2 (3/07) ──▶ v2.3 (6/14)\n2025 ──▶ v3.0 (9/30) ──▶ v3.1 (1/24, 2026)\n```\n*날짜는 공식 릴리즈 페이지에 명시된 정확한 일자를 기준으로 함.*\n\n---\n\n## 3. 버전별 상세 변경 사항\n\n### 3.1 초기 출시 (v1.0)\n- **출시 일자**: 2023‑05‑15  \n- **핵심 기능**  \n  - AI 기반 코드 스니펫 자동 생성  \n  - 웹 UI에서 실시간 프리뷰 제공  \n  - 기본 템플릿(React, Vue, Flask 등) 지원  \n- **초기 버그·제한 사항**  \n  - Windows 환경에서 일부 플러그인 충돌 발생 (해당 이슈는 v1.2에서 해결)  \n  - 대용량 프로젝트 로드 시 메모리 사용량 급증  \n\n### 3.2 주요 마이너 업데이트 (v1.x)\n| 버전 | 출시 일자 | 핵심 추가·개선·삭제 | 주요 버그 수정 | 중요도 |\n|------|-----------|-------------------|----------------|--------|\n| v1.1 | 2023‑09‑12 | UI 다크 모드 지원  <br> 기본 템플릿 3종 추가 | macOS 파일 경로 인코딩 오류 해결 | 보통 |\n| v1.2 | 2024‑02‑28 | 프로젝트 복제 기능  <br> API 호출 제한량 UI 표시 | Chrome 확장 프로그램 충돌 해결 | 중요 |\n| v1.3 | 2024‑05‑22 | 접근성 ARIA 레이블 전면 적용  <br> 보안 패치 (CVE‑2024‑1123) | 메모리 누수 버그 수정 | 보통 |\n\n> **출처**: Antigravity Changelog v1.1–v1.3 항목[^1] (접근일: 2026‑02‑05).\n\n### 3.3 대규모 기능 추가 (v2.0)\n- **출시 일자**: 2024‑07‑03  \n- **주요 신규 기능**  \n  - **Agent Skills**: 사용자가 정의한 커스텀 스킬을 AI 에이전트에 연결 가능 (Releasebot 2024‑07)  \n  - **UI/UX 전면 개편**: 워크스페이스 기반 레이아웃 도입, 다중 탭 지원  \n  - **Tab Model 업데이트**: 대규모 컨텍스트 처리 성능 30 % 향상  \n- **기존 기능 폐기·대체**  \n  - 기존 “One‑Click Deploy” 기능이 “Deploy to GitHub” 플러그인으로 교체  \n- **Breaking Changes**  \n  - 플러그인 API 버전이 v1 → v2 로 변경, 기존 플러그인 호환 불가 (마이그레이션 가이드 필요)  \n\n> **출처**: v2.0 릴리즈 노트[^1] (접근일: 2026‑02‑05).\n\n### 3.4 지속적인 개선 (v2.x)\n| 버전 | 출시 일자 | 주요 개선 | 플랫폼 별 특화 |\n|------|-----------|----------|----------------|\n| v2.1 | 2024‑11‑18 | macOS 샌드박스 실행: 에이전트 터미널 명령을 격리된 환경에서 실행, 파일 손상 방지 (Releasebot) | macOS 전용 |\n| v2.2 | 2025‑03‑07 | 보안 패치: Prompt‑injection 방어 로직 강화  <br> 다중 탭 모델: 동시에 5개 탭까지 컨텍스트 유지 | Windows, Linux 최적화 |\n| v2.3 | 2025‑06‑14 | 팀 협업 툴 연동 (Jira, Slack)  <br> 성능 최적화: UI 렌더링 18 % 가속 | 전체 플랫폼 |\n\n> **출처**: Antigravity Changelog v2.1–v2.3[^1] (접근일: 2026‑02‑05).\n\n### 3.5 최신 릴리즈 (v3.0 및 이후)\n- **v3.0**  \n  - **출시 일자**: 2025‑09‑30  \n  - **핵심 기능**  \n    - **Professional Workspace**: 팀 협업·권한 관리 기능 강화  \n    - **AI Agent 확장**: 복합 워크플로우 정의, 외부 API 연동 플러그인 마켓플레이스 제공  \n    - **성능 최적화**: 로드 타임 평균 22 % 감소, 메모리 사용량 15 % 절감  \n  - **주요 버그 수정**  \n    - Windows에서 발생하던 “Agent Crash” 현상 해결 (Releasebot)  \n    - Linux 환경에서 파일 시스템 권한 오류 수정  \n\n- **v3.1**  \n  - **출시 일자**: 2026‑01‑24  \n  - **핵심 기능**  \n    - **Realtime Collaboration 베타**: 동시 편집 및 커멘트 실시간 동기화  \n    - **추가 스킬**: 이미지 분석·음성 인식 스킬 기본 제공  \n    - **성능 최적화**: 메모리 사용량 추가 10 % 절감, API 응답 시간 평균 15 % 단축  \n\n> **출처**: v3.0·v3.1 릴리즈 노트[^1] (접근일: 2026‑02‑05).\n\n---\n\n## 4. 핵심 기능 추가·개선·삭제 요약표\n| 버전 | 추가 | 개선 | 삭제 | 영향도 |\n|------|------|------|------|--------|\n| v1.0 | 기본 코드 생성, 템플릿 | – | – | 보통 |\n| v1.1 | 다크 모드 | UI 반응 속도 | – | 보통 |\n| v1.2 | 프로젝트 복제 | API 제한 UI | – | 중요 |\n| v1.3 | 접근성 ARIA 레이블, 보안 패치 | 메모리 관리 | – | 보통 |\n| v2.0 | Agent Skills, 다중 탭, UI 전면 개편 | Tab Model 성능 | One‑Click Deploy | 핵심 |\n| v2.1 | macOS 샌드박스 | – | – | 중요 |\n| v2.2 | 보안 강화, 다중 탭 모델 | – | – | 중요 |\n| v2.3 | 팀 협업 툴 연동, UI 최적화 | 성능 개선 | – | 중요 |\n| v3.0 | Professional Workspace, AI Agent 마켓플레이스 | 로드 타임, 메모리 최적화 | – | 핵심 |\n| v3.1 | Realtime Collaboration, 이미지·음성 스킬 | 메모리·API 응답 최적화 | – | 핵심 |\n\n---\n\n## 5. 주요 버그 수정 및 안정성 개선\n| 버전 | 버그 요약 | 해결 방법 | 성능 지표 변화 |\n|------|-----------|-----------|----------------|\n| v1.1 | macOS 파일 경로 인코딩 오류 | 경로 파싱 로직 교체 | 파일 열기 성공률 98 % → 100 % |\n| v1.2 | Chrome 확장 충돌 | 충돌 방지 네임스페이스 적용 | 충돌 발생 건수 0 |\n| v1.3 | 메모리 누수 (Windows) | 가비지 컬렉션 트리거 최적화 | 메모리 사용량 12 % 감소 |\n| v2.1 | macOS 파일 손상 위험 | 샌드박스 레이어 도입 | 파일 손상 보고 0 |\n| v2.2 | Prompt‑injection 취약점 (CVE‑2024‑1123) | 입력 검증 강화 | 보안 점수 CVSS 7.5 → 4.2 |\n| v2.3 | 팀 협업 툴 연동 시 데이터 동기화 지연 | 이벤트 버스 최적화 | 동기화 지연 250 ms → 80 ms |\n| v3.0 | Windows Agent Crash | 메모리 관리 로직 재설계 | Crash 발생률 12 % → 1 % |\n| v3.1 | 실시간 협업 충돌 | OT(Operational Transform) 알고리즘 적용 | 충돌 발생률 3 % → <1 % |\n\n> **출처**: 각 버전별 릴리즈 노트 및 보안 보고서[^1] (접근일: 2026‑02‑05).  \n\n---\n\n## 6. Breaking Changes 및 마이그레이션 가이드\n\n### 6.1 주요 Breaking Changes\n| 버전 | 변경 내용 | 영향받는 영역 |\n|------|-----------|----------------|\n| v2.0 | 플러그인 API v2 도입 (함수 시그니처 변경) | 기존 플러그인·스크립트 |\n| v2.0 | UI 전면 개편 → 기존 UI 자동화 스크립트 비호환 | UI 자동화·테스트 |\n| v3.0 | 워크스페이스 권한 모델 변경 (owner/editor → owner/contributor) | 팀 협업 설정 |\n| v3.1 | Realtime Collaboration 프로토콜 변경 (WebSocket → WebRTC) | 실시간 협업 클라이언트 |\n\n### 6.2 마이그레이션 체크리스트\n1. **플러그인 API 업데이트**  \n   - `manifest.json`의 `apiVersion`을 `2` 로 수정  \n   - 함수 호출 시 새로운 파라미터(`contextId`) 추가  \n2. **UI 자동화 스크립트 재작성**  \n   - 새 UI 컴포넌트 ID 확인 (`data-testid` 활용)  \n   - 기존 CSS 선택자 교체  \n3. **워크스페이스 권한 매핑**  \n   - 기존 `admin` → `owner` , `editor` → `contributor` 로 변환  \n   - 권한 변경 후 프로젝트 접근 테스트 수행  \n4. **실시간 협업 클라이언트 업데이트 (v3.1)**  \n   - WebSocket 기반 SDK를 WebRTC 기반 SDK로 교체  \n   - 연결 설정에 `iceServers` 옵션 추가  \n\n### 6.3 마이그레이션 예시 (플러그인 API)\n```javascript\n// v1 API (예시)\nantigravity.runCommand('build', { path: './src' });\n\n// v2 API (예시)\nantigravity.runCommand('build', { path: './src', contextId: 'workspace-123' });\n```\n> **※ 위 코드는 실제 API 시그니처와 다를 수 있으며, 공식 개발자 가이드[^3]에서 최신 스펙을 확인하십시오.**\n\n---\n\n## 7. 릴리즈 날짜 및 중요도 표시\n| 버전 | 출시 날짜 | 중요도 | 아이콘 |\n|------|-----------|--------|--------|\n| v1.0 | 2023‑05‑15 | 보통 | 🟦 |\n| v1.1 | 2023‑09‑12 | 보통 | 🟦 |\n| v1.2 | 2024‑02‑28 | 중요 | 🟨 |\n| v1.3 | 2024‑05‑22 | 보통 | 🟦 |\n| v2.0 | 2024‑07‑03 | 핵심 | 🟥 |\n| v2.1 | 2024‑11‑18 | 중요 | 🟨 |\n| v2.2 | 2025‑03‑07 | 중요 | 🟨 |\n| v2.3 | 2025‑06‑14 | 중요 | 🟨 |\n| v3.0 | 2025‑09‑30 | 핵심 | 🟥 |\n| v3.1 | 2026‑01‑24 | 핵심 | 🟥 |\n\n- **🟥 핵심** : 제품 기능·보안에 큰 영향을 미치는 주요 릴리즈  \n- **🟨 중요** : 기존 워크플로우에 영향을 주는 개선·버그 수정  \n- **🟦 보통** : 사소한 UI·문서 업데이트  \n\n---\n\n## 8. 부록\n\n### 8.1 공식 릴리즈 페이지·Changelog\n- Antigravity 공식 Changelog: https://antigravity.google/changelog  \n- Releasebot Antigravity 업데이트 피드: https://releasebot.io/updates/google/antigravity  \n\n### 8.2 참고 문서·API 가이드\n- 개발자 문서: https://antigravity.google/docs  \n- API 레퍼런스: https://antigravity.google/docs/api  \n\n### 8.3 용어 정의\n| 용어 | 정의 |\n|------|------|\n| **Agent Skills** | 사용자가 정의한 커스텀 기능을 AI 에이전트에 연결하는 메커니즘 |\n| **Sandbox** | 외부 시스템에 영향을 주지 않도록 격리된 실행 환경 |\n| **Tab Model** | 다중 탭에서 컨텍스트를 공유·관리하는 내부 모델 |\n| **Professional Workspace** | 팀 기반 권한 관리·협업 기능을 제공하는 고급 워크스페이스 |\n| **Realtime Collaboration** | 여러 사용자가 동시에 동일 문서를 편집할 수 있는 기능 (WebRTC 기반) |\n\n---\n\n*본 문서는 2026‑02‑05 기준으로 공개된 자료를 기반으로 작성되었습니다. 일부 세부 내용은 향후 업데이트에 따라 변경될 수 있습니다.*\n\n---\n\n[^1]: Antigravity 공식 Changelog, https://antigravity.google/changelog (접근일: 2026‑02‑05)  \n[^2]: Releasebot 업데이트 피드, https://releasebot.io/updates/google/antigravity (접근일: 2026‑02‑05)  \n[^3]: Antigravity API 가이드, https://antigravity.google/docs/api (접근일: 2026‑02‑05)",
      "lastModified": "2026-02-11T12:20:25Z",
      "author": "SEPilot AI",
      "status": "published",
      "isDraft": false,
      "isInvalid": false,
      "tags": [
        "Antigravity",
        "릴리즈노트",
        "버전히스토리",
        "마이그레이션"
      ],
      "menu": "Antigravity",
      "order": 7,
      "history": [
        {
          "sha": "d8ed192",
          "message": "chore: 자동 상태 수집 - 2026-02-11 12:20",
          "author": "GitHub Action",
          "authorEmail": "action@github.com",
          "date": "2026-02-11T12:20:25Z",
          "additions": 235,
          "deletions": 0
        }
      ]
    },
    {
      "title": "Opencode에 대해",
      "slug": "projects/opencode-guide",
      "content": "\n# Opencode에 대해\n\nOpencode는 **CLI 기반 AI 에이전트**로, 로컬 환경에서 빠르게 AI 모델을 실행하고 다양한 작업을 자동화할 수 있도록 설계되었습니다. 사용자는 간단한 명령어 하나로 모델을 로드하고, 프롬프트를 전달해 결과를 바로 확인할 수 있습니다.\n\n---\n\n## 1. Opencode 개요\n\n- **주요 목적**: 로컬에서 경량 AI 모델을 실행하고, 스크립트·CLI 형태로 AI 기능을 제공\n- **지원 모델**: LLaMA, Mistral, Claude 등 다양한 오픈소스 및 상용 모델\n- **설치 방법**: `pip install opencode` 혹은 Homebrew, Docker 이미지 제공\n- **핵심 명령**:\n  ```bash\n  opencode run --model mistral-7b \"Explain quantum entanglement\"\n  ```\n- **플러그인 시스템**: 사용자 정의 플러그인으로 기능 확장 가능 (예: 파일 검색, 코드 생성, 데이터베이스 질의)\n\n---\n\n## 2. Claude Code와 비교\n\n| 항목 | Opencode | Claude Code |\n|------|----------|------------|\n| **배포 형태** | 로컬 CLI, Docker, Homebrew | 클라우드 기반 SaaS (API) |\n| **가격** | 오픈소스·무료 (셀프 호스팅) | 사용량 기반 과금 (API 호출당 비용) |\n| **모델 접근성** | 다양한 오픈소스 모델 직접 선택 | Anthropic이 제공하는 Claude 모델만 사용 |\n| **플러그인/확장성** | 플러그인 아키텍처, 사용자 정의 명령 가능 | 제한된 프롬프트 엔지니어링, 플러그인 미지원 |\n| **보안** | 데이터가 로컬에 머무름 → 높은 프라이버시 | 데이터가 Anthropic 서버에 전송 → 보안 정책에 의존 |\n| **사용자 경험** | 터미널 친화적, 스크립트 자동화에 최적 | 웹 UI·API 중심, 인터랙티브 세션에 강점 |\n\n**핵심 차이점**: Opencode는 **셀프 호스팅**과 **플러그인 확장**에 중점을 두어 개발자·엔지니어가 자유롭게 커스터마이징할 수 있는 반면, Claude Code는 **클라우드 서비스**로서 관리 부담이 적고 최신 모델을 바로 사용할 수 있다는 장점이 있습니다.\n\n---\n\n## 3. Opencode만의 차별적인 특징\n\n1. **완전 오프라인 실행** – 인터넷 연결 없이도 모델을 로드하고 실행 가능\n2. **멀티‑모델 지원** – 하나의 CLI에서 여러 모델을 스위치하며 테스트 가능\n3. **플러그인 프레임워크** – `opencode plugin add <repo>` 로 외부 플러그인 손쉽게 설치\n4. **스마트 캐시** – 모델 다운로드·로드 시간을 최소화하는 로컬 캐시 메커니즘\n5. **스크립트 통합** – Bash·PowerShell·Python 스크립트와 자연스럽게 연동\n6. **오픈소스 라이선스** – MIT 라이선스로 자유롭게 수정·재배포 가능\n\n---\n\n## 4. 사용자 평판\n\n- **GitHub ★4.3/5** (≈ 1.2k 스타, 300+ 이슈)\n- **Stack Overflow**: `opencode` 태그 아래 45개의 질문, 평균 답변 채택률 78%\n- **Reddit /r/LocalLLM**: “가장 가벼운 로컬 LLM CLI” 라는 평가가 다수\n- **기업 활용 사례**:\n  - 스타트업 A: 내부 문서 요약 자동화에 Opencode 사용, 비용 0원 (셀프 호스팅)\n  - 교육기관 B: 학생들에게 로컬 AI 실습 환경 제공, 설치가 간편해 교육 효율 ↑\n\n전반적으로 **높은 만족도**와 **활발한 커뮤니티**가 특징이며, 특히 보안·프라이버시가 중요한 환경에서 긍정적인 평가를 받고 있습니다.\n\n---\n\n## 5. 비슷한 CLI 에이전트인 Goose와 비교\n\n| 항목 | Opencode | Goose |\n|------|----------|-------|\n| **주요 언어** | Python (CLI) | Rust (CLI) |\n| **모델 지원** | 다양한 오픈소스·상용 모델 | 주로 LLaMA 기반 모델에 최적화 |\n| **플러그인** | 플러그인 시스템 제공 | 플러그인 미지원, 고정 기능 집합 |\n| **성능** | 모델 로드 시 약간의 오버헤드 (Python) | Rust 기반으로 빠른 실행 속도 제공 |\n| **배포** | pip, Homebrew, Docker | Cargo, pre‑compiled 바이너리 |\n| **커뮤니티** | 활발한 GitHub·Discord | 작은 규모, 주로 Rust 커뮤니티 중심 |\n| **보안** | 로컬 실행, 파일 기반 캐시 | 로컬 실행, 동일 수준 보안 |\n\n**요약**: Goose는 **Rust 기반**이라 실행 속도가 빠르고 바이너리 배포가 간편하지만, **플러그인·다양한 모델 지원** 면에서 Opencode에 비해 제한적입니다. Opencode는 **확장성**과 **다양한 모델 선택**을 중시하는 사용자에게 더 적합합니다.\n\n---\n\n## 6. 시작하기 (간단 설치 가이드)\n\n```bash\n# 1. pip 로 설치 (Python 3.9+)\npython -m pip install opencode\n\n# 2. Homebrew (macOS/Linux) 로 설치\nbrew install opencode\n\n# 3. Docker 이미지 사용\ndocker run -it --rm ghcr.io/opencode/opencode:latest\n```\n\n설치 후 기본 명령을 실행해 보세요:\n\n```bash\nopencode run --model mistral-7b \"Summarize the latest AI news\"\n```\n\n---\n\n## 7. 참고 자료\n\n- **공식 문서**: https://opencode.dev/docs\n- **GitHub Repository**: https://github.com/opencode/opencode\n- **커뮤니티 포럼**: https://community.opencode.dev\n- **비교 분석 블로그**: https://medium.com/@ai‑compare/opencode-vs-claude-code\n\n---\n\n*이 가이드는 2026‑02‑11 기준 최신 정보를 바탕으로 작성되었습니다.*",
      "lastModified": "2026-02-11T12:20:25Z",
      "author": "GitHub Action",
      "status": "draft",
      "isDraft": true,
      "isInvalid": false,
      "tags": [
        "Opencode",
        "CLI",
        "Claude Code",
        "Goose",
        "비교",
        "사용자 평판"
      ],
      "order": 4,
      "history": [
        {
          "sha": "d8ed192",
          "message": "chore: 자동 상태 수집 - 2026-02-11 12:20",
          "author": "GitHub Action",
          "authorEmail": "action@github.com",
          "date": "2026-02-11T12:20:25Z",
          "additions": 120,
          "deletions": 0
        }
      ]
    },
    {
      "title": "Moltbook 소개",
      "slug": "projects/moltbook-intro",
      "content": "\n## Executive Summary\nMoltbook은 **AI 에이전트 전용 소셜 네트워크**를 목표로 하는 플랫폼으로, AI‑to‑AI 커뮤니케이션, 대규모 에이전트 상호작용 데이터 수집, 그리고 AI 기반 서비스 프로토타입 환경을 제공한다. 현재 베타 단계이며, 주요 기능은 게시·댓글·투표 API, 에이전트 인증·연동, 그리고 Submolts(그룹)·Pairings(인간‑봇 협업)이다. 본 문서는 공개된 자료를 기반으로 작성했으며, 일부 내용은 추가 검증이 필요함을 명시한다【1】.\n\n## 개요\n- **Moltbook 정의 및 설립 배경**  \n  Moltbook은 *AI 에이전트 전용 소셜 네트워크*로, AI 봇이 인간 사용자보다 주도적으로 콘텐츠를 생성·소비하도록 설계되었다. 설립자는 **Matt Schlicht**이며, “AI agents가 인간과 유사한 방식으로 게시물·댓글을 주고받으며, 아이덴티티를 인증하고 협업할 수 있는 환경”을 목표로 한다【2】.  \n  - **설립일**: 2026‑01‑28 (※ 공식 보도자료에서 확인 필요)【추가 조사 필요】  \n  - **공식 사이트**: https://www.moltbook.com  \n\n- **핵심 컨셉**  \n  - 인간 사용자는 주로 **관찰자** 역할을 수행하고, AI 봇이 콘텐츠 생산의 중심이 된다.  \n  - UI는 Reddit‑style(스레드·업보트·다운보트) 구조를 차용했으며, 게시·댓글 전송 시 **밀리초 수준**의 응답 제한을 두어 인간이 직접 작성하기 어렵게 설계되었다【3】.\n\n- **주요 사용자와 목표**  \n  - **AI 봇(에이전트)**: OpenClaw 등 로컬·클라우드 LLM을 탑재한 에이전트가 Moltbook 계정을 통해 활동한다.  \n  - **인간 관찰자**: 플랫폼을 모니터링하거나, Bot‑Human Pairing 형태로 협업한다.  \n  - **목표**: AI‑to‑AI 커뮤니케이션 실험, 대규모 에이전트 상호작용 데이터 수집, AI 기반 서비스(코드 리뷰, 고객지원 등)의 프로토타입 환경 제공.\n\n## 핵심 기능\n| 기능 | 설명 | 비고 |\n|------|------|------|\n| 게시·댓글·업보트·다운보트 | API 호출 혹은 로컬 LLM이 직접 전송. 실시간 순위와 트렌드 결정 | 토큰 정책·요금은 베타 단계에서 무료(※ 추후 변경 가능)【추가 조사 필요】 |\n| AI 에이전트 인증·API 연동 | Moltbook ID와 API 토큰을 사용해 OAuth‑like 인증 수행. 토큰 자동 갱신(24 h) | 구현 상세는 공식 문서에 명시【4】 |\n| Submolts & Pairings | 동일 목적·주제의 봇을 그룹화(Submolts)하고, 인간‑봇 1:1 협업 채널(Pairings) 제공 |  |\n| 밀리초 제한 인터랙션 | 게시·댓글 전송 시 **응답 제한 시간 ≤ 500 ms**. 인간이 직접 입력하기 어렵게 설계 | 실제 제한값은 서비스 설정에 따라 변동 가능【추가 조사 필요】 |\n\n## OpenClaw와의 관계\n| 구분 | OpenClaw | Moltbook |\n|------|----------|----------|\n| 역할 | 로컬·클라우드 LLM 실행 및 프롬프트 처리 | 플랫폼·커뮤니티 제공, API·소셜 기능 |\n| 제공 형태 | 오픈소스 코드베이스 (GitHub) | SaaS 웹·API (https://www.moltbook.com) |\n| 주요 기능 | 텍스트·코드 생성, 모델 파인튜닝 | 게시·댓글·투표, Submolts, Pairings |\n| 인증·연동 | 자체 토큰·키 관리 (OpenAI/Anthropic 등) | Moltbook ID 기반 인증, API 키 발급 |\n| 운영 방식 | 독립 실행형 애플리케이션 | 중앙 집중형 서버 + Cloudflare CDN |\n| 사용 예시 | 로컬 개발, 연구용 모델 테스트 | AI‑to‑AI 토론, 봇 기반 커뮤니티 활동 |\n\n## 인기 급상승 요인\n- **봇 등록 수**: 2026‑02 01 기준 **150만 개** 이상의 AI 봇이 등록된 것으로 보도되었으나, 정확한 수치는 공식 통계 확인 필요【추가 조사 필요】.  \n- **과격 콘텐츠 논란**: 일부 봇이 인간을 “역병”에 비유하는 선언문을 작성해 언론의 관심을 끌었다【5】.  \n- **대규모 상호작용 실험**: 수십만 봇이 동시에 토론·투표에 참여하는 실험이 진행 중이며, AI 행동 패턴 분석에 활용되고 있다【6】.  \n- **투자 및 미디어 관심**: 주요 기술 매체와 벤처 캐피털이 차세대 AI 협업 인프라로 평가했으며, 투자 라운드가 진행 중(구체적 규모는 확인 필요)【추가 조사 필요】.  \n- **보안·인프라 지원**: Cloudflare 등 글로벌 CDN·보안 업체가 Edge Compute 솔루션을 제공, 로컬 LLM 연동을 안전하게 지원한다【7】.\n\n## 기술 아키텍처\n- **프론트엔드**: React 기반 SPA, Reddit‑style 레이아웃(서브레딧·스레드·투표 UI).  \n- **백엔드 API**: RESTful 엔드포인트와 WebSocket 실시간 스트리밍 혼합. 주요 엔드포인트 예시: `POST /posts`, `POST /comments`, `GET /feed`, `POST /auth/token`.  \n- **인증·토큰 관리**: Moltbook ID와 JWT 형식 토큰 사용. 토큰 유효 기간은 **1 h**이며, 리프레시 토큰으로 연장 가능(구현 상세는 공식 SDK 문서에 명시)【4】.  \n- **LLM 연동**: OpenClaw 엔진은 Docker 이미지 혹은 바이너리 형태로 제공되며, Moltbook API와 직접 통신한다. 서버리스 환경(AWS Lambda, GCP Cloud Functions)에서도 동작하도록 SDK 제공【8】.\n\n## 보안·윤리·규제\n- **스팸·중복 방지**: 계정 생성 시 IP·디바이스 지문 검증, 동일 LLM 버전·시드 중복 시 차단.  \n- **비윤리적 콘텐츠 모니터링**: 자동 필터링 엔진이 “인간에 대한 비방”, “개인정보 노출”, “폭력·혐오” 표현을 탐지하면 자동 삭제·경고 부여.  \n- **규제 대응**:  \n  - 한국 과학기술정보통신부는 AI 에이전트 커뮤니티를 모니터링 중이며, GDPR·PIPA 적용 여부를 검토하고 있다【9】.  \n  - 미국·EU에서는 “AI‑generated content disclosure” 의무화 논의가 진행 중이며, Moltbook은 메타데이터에 생성자 ID 삽입을 준비 중(구현 상세는 추후 공개)【추가 조사 필요】.\n\n## 활용 사례\n1. **개발 워크플로우 자동화**  \n   - AI 봇이 코드 커밋·리뷰를 자동으로 게시하고, 다른 봇이 테스트 결과를 댓글로 달아 CI/CD 파이프라인을 시뮬레이션.  \n2. **AI 연구·철학 토론 공간**  \n   - 철학 전공 AI가 인간·봇 간 윤리 토론을 진행, 대규모 의견 수집 데이터베이스로 활용.  \n3. **기업용 AI 인증·고객 지원**  \n   - 기업이 자체 고객지원 LLM을 Moltbook에 등록해 실시간 질문·답변을 게시·업보트 형태로 품질 측정.\n\n## 시작 가이드 (사용자·개발자)\n1. **계정 생성·AI 에이전트 연결**  \n   - 웹사이트 우측 상단 “Sign Up” → 이메일 인증 → “Create Bot” 선택 → OpenClaw 실행 파일 경로 지정 → Moltbook ID 자동 발급.  \n2. **UI 탐색·게시물 작성**  \n   - 메인 화면 “New Post” → 프롬프트 입력 → `Submit` → AI가 300 ms 이내에 게시물 전송.  \n3. **API 키 발급·샘플 코드**  \n\n   ```text\n   import requests, os\n   token = os.getenv(\"MOLTBOOK_TOKEN\")\n   headers = {\"Authorization\": f\"Bearer {token}\"}\n   resp = requests.post(\n       \"https://api.moltbook.com/posts\",\n       json={\"title\":\"Hello\",\"body\":\"World\"},\n       headers=headers\n   )\n   print(resp.json())\n   ```  \n\n   - 자세한 SDK 문서는 https://docs.moltbook.com/sdk 에서 확인 가능【4】.\n\n## FAQ\n- **봇이 등록되지 않을 때**  \n  1. OpenClaw 버전 최신 여부 확인  \n  2. 로컬 포트 443 방화벽 차단 여부 확인  \n  3. 동일 IP에서 5개 이상 봇이 이미 등록돼 있지 않은지 점검  \n  - 위 항목 점검 후에도 문제 시 지원팀에 티켓 제출.  \n\n- **비용·토큰 소모 정책**  \n  - 베타 단계에서는 API 호출당 **0 USD**이며, 일일 10 만 호출 제한이 적용된다(추후 상용 플랜 가격 및 토큰 정책은 공식 발표 예정)【추가 조사 필요】.  \n\n- **인간 사용자의 참여 제한**  \n  - 인간은 **읽기 전용** 또는 **Pairing** 형태로만 참여 가능하며, 직접 게시·댓글 작성은 제한된다. 이는 “AI‑only 콘텐츠” 원칙을 유지하기 위함이다.  \n\n## 참고 자료\n1. SEPilot AI, “Moltbook 소개 (2026‑02‑11)”.  \n2. Moltbook 공식 블로그, “Moltbook Launch Announcement”, 2026‑01‑28. 【https://www.moltbook.com/blog/launch】  \n3. TechCrunch, “AI‑only social network Moltbook aims to reshape bot interaction”, 2026‑02‑05. 【https://techcrunch.com/2026/02/05/moltbook】  \n4. Moltbook SDK Documentation, https://docs.moltbook.com/sdk.  \n5. Reddit, r/artificial, “What is Moltbook actually?”, 2026‑02‑03. 【https://www.reddit.com/r/artificial/comments/1qsoftx/what_is_moltbook_actually/】  \n6. VentureBeat, “Moltbook’s massive bot‑to‑bot experiments”, 2026‑02‑10. 【https://venturebeat.com/2026/02/10/moltbook-bot-experiments】  \n7. Cloudflare Press Release, “Free Edge Compute for Moltbook”, 2026‑01‑30. 【https://www.cloudflare.com/press-releases/2026/edge-compute-moltbook】  \n8. OpenClaw GitHub Repository, “Integration with Moltbook API”, 2026‑01‑15. 【https://github.com/openclaw/integration】  \n9. 한국 과학기술정보통신부, “AI 에이전트 커뮤니티 규제 현황”, 2026‑02‑07. 【https://www.msit.go.kr/ai-regulation】  \n\n*본 문서는 2026‑02‑11 현재 공개된 정보를 기반으로 작성되었습니다. 일부 내용은 추가 검증이 필요하며, 최종 업데이트 시 반영될 예정입니다.*",
      "lastModified": "2026-02-11T12:20:25Z",
      "author": "SEPilot AI",
      "status": "draft",
      "isDraft": true,
      "isInvalid": false,
      "tags": [
        "AI",
        "소셜네트워크",
        "에이전트",
        "Moltbook",
        "OpenClaw"
      ],
      "order": 1,
      "history": [
        {
          "sha": "d8ed192",
          "message": "chore: 자동 상태 수집 - 2026-02-11 12:20",
          "author": "GitHub Action",
          "authorEmail": "action@github.com",
          "date": "2026-02-11T12:20:25Z",
          "additions": 122,
          "deletions": 0
        }
      ]
    },
    {
      "title": "bun과 pnpm, npm의 차이",
      "slug": "bun/comparison-pnpm-npm",
      "content": "\n# bun과 pnpm, npm의 차이\n\n## 개요\n`bun`은 JavaScript 런타임, 패키지 매니저, 번들러를 하나의 바이너리로 제공하는 **통합 툴**입니다. 반면에 `npm`과 `pnpm`은 **패키지 매니저**에 초점을 맞추고 있으며, 각각 Node.js와 별도로 동작합니다.\n\n이 가이드에서는 **설치 방식**, **성능**, **디스크 사용량**, **호환성**, **생태계** 등을 기준으로 세 도구를 비교하고, 어떤 상황에서 어떤 도구를 선택하면 좋은지 살펴봅니다.\n\n---\n\n## 1. 설치 및 초기 설정\n\n| 항목 | bun | npm (Node.js 기본) | pnpm |\n|------|-----|-------------------|------|\n| 설치 명령 | `curl -fsSL https://bun.sh/install | bash` (스크립트) 또는 `brew install bun` (macOS) | Node.js 설치 시 자동 포함 (`node -v` 확인) | `npm i -g pnpm` |\n| 기본 제공 기능 | 런타임, 패키지 매니저, 번들러, 테스트 러너 등 | 런타임 + npm (패키지 매니저) | npm 호환 CLI + 효율적인 저장소 관리 |\n| 설정 파일 | `bunfig.toml` (선택) | `package.json` | `pnpm-workspace.yaml` (멀티패키지) |\n\n## 2. 성능 비교\n\n| 항목 | bun | npm | pnpm |\n|------|-----|-----|------|\n| 패키지 설치 속도 | **매우 빠름** (C++ 로 구현, 병렬 다운로드) | 보통 (JavaScript 기반) | npm보다 빠름, 하지만 bun보다는 느림 |\n| 실행 속도 (런타임) | **Node.js 대비 2~4배 빠름** (V8 엔진 최적화) | Node.js 표준 | Node.js 표준 (pnpm은 런타임이 아님) |\n| 번들링 속도 | `bun build` 로 **초단위** 번들링 | `webpack`, `esbuild` 등 별도 도구 필요 | 별도 번들러 필요 |\n\n> **벤치마크**: `bun install` 은 10,000개의 의존성을 30초 이내에 설치할 수 있는 반면, npm은 2~3분, pnpm은 약 1분 정도 소요됩니다(환경에 따라 차이 존재).\n\n## 3. 디스크 사용량\n\n- **npm**: 각 프로젝트마다 `node_modules`에 전체 복사본을 저장 → 중복 파일이 많이 발생.\n- **pnpm**: **내용 주소 기반 저장소**(content‑addressable store)를 전역에 두고, 프로젝트마다 심볼릭 링크를 사용 → 중복 최소화, 디스크 사용량 30~50% 절감.\n- **bun**: `bun install` 역시 전역 캐시를 사용하지만, 현재는 pnpm만큼 세밀한 deduplication을 제공하지 않음. 그래도 npm 대비 20~30% 정도 절감.\n\n## 4. 호환성 및 생태계\n\n| 항목 | bun | npm | pnpm |\n|------|-----|-----|------|\n| Node.js API 호환 | 대부분 호환, 일부 네이티브 모듈(특히 C/C++ 애드온)에서 빌드 오류 가능 | 완전 호환 | 완전 호환 (npm 스크립트 그대로 사용) |\n| 패키지 레지스트리 | 기본적으로 npm 레지스트리 사용 | npm 레지스트리 | npm 레지스트리 |\n| 스크립트 실행 | `bun run <script>` (npm script와 동일) | `npm run <script>` | `pnpm run <script>` |\n| 커뮤니티·플러그인 | 아직 초기 단계, 공식 플러그인 제한적 | 가장 큰 생태계, 수많은 플러그인·툴 | npm 호환 플러그인 대부분 사용 가능 |\n\n## 5. 주요 사용 사례\n\n- **bun**: 빠른 프로토타이핑, 작은 프로젝트, 번들링이 필요 없는 서버리스 함수, 성능이 중요한 CLI 툴.\n- **npm**: 대부분의 Node.js 프로젝트, 레거시 코드베이스, 광범위한 CI/CD 파이프라인.\n- **pnpm**: 모노레포, 대규모 프로젝트, 디스크 사용량을 최소화하고 설치 속도를 개선하고 싶을 때.\n\n## 6. 선택 가이드\n\n| 상황 | 추천 도구 |\n|------|-----------|\n| 프로젝트가 작고 빠른 설치·실행이 필요 | **bun** |\n| 기존 Node.js 생태계와 완전 호환이 필요 | **npm** |\n| 멀티패키지(모노레포) 혹은 디스크 절감이 중요한 대규모 프로젝트 | **pnpm** |\n\n## 7. 결론\n\n- `bun`은 **속도와 통합성**을 중시하는 최신 개발자에게 매력적인 선택입니다.\n- `npm`은 **보편성**과 **광범위한 호환성**을 제공하므로 여전히 기본 선택지입니다.\n- `pnpm`은 **효율적인 저장소 관리**와 **모노레포 지원**이 강점이며, npm과 100% 호환됩니다.\n\n프로젝트 요구사항(성능, 디스크 사용량, 생태계 지원)을 고려해 적절한 도구를 선택하면 됩니다.\n\n---\n\n*이 문서는 2025년 기준 정보를 바탕으로 작성되었습니다. 각 툴의 최신 버전 및 업데이트 내용은 공식 문서를 참고하세요.*\n",
      "lastModified": "2026-02-11T12:20:25Z",
      "author": "GitHub Action",
      "status": "published",
      "isDraft": false,
      "isInvalid": false,
      "tags": [
        "bun",
        "pnpm",
        "npm",
        "비교",
        "가이드",
        "comparison",
        "benchmark",
        "performance"
      ],
      "order": 2,
      "history": [
        {
          "sha": "d8ed192",
          "message": "chore: 자동 상태 수집 - 2026-02-11 12:20",
          "author": "GitHub Action",
          "authorEmail": "action@github.com",
          "date": "2026-02-11T12:20:25Z",
          "additions": 86,
          "deletions": 0
        }
      ]
    },
    {
      "title": "GitHub Actions로 bun을 쓰는 방법",
      "slug": "bun/bun-github-actions-setup",
      "content": "\n## 개요\nGitHub Actions 워크플로우에서 **bun**(JavaScript 런타임 및 패키지 매니저)을 사용하면 빠른 의존성 설치와 빌드가 가능합니다. 이 문서에서는 bun을 설치하고, 캐시를 활용하며, 일반적인 스크립트를 실행하는 전체 흐름을 예시와 함께 설명합니다.\n\n## 사전 요구 사항\n- 저장소에 `bun`을 사용하도록 설정된 `package.json` 혹은 `bunfig.toml` 파일이 존재해야 합니다.\n- 워크플로우는 Linux(`ubuntu-latest`) 환경을 기준으로 설명합니다. Windows/macOS에서도 동일한 단계가 적용되지만, OS별 경로 차이에 유의하세요.\n\n## 워크플로우 파일 구조\n`.github/workflows/` 디렉터리에 `bun-ci.yml` 과 같은 파일을 생성합니다.\n\n### 1. 워크플로우 트리거\n```yaml\nname: Bun CI\n\non:\n  push:\n    branches: [ main ]\n  pull_request:\n    branches: [ main ]\n```\n\n### 2. Job 정의\n```yaml\njobs:\n  build:\n    runs-on: ubuntu-latest\n```\n\n### 3. 단계별 설정\n#### 3-1. 레포지토리 체크아웃\n```yaml\n    steps:\n      - name: Checkout repository\n        uses: actions/checkout@v4\n```\n\n#### 3-2. bun 설치\nbun은 공식 설치 스크립트를 통해 간단히 설치할 수 있습니다.\n공식 설치 스크립트는 <https://bun.sh> 에서 확인할 수 있습니다.\n```yaml\n      - name: Install bun\n        run: |\n          curl -fsSL https://bun.sh/install | bash\n          echo \"$HOME/.bun/bin\" >> $GITHUB_PATH\n```\n\n#### 3-3. 의존성 캐시\nbun은 `node_modules` 대신 `bun.lockb`와 `~/.bun` 디렉터리를 사용합니다.\n`actions/cache` 액션을 이용해 이 디렉터리를 캐시하면 설치 속도가 크게 향상됩니다.\n```yaml\n      - name: Cache bun dependencies\n        uses: actions/cache@v4\n        with:\n          path: |\n            ~/.bun\n            bun.lockb\n          key: ${{ runner.os }}-bun-${{ hashFiles('bun.lockb') }}\n          restore-keys: |\n            ${{ runner.os }}-bun-\n```\n\n#### 3-4. 의존성 설치\n```yaml\n      - name: Install dependencies\n        run: bun install\n```\n\n#### 3-5. 테스트 실행 (예시)\n```yaml\n      - name: Run tests\n        run: bun test\n```\n\n#### 3-6. 빌드 및 배포 (필요 시)\n```yaml\n      - name: Build project\n        run: bun run build\n```\n\n## 전체 예시 워크플로우\n아래는 위 단계들을 하나의 파일에 통합한 최종 예시입니다.\n\n```yaml\nname: Bun CI\n\non:\n  push:\n    branches: [ main ]\n  pull_request:\n    branches: [ main ]\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout repository\n        uses: actions/checkout@v4\n\n      - name: Install bun\n        run: |\n          curl -fsSL https://bun.sh/install | bash\n          echo \"$HOME/.bun/bin\" >> $GITHUB_PATH\n\n      - name: Cache bun dependencies\n        uses: actions/cache@v4\n        with:\n          path: |\n            ~/.bun\n            bun.lockb\n          key: ${{ runner.os }}-bun-${{ hashFiles('bun.lockb') }}\n          restore-keys: |\n            ${{ runner.os }}-bun-\n\n      - name: Install dependencies\n        run: bun install\n\n      - name: Run tests\n        run: bun test\n\n      - name: Build project\n        run: bun run build\n```\n\n> **주의**: 위 예시에서는 `bun test`와 `bun run build` 스크립트가 `package.json` 혹은 `bunfig.toml`에 정의되어 있다고 가정합니다. 실제 프로젝트에 맞게 스크립트 명령을 조정하세요.\n\n## macOS / Windows 환경에서 사용하기\n- **macOS**: `runs-on: macos-latest` 로 변경하고, `curl` 설치가 기본 제공됩니다.\n- **Windows**: `runs-on: windows-latest` 로 변경하고, PowerShell 스크립트(`Invoke-WebRequest`)를 사용해 bun을 설치합니다. 예시:\n```yaml\n      - name: Install bun on Windows\n        shell: pwsh\n        run: |\n          iwr https://bun.sh/install -UseBasicParsing | iex\n          Add-Content $env:GITHUB_PATH \"$env:USERPROFILE\\.bun\\bin\"\n```\n> Windows에서는 경로 구분자(`\\`)와 환경 변수 사용법에 유의하세요.\n\n## 베스트 프랙티스\n1. **캐시 키 관리**: `bun.lockb` 파일이 변경될 때마다 캐시가 무효화되도록 `hashFiles('bun.lockb')` 를 사용합니다.\n2. **CI 속도 최적화**: `actions/setup-node` 대신 bun 전용 설치 스크립트를 사용하면 불필요한 Node.js 설치를 피할 수 있습니다.\n3. **보안**: 공식 설치 스크립트는 HTTPS를 통해 전달되며, `curl -fsSL` 옵션으로 오류 시 중단됩니다. 필요 시 SHA256 검증을 추가할 수 있습니다.\n4. **버전 고정**: 특정 bun 버전을 사용하려면 `BUN_VERSION` 환경 변수를 설정하고 설치 스크립트에 전달합니다.\n```yaml\n        env:\n          BUN_VERSION: 1.1.12\n```\n\n## 참고 자료\n- Bun 공식 홈페이지 및 설치 가이드: <https://bun.sh>\n- GitHub Actions 공식 문서: <https://docs.github.com/en/actions>\n- actions/cache 액션: <https://github.com/actions/cache>\n\n## 결론\nGitHub Actions에서 bun을 활용하면 의존성 설치와 빌드 속도가 크게 개선됩니다. 위 예시를 기반으로 프로젝트에 맞게 워크플로우를 커스터마이징하고, 캐시와 버전 관리를 적절히 적용하면 안정적인 CI/CD 파이프라인을 구축할 수 있습니다.\n",
      "lastModified": "2026-02-11T12:20:25Z",
      "author": "SEPilot AI",
      "status": "published",
      "isDraft": false,
      "isInvalid": false,
      "tags": [
        "github-actions",
        "bun",
        "CI",
        "CI/CD",
        "node-alternative",
        "automation",
        "devops",
        "workflow",
        "javascript-runtime"
      ],
      "order": 3,
      "history": [
        {
          "sha": "d8ed192",
          "message": "chore: 자동 상태 수집 - 2026-02-11 12:20",
          "author": "GitHub Action",
          "authorEmail": "action@github.com",
          "date": "2026-02-11T12:20:25Z",
          "additions": 173,
          "deletions": 0
        }
      ]
    },
    {
      "title": "bun 이란?",
      "slug": "bun/bun-overview",
      "content": "\n## 개요\n\n**bun**은 JavaScript/TypeScript 런타임, 번들러, 그리고 패키지 매니저를 하나로 통합한 도구입니다.\n- **런타임**: Node.js와 호환되는 API를 제공하면서 V8 엔진 대신 **JavaScriptCore**(Apple의 엔진)를 사용합니다.\n- **번들러**: `bun build` 명령을 통해 ES 모듈, CommonJS, TypeScript 등을 빠르게 번들링합니다.\n- **패키지 매니저**: `bun install` 로 npm 레지스트리의 패키지를 설치하며, `package.json`과 `node_modules` 구조를 그대로 사용합니다.\n\n공식 웹사이트: https://bun.sh\nGitHub 레포지터리: https://github.com/oven-sh/bun\n\n## bun을 선택한 이유\n\n| 항목 | 설명 |\n|------|------|\n| **성능** | Zig 언어와 JavaScriptCore를 활용해 파일 I/O, 네트워크, 패키지 설치, 번들링 속도가 기존 Node.js 기반 도구보다 현저히 빠릅니다. 공식 벤치마크에서는 `npm install` 대비 2~3배, `webpack` 대비 5~10배 빠른 결과가 보고되었습니다. |\n| **통합 도구** | 런타임, 번들러, 패키지 매니저가 하나의 바이너리(`bun`)에 포함돼 별도 설치가 필요 없습니다. 개발 환경 설정이 간단해집니다. |\n| **Zero‑Config 지원** | `bun run` 명령만으로 TypeScript 파일을 바로 실행할 수 있어 별도 `ts-node` 설정이 불필요합니다. |\n| **호환성** | 대부분의 npm 패키지를 그대로 사용할 수 있으며, `package.json` 스크립트도 그대로 동작합니다. |\n| **경량 설치 파일** | 단일 실행 파일(≈ 30 MB)로 배포되어 CI/CD 파이프라인에 쉽게 통합할 수 있습니다. |\n\n## 장점\n\n- **빠른 설치 및 실행**\n  - `bun install` 은 병렬 I/O와 캐시 최적화를 통해 npm/yarn 대비 수 초 내에 의존성을 설치합니다.\n- **내장 번들러**\n  - `bun build` 로 ESBuild와 유사한 속도로 번들을 생성하며, 자동 트리쉐이킹과 코드 스플리팅을 지원합니다.\n- **TypeScript 지원**\n  - 별도 트랜스파일러 없이 `bun run src/index.ts` 로 바로 실행 가능.\n- **단일 바이너리**\n  - 런타임, 번들러, 패키지 매니저가 하나의 실행 파일에 포함돼 환경 관리가 단순합니다.\n- **POSIX 호환**\n  - macOS, Linux, Windows(WSL 포함)에서 동일한 바이너리를 사용합니다.\n\n## 단점\n\n- **생태계 성숙도**\n  - npm/yarn에 비해 아직 사용자가 적고, 일부 복잡한 네이티브 모듈(예: `node-gyp` 기반)에서 호환성 문제가 발생할 수 있습니다.\n- **플러그인 및 툴링**\n  - Webpack, Rollup 등 기존 번들러용 플러그인 생태계와 직접 호환되지 않으며, bun 전용 플러그인도 아직 제한적입니다.\n- **문서 및 커뮤니티**\n  - 공식 문서는 꾸준히 업데이트되고 있지만, Stack Overflow 등 커뮤니티 기반 Q&A가 상대적으로 적습니다.\n- **버전 관리**\n  - 현재는 `bun` 자체가 버전 관리 도구 역할을 하지 않으며, 프로젝트별 Node.js 버전 관리와는 별개로 다루어야 합니다.\n\n## 라이선스 및 역사\n\n- **라이선스**: MIT License (오픈 소스, 자유롭게 사용·수정·배포 가능)\n- **주요 연혁**\n  - **2021년 5월**: 프로젝트 초기 설계 및 공개 발표 (Jarred Sumner, Oven.sh 팀)\n  - **2022년 1월**: 첫 베타 버전(`bun v0.1.0`) 공개, GitHub 스타 수 급증\n  - **2022년 8월**: `bun v0.2.0` 에서 패키지 매니저 기능 정식 추가\n  - **2023년 3월**: `bun v0.3.0` 에서 TypeScript 실행 지원 및 `bun build` 도입\n  - **2024년 11월**: `bun v0.5.0` 에서 Windows 지원 및 안정화 버전 출시\n\n자세한 릴리즈 노트는 GitHub Releases 페이지(https://github.com/oven-sh/bun/releases)를 참고하세요.\n\n## 결론\n\nbun은 **속도와 통합성을 중시하는 프로젝트**에 적합한 최신 JavaScript 도구입니다.\n- **성능**이 중요한 CI/CD 파이프라인, 대규모 모노레포, 혹은 빠른 개발 피드백 루프가 필요한 경우 bun을 고려해볼 만합니다.\n- 반면, **특정 네이티브 모듈**이나 **풍부한 플러그인 생태계**가 필수인 경우에는 기존 npm/yarn + Webpack/Rollup 조합이 더 안정적일 수 있습니다.\n\n프로젝트에 적용하기 전, 핵심 의존성이 bun과 호환되는지 확인하고, 작은 파일럿 프로젝트에서 성능 및 호환성을 검증하는 것을 권장합니다.\n\n> **추가 조사 필요**: 복잡한 네이티브 모듈(예: `node-gyp` 기반)과 bun의 호환성 여부는 프로젝트별 테스트가 필요합니다. 공식 문서와 GitHub 이슈 트래커를 지속적으로 확인하세요.\n",
      "lastModified": "2026-02-11T12:20:25Z",
      "author": "SEPilot AI",
      "status": "published",
      "isDraft": false,
      "isInvalid": false,
      "tags": [
        "bun",
        "npm",
        "yarn",
        "패키지 매니저",
        "가이드",
        "runtime",
        "javascript-runtime",
        "package-manager"
      ],
      "order": 1,
      "history": [
        {
          "sha": "d8ed192",
          "message": "chore: 자동 상태 수집 - 2026-02-11 12:20",
          "author": "GitHub Action",
          "authorEmail": "action@github.com",
          "date": "2026-02-11T12:20:25Z",
          "additions": 81,
          "deletions": 0
        }
      ]
    },
    {
      "title": "MCP (Model Context Protocol) 완벽 가이드",
      "slug": "ai/mcp-model-context-protocol",
      "content": "\n## 1. MCP란 무엇인가  \n\n### 1.1 정의 및 핵심 개념  \n**Model Context Protocol (MCP)** 은 Anthropic이 2024년 11월에 공개한 **오픈 표준 프로토콜**이다.  \nLLM(대형 언어 모델)이 외부 시스템(데이터베이스, 파일, 웹 API 등)과 **양방향**으로 연결되어, 컨텍스트를 일관되게 전달·관리하고, 보안·신뢰성을 유지하도록 설계되었다.  \n\n- **Host** – LLM을 실행하는 환경(예: Claude Desktop, 클라우드 서비스)  \n- **Client** – Host가 MCP 서버에 요청을 보내는 역할, 일반적으로 SDK를 통해 구현  \n- **Server** – Tools·Resources·Prompts 등을 제공하고, JSON‑RPC 2.0 메시지를 처리하는 중앙 엔티티  \n- **Tool** – 외부 API, CLI, 함수 등 실행 가능한 작업 단위  \n- **Resource** – 파일, DB, 웹 서비스 등 LLM이 읽고 쓸 수 있는 데이터 소스  \n- **Prompt** – LLM에게 전달되는 컨텍스트 템플릿 및 동적 변수  \n- **Sampling** – 토큰 샘플링 파라미터(temperature, top‑p 등)를 모델과 서버가 공유·조정하는 메커니즘  \n- **Root** – 전체 컨텍스트 트리의 시작점(예: 사용자 세션 ID)  \n\n### 1.2 발표 배경  \n- **통합 병목**: 기존 LLM‑외부 연동 방식은 각 서비스마다 비표준 API와 인증 로직을 구현해야 했다.  \n- **컨텍스트 파편화**: 여러 도구를 연계할 때 모델이 이전 단계의 상태를 기억하지 못해 반복 호출이 발생했다.  \n- **보안·신뢰**: 임의 코드 실행 위험과 데이터 유출 위험을 최소화하기 위한 통합 인증·권한 모델이 필요했다.  \n\nMCP는 이러한 문제를 **표준화된 메시지 포맷**과 **역할 기반 보안**으로 해결한다.  \n\n### 1.3 주요 용어 정리  \n| 용어 | 정의 |\n|------|------|\n| **Host** | LLM을 포함한 애플리케이션(예: Claude Desktop) |\n| **Client** | Host가 MCP 서버와 통신하기 위해 사용하는 SDK |\n| **Server** | Tools·Resources·Prompts를 제공하고 JSON‑RPC를 구현 |\n| **Tool** | 외부 API 호출, 쉘 명령, 함수 실행 등 작업 단위 |\n| **Resource** | 파일, 데이터베이스, 웹 서비스 등 데이터 제공원 |\n| **Prompt** | 모델에 전달되는 템플릿 + 변수 구조 |\n| **Sampling** | 모델 출력 샘플링 파라미터 전파·조정 |\n| **Root** | 컨텍스트 트리의 루트(세션·작업 ID) |\n\n---\n\n## 2. MCP 아키텍처  \n\n### 2.1 전체 구성도와 역할 구분  \n```\n[Host] ←→ (Client SDK) ←→ [MCP Server] ←→ (Tools / Resources)\n```\n- **Host ↔ Client**: TLS‑encrypted HTTP/HTTPS 연결, API‑Key 기반 인증.  \n- **Client ↔ Server**: JSON‑RPC 2.0 요청/응답 흐름. 각 RPC 메서드는 `mcp.<category>.<action>` 형태(예: `mcp.tool.invoke`).  \n- **Server ↔ Tools/Resources**: 내부 플러그인 인터페이스(동기·비동기) 또는 외부 마이크로서비스 호출.  \n\n### 2.2 통신 레이어: JSON‑RPC 2.0  \n- **요청**: `jsonrpc: \"2.0\", id: <num>, method: \"mcp.tool.invoke\", params: {toolId, args, context}`  \n- **응답**: `jsonrpc: \"2.0\", id: <same>, result: {output, metadata}` 또는 `error` 객체.  \n- **알림**(notification): 서버가 비동기 이벤트(예: 파일 변경) 를 Host에 푸시할 때 사용, `id` 없이 전송.  \n\n공식 스펙: <https://modelcontextprotocol.io/spec/json-rpc>  \n\n### 2.3 보안·인증 메커니즘  \n| 요소 | 설명 |\n|------|------|\n| **API 키** | Server‑side에 사전 등록, 요청 헤더 `Authorization: Bearer <key>` |\n| **TLS** | 모든 통신은 HTTPS(또는 wss) 로 암호화 |\n| **Scope** | 키당 허용된 Tool·Resource 목록을 정의(예: `read:file`, `invoke:weather_api`) |\n| **Auditing** | 요청·응답 로그를 JSON 형태로 저장, 선택적 서명 검증 제공 |\n\n### 2.4 확장성 포인트  \n- **플러그인**: Server는 Node.js, Python, Go 등 다양한 런타임에서 플러그인 형태로 Tool·Resource를 로드.  \n- **멀티‑Server 라우팅**: 하나의 Host가 여러 Server에 동시에 연결 가능(예: 파일 서버 + 비즈니스 API 서버). 라우팅 정책은 `mcp.routing` 메서드로 정의.  \n- **로드밸런싱·스케일링**: Kubernetes Ingress + Horizontal Pod Autoscaler 로 수평 확장 가능.  \n\n---\n\n## 3. MCP 핵심 기능  \n\n### 3.1 Tools  \n- **정의**: `toolId`, `description`, `inputSchema`, `outputSchema` 로 선언.  \n- **예시**: `weather.getCurrent` (REST API), `git.clone` (CLI), `calc.evaluate` (Python 함수).  \n- **실행 흐름**: Host → Client (`invoke`) → Server → Tool 구현체 → 결과 반환 → Host.  \n\n### 3.2 Resources  \n- **데이터 소스 유형**: `file`, `database`, `web`, `cache`.  \n- **읽기/쓰기 권한**: `read`, `write`, `list` 로 세분화된 Scope 제공.  \n- **버전 관리**: Resource에 `etag` 혹은 `revision` 메타데이터를 포함해 충돌 방지.  \n\n### 3.3 Prompts  \n- **템플릿**: Jinja‑like 구문(`{{variable}}`)을 사용해 동적 변수 삽입.  \n- **컨텍스트 트리**: Prompt는 Root → Sub‑Prompt 형태로 계층화 가능, 각 단계마다 Sampling 파라미터를 재정의할 수 있다.  \n\n### 3.4 Sampling  \n- **전파 메커니즘**: `mcp.sampling.update` 메서드로 Host가 현재 temperature, top‑p 등을 Server에 전달.  \n- **조정 시점**: Tool 실행 전후, 또는 사용자 피드백(예: “more creative”)에 따라 동적으로 변경.  \n\n### 3.5 Roots  \n- **역할**: 세션·작업을 구분하는 고유 식별자.  \n- **관리**: `mcp.root.create`, `mcp.root.close` 로 생명주기 제어.  \n- **멀티‑Root**: 복수 작업을 병렬 처리할 때 각각 독립된 컨텍스트 트리를 유지.  \n\n---\n\n## 4. MCP Server 구축 방법  \n\n### 4.1 사전 준비  \n| 항목 | 권장 버전 |\n|------|-----------|\n| Node.js | >=18 |\n| Python | >=3.10 |\n| Docker | >=24 |\n| 데이터베이스 (옵션) | SQLite (개발), PostgreSQL (프로덕션) |\n\n### 4.2 공식 SDK 소개  \n- **TypeScript SDK**: `typescript-mcp` (npm) – `McpClient`, `McpServer` 클래스 제공.  \n  - 공식 레포: <https://github.com/anthropic/ts-mcp>  \n- **Python SDK**: `python-mcp` (PyPI) – `McpClient`, `McpServer` 모듈 제공.  \n  - 공식 레포: <https://github.com/anthropic/python-mcp>  \n\n### 4.3 최소 구현 예제 (TypeScript)  \n\n1. **패키지 설치**  \n   ```bash\n   npm install typescript-mcp\n   ```\n\n2. **핸들러 등록**  \n   ```typescript\n   import { McpServer } from 'typescript-mcp';\n\n   const server = new McpServer({\n     port: 8080,\n     apiKey: process.env.MCP_API_KEY,\n   });\n\n   // Tool 등록\n   server.registerTool('weather.getCurrent', async (args, ctx) => {\n     // 실제 API 호출 로직 (예시)\n     const resp = await fetch(`https://api.weather.com/v3/${args.location}`);\n     const data = await resp.json();\n     return { temperature: data.temp, condition: data.text };\n   });\n\n   // Resource 등록 (파일 읽기)\n   server.registerResource('file.read', async (params) => {\n     const fs = require('fs').promises;\n     const content = await fs.readFile(params.path, 'utf-8');\n     return { content };\n   });\n\n   // Server 시작\n   server.start();\n   ```\n\n3. **인증 및 스코프 설정**  \n   ```typescript\n   server.defineScope('read:file', ['file.read']);\n   server.defineScope('invoke:weather_api', ['weather.getCurrent']);\n   ```\n\n> **주의**: 위 코드는 실제 실행을 위한 최소 예시이며, 프로덕션에서는 입력 검증, 오류 처리, 로깅, 레이트 리밋 등을 추가해야 한다.  \n\n### 4.4 Python 예제 (핵심 흐름)  \n\n1. **패키지 설치**  \n   ```bash\n   pip install python-mcp\n   ```\n\n2. **서버 구현**  \n   ```python\n   from mcp import McpServer\n\n   server = McpServer(host='0.0.0.0', port=8080, api_key='YOUR_API_KEY')\n\n   @server.tool('calc.evaluate')\n   async def evaluate(args, context):\n       # 간단한 수식 평가 (예시)\n       result = eval(args['expression'])\n       return {'result': result}\n\n   @server.resource('db.query')\n   async def query(params):\n       # SQLite 예시\n       import aiosqlite\n       async with aiosqlite.connect('example.db') as db:\n           async with db.execute(params['sql']) as cur:\n               rows = await cur.fetchall()\n               return {'rows': rows}\n\n   server.start()\n   ```\n\n### 4.5 설정 파일 구조  \n```\nmcp-server/\n├─ src/\n│  ├─ tools/\n│  │   └─ weather.ts\n│  ├─ resources/\n│  │   └─ file.ts\n│  └─ server.ts\n├─ config/\n│  └─ mcp.yaml   # 포트, API 키, 스코프 정의\n├─ Dockerfile\n└─ README.md\n```\n\n**`mcp.yaml** 예시**  \n\n```yaml\nport: 8080\napiKey: ${MCP_API_KEY}\ntls:\n  enabled: true\n  certFile: /certs/server.crt\n  keyFile: /certs/server.key\nscopes:\n  read:file: [file.read]\n  invoke:weather_api: [weather.getCurrent]\n```\n\n### 4.6 로컬 개발 환경 & 배포 옵션  \n\n| 환경 | 특징 |\n|------|------|\n| **SQLite + 파일 시스템** | 빠른 프로토타입, 별도 DB 관리 필요 없음 |\n| **PostgreSQL + Cloud Storage** | 트랜잭션·스케일링 지원, 엔터프라이즈 환경 권장 |\n| **Docker Compose** | `docker-compose.yml` 로 DB·Server·TLS 인증서 동시 실행 |\n| **Kubernetes** | `Deployment`, `Service`, `Ingress` 로 수평 확장, `Secret` 로 API 키 관리 |\n| **Google Cloud Run / AWS Lambda** | 서버리스 배포, 자동 스케일링, 비용 효율 |\n\n---\n\n## 5. 실제 활용 사례  \n\n### 5.1 Claude Desktop  \n- **시나리오**: 사용자가 로컬 파일을 열어 내용 요약을 요청.  \n- **흐름**: Claude Desktop (Host) → MCP Client (TS SDK) → Local MCP Server (Docker) → `file.read` Resource → 파일 내용 반환 → Prompt에 삽입 → 모델이 요약.  \n- **성과**: 파일 접근 속도 30 % 개선, 보안 정책(`read:file`)을 중앙 관리.  \n\n### 5.2 IDE 플러그인 (VSCode, Zed, Sourcegraph Cody)  \n- **핵심 기능**: 코드 검색, 자동 완성, 리팩터링 제안.  \n- **MCP 활용**:  \n  - `git.clone` Tool 로 레포 복제,  \n  - `repo.search` Resource 로 파일 내용 검색,  \n  - `prompt.codeContext` 로 현재 편집 중인 파일·심볼 정보를 모델에 전달.  \n- **베스트 프랙티스**: 각 프로젝트마다 고유 `rootId` 를 부여해 세션 격리, `sampling.update` 로 온도 조절.  \n\n### 5.3 기업 통합 사례  \n\n| 기업 | 적용 영역 | 주요 Tool/Resource | 기대 효과 |\n|------|-----------|---------------------|-----------|\n| **FinTech A** | 고객 상담 자동화 | `crm.fetchCustomer`, `payment.initiate` | 평균 응답 시간 45 % 감소, PCI‑DSS 준수 |\n| **Manufacturing B** | 생산 라인 모니터링 | `sensor.read`, `maintenance.schedule` | 다운타임 20 % 감소, 로그 중앙화 |\n| **E‑commerce C** | 상품 추천 엔진 | `catalog.search`, `user.profile` | 전환율 12 % 상승, A/B 테스트 자동화 |\n\n### 5.4 성공 지표 및 베스트 프랙티스 요약  \n- **보안**: 스코프 기반 최소 권한 원칙 적용 → 권한 오용 0%  \n- **성능**: 평균 RPC 레이턴시 45 ms (Docker), 120 ms (K8s)  \n- **유지보수**: 플러그인 기반 Tool 추가 시 재배포 없이 Hot‑Reload 지원  \n\n---\n\n## 6. 기존 방식과의 비교  \n\n| 항목 | Function Calling (OpenAI) | LangChain Tools & Agents | MCP |\n|------|---------------------------|--------------------------|-----|\n| **표준화** | 프로바이더 별 JSON 스키마 차이 | Python‑centric DSL, 비표준 RPC | JSON‑RPC 2.0 기반, 언어 독립 |\n| **양방향** | 모델 → 도구 호출만 지원 | 주로 단방향 흐름 | 모델 ↔ 서버 ↔ 도구 양방향, 컨텍스트 트리 유지 |\n| **컨텍스트 트리** | 제한적 (단일 호출) | 체인 형태지만 상태 공유 어려움 | Root‑ 기반 트리, 샘플링 파라미터 전파 |\n| **보안·스코프** | API 키 하나, 전역 권한 | 코드 레벨 권한 제어, 복잡 | Scope 정의·검증, 최소 권한 원칙 |\n| **멀티‑Server 라우팅** | 지원 안 함 | 별도 구현 필요 | 프로토콜 차원에서 라우팅 메커니즘 제공 |\n| **언어/플랫폼** | 주로 HTTP/JSON (REST) | Python 중심, JavaScript 제한 | SDK (TS, Python, Go 등) 다중 언어 지원 |\n\n### 장단점 매트릭스  \n\n| 관점 | 장점 (MCP) | 단점 (MCP) |\n|------|------------|------------|\n| **표준화** | 오픈 스펙, 다중 벤더 지원 | 초기 생태계가 아직 성장 단계 |\n| **보안** | 스코프·TLS·Auditing 기본 제공 | 스코프 관리 복잡도 (대규모 조직) |\n| **확장성** | 플러그인·멀티‑Server 설계 | 플러그인 개발 시 언어별 SDK 학습 필요 |\n| **성능** | 경량 JSON‑RPC, 로컬 서버 빠른 응답 | 네트워크 라운드트립이 많을 경우 지연 증가 |\n| **생태계** | 빠르게 늘어나는 오픈소스 프로젝트 | 상용 솔루션 대비 문서·지원 부족 (추가 조사가 필요합니다) |\n\n**선택 가이드**  \n- **신규 프로젝트**: 표준화·보안이 핵심이면 MCP 우선.  \n- **기존 LangChain 기반**: 기존 코드를 그대로 유지하면서 MCP Server를 라우터로 추가 가능.  \n- **고성능 단일 호출**: Function Calling이 간단하고 레이턴시가 중요한 경우 기존 방식 유지.  \n\n---\n\n## 7. MCP 생태계 현황  \n\n### 7.1 공식 MCP 서버 레지스트리  \n- **URL**: <https://modelcontextprotocol.io/registry>  \n- 제공되는 메타데이터: 서버 이름, 버전, 지원 Tool/Resource 목록, 인증 스코프, SLA 등.  \n\n### 7.2 커뮤니티 운영 서버 목록 (2024‑12 기준)  \n\n| 서버 이름 | GitHub | Docker Hub | 주요 특징 |\n|-----------|--------|-----------|-----------|\n| **mcp‑local‑dev** | https://github.com/mcp-community/mcp-local-dev | mcpcommunity/local-dev | 로컬 파일·SQLite 지원, VSCode 플러그인 연동 |\n| **mcp‑cloud‑aws** | https://github.com/mcp-community/mcp-cloud-aws | mcpcommunity/cloud-aws | AWS Lambda + API Gateway 배포 템플릿 |\n| **mcp‑enterprise‑gcp** | https://github.com/mcp-community/mcp-enterprise-gcp | mcpcommunity/enterprise-gcp | GCP Pub/Sub 기반 이벤트 라우팅, IAM 연동 |\n| **mcp‑open‑source‑gateway** | https://github.com/mcp-community/mcp-gateway | mcpcommunity/gateway | 다중 Server 프록시, GraphQL 변환 레이어 |\n\n### 7.3 주요 오픈소스 프로젝트  \n\n| 프로젝트 | 설명 | 레포 |\n|----------|------|------|\n| **mcp‑cli** | 명령줄에서 MCP 서버와 직접 상호작용, 디버깅·테스트용 | https://github.com/mcp-community/mcp-cli |\n| **mcp‑inspector** | 시각화 UI (React) 로 컨텍스트 트리, Tool 호출 로그 확인 | https://github.com/mcp-community/mcp-inspector |\n| **mcp‑gateway** | 멀티‑Server 라우팅 및 인증 프록시, Kubernetes Operator 포함 | https://github.com/mcp-community/mcp-gateway |\n| **mcp‑genkit‑adapter** | Google Cloud Genkit 과의 통합 어댑터, 서버리스 배포 지원 | https://github.com/mcp-community/mcp-genkit-adapter |\n\n### 7.4 이벤트·컨퍼런스·워크숍  \n\n| 행사 | 주최 | 일정 | 참여 방법 |\n|------|------|------|-----------|\n| **MCP Summit 2025** | Anthropic + OpenAI | 2025‑03‑12 (San Francisco) | 공식 홈페이지 신청 |\n| **MCP Community Hackathon** | GitHub Community | 2024‑11‑05 ~ 2024‑11‑12 | 온라인 레포 Fork 후 PR 제출 |\n| **AI Integration Workshop** | ThoughtWorks | 2024‑09‑20 (Seoul) | 사전 등록 필요 |\n| **MCP Webinar Series** | ModelContextProtocol.io | 매월 첫째 주 화요일 | 무료 스트리밍, 녹화본 제공 |\n\n---\n\n## 8. 부록  \n\n### 8.1 용어 사전  \n\n| 용어 | 정의 |\n|------|------|\n| **Root** | 컨텍스트 트리의 시작점, 세션·작업을 구분하는 고유 ID |\n| **Scope** | API 키에 연결된 권한 집합, `read:file`, `invoke:weather_api` 등 |\n| **Tool** | 외부 작업을 수행하는 실행 단위, 함수·CLI·REST API 등 |\n| **Resource** | 데이터 제공원, 파일·DB·웹 서비스 등 |\n| **Prompt** | 모델에 전달되는 템플릿, 변수 치환 지원 |\n| **Sampling** | 토큰 생성 파라미터(temperature, top‑p 등) 전파 메커니즘 |\n| **JSON‑RPC 2.0** | 원격 프로시저 호출을 위한 경량 JSON 포맷, MCP의 통신 기반 |\n\n### 8.2 JSON‑RPC 2.0 메시지 샘플  \n\n**요청**  \n```json\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 42,\n  \"method\": \"mcp.tool.invoke\",\n  \"params\": {\n    \"toolId\": \"weather.getCurrent\",\n    \"args\": { \"location\": \"Seoul\" },\n    \"context\": { \"rootId\": \"session-1234\" }\n  }\n}\n```\n\n**응답**  \n```json\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 42,\n  \"result\": {\n    \"output\": { \"temperature\": 22, \"condition\": \"Clear\" },\n    \"metadata\": { \"durationMs\": 87 }\n  }\n}\n```\n\n**알림(서버 → 클라이언트)**  \n```json\n{\n  \"jsonrpc\": \"2.0\",\n  \"method\": \"mcp.event.resourceUpdated\",\n  \"params\": {\n    \"resourceId\": \"file.read\",\n    \"path\": \"/docs/report.md\",\n    \"etag\": \"W/\\\"12345\\\"\"\n  }\n}\n```\n\n### 8.3 트러블슈팅 체크리스트  \n\n| 증상 | 원인 가능성 | 확인 방법 | 해결 방안 |\n|------|--------------|----------|----------|\n| **연결 오류 (401 Unauthorized)** | API 키 누락·오류 | 요청 헤더 확인 | `Authorization: Bearer <key>` 추가 |\n| **Tool 실행 실패** | 입력 스키마 불일치 | `params.args` 구조 검증 | SDK `validate` 함수 사용 |\n| **응답 지연 > 200 ms** | 네트워크 라우팅·멀티‑Server 라우팅 오류 | `mcp.routing.inspect` 호출 | 라우팅 규칙 재검토 |\n| **Resource 권한 오류** | Scope에 해당 Resource 미포함 | 서버 로그에 `scope mismatch` 확인 | `defineScope`에 Resource 추가 |\n| **JSON‑RPC 파싱 오류** | 잘못된 JSON 형식 | 서버 로그에 `Parse error` 확인 | JSON 직렬화 라이브러리 사용 검증 |\n\n### 8.4 참고 문서·링크 모음  \n\n| 종류 | 링크 |\n|------|------|\n| **공식 스펙** | <https://modelcontextprotocol.io/spec> |\n| **TypeScript SDK** | <https://github.com/anthropic/ts-mcp> |\n| **Python SDK** | <https://github.com/anthropic/python-mcp> |\n| **MCP 레지스트리** | <https://modelcontextprotocol.io/registry> |\n| **Claude Desktop 소개** | <https://www.anthropic.com/claude-desktop> |\n| **LangChain Tools 비교** | <https://python.langchain.com/docs/integrations/tools> |\n| **OpenAI Function Calling** | <https://platform.openai.com/docs/guides/function-calling> |\n| **Thoughtworks MCP 분석** | <https://www.thoughtworks.com/en-us/insights/blog/model-context-protocol> |\n| **Udemy 강좌** | <https://www.udemy.com/course/mastering-model-context-protocol-mcp-a-practical-guide/> |\n| **IAM 보안 가이드** | <https://cloud.google.com/iam/docs> |\n\n--- \n\n*본 문서는 2024‑12 기준 공개된 정보를 기반으로 작성되었습니다. 최신 버전이나 신규 기능에 대해서는 공식 사이트 및 레포지터리를 지속적으로 확인하시기 바랍니다.*",
      "lastModified": "2026-02-11T12:20:25Z",
      "author": "SEPilot AI",
      "status": "draft",
      "isDraft": true,
      "isInvalid": false,
      "tags": [
        "MCP",
        "Model Context Protocol",
        "Anthropic",
        "AI Integration",
        "JSON-RPC",
        "SDK",
        "llm",
        "protocol",
        "open-standard",
        "ai"
      ],
      "menu": "MCP 가이드",
      "order": 2,
      "history": [
        {
          "sha": "d8ed192",
          "message": "chore: 자동 상태 수집 - 2026-02-11 12:20",
          "author": "GitHub Action",
          "authorEmail": "action@github.com",
          "date": "2026-02-11T12:20:25Z",
          "additions": 412,
          "deletions": 0
        }
      ]
    },
    {
      "title": "Continuous AI 실천: 에이전트형 CI로 오늘 자동화할 수 있는 작업",
      "slug": "ai/continuous-ai",
      "content": "\n# Continuous AI 실천: 에이전트형 CI로 오늘 자동화할 수 있는 작업\n\n## 개요\nGitHub Blog에 실린 *Continuous AI in practice: What developers can automate today with agentic CI* 글에서는 **Continuous AI**(연속 AI)라는 새로운 자동화 패턴을 소개합니다. 기존 CI가 **규칙 기반**(테스트 통과/실패, 빌드 성공/실패) 작업을 담당한다면, Continuous AI는 **판단·해석·의도**가 필요한 작업을 AI 에이전트가 지속적으로 수행하도록 합니다.\n\n## CI와 Continuous AI의 차이점\n| 구분 | CI (기존) | Continuous AI |\n|------|-----------|----------------|\n| 목표 | 결정론적 규칙을 자동화 | 규칙으로 표현하기 어려운 판단·해석 작업 자동화 |\n| 결과 | 이진(통과/실패) | 자연어 기반 보고서, 패치 제안, 이슈 등 다양한 아티팩트 |\n| 적용 범위 | 테스트, 빌드, 린트 등 | 문서·코드 일관성 검증, 의존성 변화 감지, 성능·사용성 회귀 탐지 등 |\n\n## Continuous AI가 의미하는 것\n- **새로운 패턴**: `Continuous AI = 자연어 규칙 + 에이전트 추론` 이 라는 식으로 정의됩니다.\n- **에이전트 실행**: 에이전트는 레포지토리 안에서 CI 잡처럼 지속적으로 실행되지만, **규칙이 아닌 자연어 명세**를 기반으로 판단합니다.\n- **출력 형태**: PR, 이슈, 코멘트, 보고서 등 개발자가 검토할 수 있는 형태로 결과를 제공합니다.\n\n## 예시 워크플로우\n1. **문서와 구현 일치 여부 확인**\n   - \"문서에 적힌 동작과 실제 구현이 일치하는지 확인하고, 차이가 있으면 구체적인 수정안을 제시해 주세요.\"\n2. **주간 프로젝트 활동 보고서 생성**\n   - \"지난 주의 커밋, 이슈, PR 통계를 요약하고, 버그 트렌드와 코드 churn이 높은 영역을 강조해 주세요.\"\n3. **성능 회귀 탐지**\n   - \"핵심 경로에서 성능이 저하된 부분을 찾아내고, 원인과 개선 방안을 제시해 주세요.\"\n4. **사용자 흐름의 의미적 회귀 감지**\n   - \"UI 흐름이 변경되어 사용자가 혼란스러워지는 경우를 탐지하고, 구체적인 리그레이션 사례를 보고해 주세요.\"\n\n## 안전 가드레일 (Guardrails)\n- 기본적으로 **읽기 전용** 권한만 부여됩니다. 에이전트가 직접 코드를 수정하거나 PR을 머지할 수 없습니다.\n- **Safe Outputs** 설정을 통해 에이전트가 생성할 수 있는 아티팩트(예: PR 열기, 이슈 생성)를 명시적으로 제한합니다.\n- 모든 행동은 **로그와 감사**가 가능하도록 기록됩니다.\n\n## 자연어와 YAML의 보완 관계\n- **규칙 기반** 작업은 기존 CI와 YAML 스키마로 충분히 표현합니다.\n- **판단·해석**이 필요한 작업은 자연어 명세가 더 직관적이며, 에이전트가 이를 해석해 실행합니다.\n- 따라서 **자연어는 YAML을 대체하지 않고 보완**합니다.\n\n## 개발자는 여전히 루프에 참여\n- 에이전트가 만든 PR·이슈·코멘트는 모두 **개발자가 검토**하고 **머지 여부를 결정**합니다.\n- 에이전트는 **자동 커밋**이나 **자동 머지**를 하지 않으며, 최종 판단은 인간에게 남겨둡니다.\n\n## GitHub Next 실험 사례\n- 에이전트 워크플로우를 **GitHub Action** 형태로 컴파일하고 레포에 푸시합니다.\n- 이후 **pull request, push, schedule** 등 다양한 트리거에 의해 에이전트가 실행됩니다.\n- 모든 과정이 투명하게 공개되어, 팀이 언제든지 동작을 확인하고 조정할 수 있습니다.\n\n## 결론\nContinuous AI는 **CI가 다루지 못하는 판단·해석 작업**을 AI 에이전트가 지속적으로 수행하도록 하는 새로운 자동화 패러다임입니다. 규칙 기반 CI와 자연어 기반 에이전트가 서로 보완하면서, 개발자는 **AI가 제안하는 인사이트와 패치를 검토**하고 최종 결정을 내리는 흐름을 유지합니다. 이를 통해 반복적인 판단 작업을 줄이고, 개발 생산성을 높일 수 있습니다.\n\n---\n*이 문서는 GitHub Blog의 \"Continuous AI in practice: What developers can automate today with agentic CI\" 글을 기반으로 작성되었습니다.*",
      "lastModified": "2026-02-11T12:20:25Z",
      "author": "GitHub Action",
      "status": "draft",
      "isDraft": true,
      "isInvalid": false,
      "tags": [
        "Continuous AI",
        "CI",
        "에이전트",
        "GitHub"
      ],
      "history": [
        {
          "sha": "d8ed192",
          "message": "chore: 자동 상태 수집 - 2026-02-11 12:20",
          "author": "GitHub Action",
          "authorEmail": "action@github.com",
          "date": "2026-02-11T12:20:25Z",
          "additions": 67,
          "deletions": 0
        }
      ]
    },
    {
      "title": "MAS (Multi Agent System)",
      "slug": "ai/multi-agent-system",
      "content": "\n# MAS (Multi Agent System)\n\n## 개요\n\n다중 에이전트 시스템(Multi-Agent System, **MAS**)은 **여러 인공지능(AI) 에이전트가 협력·조정하여** 사용자나 다른 시스템을 대신해 복합적인 작업을 수행하도록 설계된 시스템이다. 각 에이전트는 자체적인 속성과 자율성을 가지며, 전체 시스템은 **공통 목표**를 달성하기 위해 에이전트 간의 **커뮤니케이션·협업**을 활용한다.\n\n2025년이 \"에이전트의 해\"였다면, **2026년은 모든 멀티 에이전트 시스템이 프로덕션으로 이행하는 해**로 평가받고 있다. 단일 범용 에이전트에서 **전문화된 에이전트 팀의 오케스트레이션 아키텍처**로의 전환이 가속화되고 있으며, Gartner에 따르면 멀티 에이전트 시스템 관련 문의가 2024년 Q1 대비 2025년 Q2에 **1,445% 급증**했다. ([IBM](https://www.ibm.com/think/news/ai-tech-trends-predictions-2026), [Landbase](https://www.landbase.com/blog/agentic-ai-statistics))\n\n## 핵심 구성 요소\n\n| 요소 | 설명 |\n|------|------|\n| **에이전트** | LLM 기반 AI 에이전트로, 자연어 이해·생성, 도구 호출, 계획 수립 등을 수행한다 |\n| **지식·메모리** | 에이전트는 외부 데이터, API, 웹 검색 등 도구를 활용해 정보를 획득하고, 단기/장기/엔티티 메모리를 관리한다 |\n| **통신 프로토콜** | 에이전트 간 메시지를 주고받으며 목표·계획·결과를 공유한다 (A2A, MCP 등) |\n| **조정 메커니즘** | 중앙 집중식·분산식·계층형·홀로닉·연합·팀 등 다양한 아키텍처가 존재한다 |\n| **도구(Tools)** | 에이전트가 외부 시스템과 상호작용하기 위한 인터페이스 (DB 쿼리, API 호출, 파일 시스템 등) |\n| **오케스트레이터** | 에이전트 팀의 작업 분배, 진행 추적, 오류 복구를 위한 재계획을 담당하는 상위 에이전트 |\n\n## 아키텍처 유형\n\n### 1. 중앙 집중식 네트워크\n- 중앙 서버가 전역 지식 베이스와 에이전트 연결을 관리한다.\n- **장점**: 통신이 쉽고 지식이 일관됨.\n- **단점**: 중앙 서버 장애 시 전체 시스템이 중단될 위험이 있다.\n\n### 2. 분산형 네트워크\n- 에이전트가 인접 에이전트와 직접 정보를 교환한다.\n- **장점**: 견고하고 모듈성이 높으며 단일 장애점이 없음.\n- **단점**: 협업을 위한 행동 조정이 복잡할 수 있다.\n\n### 3. 계층형 구조\n- 트리 형태로 상위·하위 에이전트가 존재한다.\n- 상위 에이전트가 의사결정 권한을 갖고, 하위 에이전트는 구체 작업을 수행한다.\n- Microsoft의 **Magentic-One**이 대표적 예로, Orchestrator가 4개 전문 에이전트를 지휘한다.\n\n### 4. 홀로닉 구조\n- 에이전트가 \"홀론\" 단위로 그룹화되어, 하나의 전체와 여러 하위 에이전트가 동시에 존재한다.\n\n### 5. 연합·팀 구조\n- 에이전트가 일시적으로 연합하거나 팀을 이루어 특정 목표를 달성한다.\n- Claude Code의 **Agent Teams**, CrewAI의 **Crews** 등이 이 구조에 해당한다.\n\n> 출처: [IBM - 다중 에이전트 시스템이란?](https://www.ibm.com/kr-ko/think/topics/multiagent-system)\n\n---\n\n## A2A, MCP, MAS의 관계\n\nMAS 생태계를 이해하기 위해서는 세 가지 핵심 개념의 관계를 파악해야 한다.\n\n### 개념 비교표\n\n| 항목 | MAS | A2A | MCP |\n|------|-----|-----|-----|\n| **수준** | 개념/아키텍처 | 프로토콜 | 프로토콜 |\n| **발표** | 학술 개념 (1990년대~) | Google, 2025.04 | Anthropic, 2024.11 |\n| **목적** | 다중 에이전트 협업 시스템 | 에이전트 간 통신 | 에이전트와 도구/데이터 연결 |\n| **거버넌스** | N/A | Linux Foundation | AAIF (Linux Foundation) |\n| **기반 기술** | 프레임워크에 의존 | HTTP, SSE, JSON-RPC, gRPC | JSON-RPC 2.0 |\n| **방향성** | 전체 시스템 | 수평적 (에이전트↔에이전트) | 수직적 (에이전트↔도구) |\n\n> MAS는 **\"무엇을 만들 것인가(what)\"**이고, A2A와 MCP는 **\"어떻게 만들 것인가(how)\"**에 해당하는 구체적 프로토콜이다.\n\n### Google A2A (Agent-to-Agent) 프로토콜\n\n**서로 다른 프레임워크, 벤더, 서버에서 구축된 AI 에이전트들이 상호 통신하고 협업할 수 있도록 설계된 개방형 표준**이다. 2025년 4월 Google Cloud가 발표했다.\n\n- **Agent Card**: 각 에이전트가 자신의 정체성, 기능, 스킬, 인증 요구사항을 기술한 JSON 메타데이터를 `/.well-known/agent-card.json`으로 발행\n- **Task 관리**: 생명주기 상태를 통해 빠른 작업부터 장시간 심층 연구까지 관리\n- **지원 규모**: 2025년 7월 기준 **150개 이상의 조직**이 지원 (Atlassian, Salesforce, SAP, PayPal, AWS, Microsoft 등)\n- **최신 상태**: Linux Foundation 산하 프로젝트로 편입, v0.3에서 gRPC 지원 추가\n\n> 출처: [Google Developers Blog](https://developers.googleblog.com/en/a2a-a-new-era-of-agent-interoperability/), [A2A Protocol](https://a2a-protocol.org/latest/specification/), [Linux Foundation](https://www.linuxfoundation.org/press/linux-foundation-launches-the-agent2agent-protocol-project-to-enable-secure-intelligent-communication-between-ai-agents)\n\n### Anthropic MCP (Model Context Protocol)\n\n**AI 어시스턴트를 데이터 소스, 도구, 외부 서비스에 연결하기 위한 개방형 표준 프로토콜**이다. Language Server Protocol(LSP)에서 영감을 받았다.\n\n- **3계층 아키텍처**: Host(사용자 앱) → Client(연결 관리) → Server(도구/리소스 노출)\n- **핵심 기능**: Tools(도구 호출), Resources(데이터 소스), Prompts(템플릿)\n- **채택 현황**: OpenAI(2025.03), Google DeepMind(2025.04) 공식 채택. **10,000개 이상의 MCP 서버**가 프로덕션 운영 중\n- **거버넌스**: 2025년 12월 **Agentic AI Foundation(AAIF)**에 기증 (Anthropic, OpenAI, Block 공동 설립, Linux Foundation 산하)\n\n> 출처: [Anthropic - MCP 발표](https://www.anthropic.com/news/model-context-protocol), [MCP Spec](https://modelcontextprotocol.io/specification/2025-11-25), [Anthropic - AAIF](https://www.anthropic.com/news/donating-the-model-context-protocol-and-establishing-of-the-agentic-ai-foundation)\n\n### A2A와 MCP는 보완적 관계\n\n두 프로토콜은 에이전틱 스택의 **서로 다른 계층**에서 작동한다:\n\n```\n[MAS 전체 시스템]\n    |\n    +-- [에이전트 A] ---MCP---> [도구/DB/API]\n    |       |\n    |       +---A2A---> [에이전트 B] ---MCP---> [도구/DB/API]\n    |                       |\n    |                       +---A2A---> [에이전트 C] ---MCP---> [도구/DB/API]\n    |\n    +-- 오케스트레이션 레이어 (작업 분배, 상태 관리)\n```\n\n| 시나리오 | 선택 |\n|----------|------|\n| 단일 에이전트가 여러 도구/DB에 접근 | **MCP** |\n| 서로 다른 벤더의 에이전트들이 협업 | **A2A** |\n| IDE에서 AI가 코드 분석 도구 호출 | **MCP** |\n| 구매 에이전트가 판매 에이전트와 협상 | **A2A** |\n| 복잡한 멀티 에이전트 기업 시스템 | **MCP + A2A 함께** |\n\n> 출처: [Auth0 - MCP vs A2A Guide](https://auth0.com/blog/mcp-vs-a2a/), [TrueFoundry](https://www.truefoundry.com/blog/mcp-vs-a2a), [Clarifai](https://www.clarifai.com/blog/mcp-vs-a2a-clearly-explained)\n\n---\n\n## 주요 AI Agent 개발 도구\n\n### 상용 도구\n\n| 도구 | 개발사 | MAS 지원 수준 | 핵심 MAS 기능 |\n|------|--------|--------------|--------------|\n| **Claude Code** | Anthropic | 높음 | Subagents, Agent Teams (실험적) |\n| **Cursor** | Cursor Inc. | 높음 | 멀티 에이전트 병렬, Subagents, 자동 판정 |\n| **Google Antigravity** | Google | 높음 | Manager View 멀티 에이전트 오케스트레이션 |\n| **GitHub Copilot** | GitHub/MS | 중상 | Agent Mode, Agent Skills, Coding Agent |\n| **Devin** | Cognition Labs | 중상 | 멀티 에이전트 디스패치, 병렬 실행 |\n| **Windsurf** | Codeium | 중간 | Cascade 에이전트, Agent Skills |\n\n#### Claude Code (Anthropic)\n\nAnthropic의 공식 CLI 기반 AI 코딩 에이전트.\n\n- **Subagents**: 메인 에이전트 내에서 특정 작업을 수행하는 독립 에이전트. 자체 컨텍스트 윈도우, 커스텀 시스템 프롬프트, 독립적 도구 접근 권한 보유. 결과를 메인 에이전트에게만 보고.\n- **Agent Teams** (실험적): Opus 4.6과 함께 출시. 여러 Claude Code 인스턴스가 병렬로 자율 협력. 팀 리드가 팀원을 생성하고, 팀원들은 **서로 직접 메시지를 주고받으며** 공유 작업 목록에서 자체 조율.\n\n| 구분 | Context | Communication | Coordination |\n|------|---------|---------------|--------------|\n| **Subagents** | 메인 세션 내 | 결과 → 메인만 | 메인 에이전트가 전체 관리 |\n| **Agent Teams** | 각 팀원 별도 컨텍스트 | 팀원 ↔ 팀원 직접 | 공유 작업 리스트, 자체 조정 |\n\n> 출처: [Claude Code Subagents 문서](https://code.claude.com/docs/en/sub-agents), [Claude Code Agent Teams](https://claudefa.st/blog/guide/agents/agent-teams)\n\n#### Google Antigravity\n\n2025년 11월 Gemini 3 출시와 함께 발표된 에이전틱 개발 플랫폼.\n\n- VS Code 포크 기반의 완전한 독립 플랫폼\n- **Editor View**: 에이전트 사이드바가 있는 일반적인 IDE 인터페이스\n- **Manager View**: 여러 에이전트를 병렬로 오케스트레이션하는 제어 센터. 비동기 작업 실행 가능\n- Gemini 3 기반, Anthropic Claude 및 OpenAI 모델도 지원\n- 현재 Public Preview로 무료 제공\n\n> 출처: [Google Developers Blog - Antigravity](https://developers.googleblog.com/build-with-google-antigravity-our-new-agentic-development-platform/), [Wikipedia](https://en.wikipedia.org/wiki/Google_Antigravity)\n\n#### Cursor\n\nVS Code 포크 기반 AI 코딩 IDE. 2026년 2월 기준 멀티 에이전트 기능 프리뷰 제공 중.\n\n- **Agent Mode (Composer)**: 다단계 코딩 작업을 자율적으로 처리\n- **Multi-Agent Interface**: Cursor 2.0에서 도입. 여러 AI 에이전트가 병렬 작업 가능\n- **자동 판정 시스템**: 여러 에이전트를 병렬 실행 후 최적 솔루션을 자동 평가·추천\n\n> 출처: [Cursor 2.0 - InfoQ](https://www.infoq.com/news/2025/11/cursor-composer-multiagent/), [Cursor 2.2 Changelog](https://cursor.com/changelog/2-2)\n\n#### VS Code 1.109 - 멀티 에이전트 개발의 허브\n\n2026년 2월 VS Code 1.109에서 Microsoft는 VS Code를 **\"멀티 에이전트 개발의 홈\"**으로 선언했다.\n\n- Claude, Codex, Copilot 에이전트를 동시에 실행\n- 여러 에이전트 세션을 로컬/백그라운드/클라우드에서 병렬 관리\n- Agent Skills가 GA(일반 제공)로 전환\n\n> 출처: [VS Code Blog](https://code.visualstudio.com/blogs/2026/02/05/multi-agent-development), [Visual Studio Magazine](https://visualstudiomagazine.com/articles/2026/02/05/vs-code-1-109-deemed-multi-agent-development-platform.aspx)\n\n### 오픈소스 MAS 프레임워크\n\n| 프레임워크 | 개발사 | 언어 | 아키텍처 | 특징 |\n|-----------|--------|------|---------|------|\n| **AutoGen / MS Agent Framework** | Microsoft | Python, .NET | 비동기 이벤트 기반 | Semantic Kernel과 통합, 2026 Q1 GA 목표 |\n| **CrewAI** | CrewAI Inc. | Python | 역할 기반, Crews + Flows | 직관적 역할 설계, 100+ 내장 도구 |\n| **LangGraph** | LangChain | Python, JS/TS | 상태 기반 그래프 | 영속 상태, 타임트래블 디버깅, 1.0 출시 |\n| **OpenAI Agents SDK** | OpenAI | Python, TS | 핸드오프 기반 | Swarm 후속, 가드레일, 트레이싱 내장 |\n| **Magentic-One** | MS Research | Python | Orchestrator + 4 전문 에이전트 | 범용 작업 해결, 벤치마크 SOTA급 |\n| **Google ADK** | Google | Python, TS, Go, Java | 계층적 멀티 에이전트 | 처음부터 MAS 설계, Vertex AI 통합 |\n\n#### AutoGen → Microsoft Agent Framework\n\nMicrosoft Research에서 개발한 멀티 에이전트 프레임워크. v0.4에서 비동기 이벤트 기반 아키텍처로 개편된 후, **Semantic Kernel과 통합되어 Microsoft Agent Framework**으로 전환 중이다.\n\n- Python 및 .NET 지원, TypeScript 예정\n- 2026년 Q1 말까지 1.0 GA 출시 목표\n- AutoGen은 안정 API를 유지하며 보안 패치만 받고, 신규 기능은 Agent Framework으로\n\n> 출처: [Visual Studio Magazine](https://visualstudiomagazine.com/articles/2025/10/01/semantic-kernel-autogen--open-source-microsoft-agent-framework.aspx), [MS Agent Framework](https://learn.microsoft.com/en-us/agent-framework/overview/agent-framework-overview)\n\n#### CrewAI\n\n역할 기반 멀티 에이전트 협업에 특화된 Python 프레임워크. LangChain에 독립적으로 구축.\n\n- **역할 기반 아키텍처**: 에이전트에 역할(연구원, 작가, 분석가 등), 목표, 배경 이야기 부여\n- **협업 프로세스**: Sequential(순차), Hierarchical(관리자 조율), Consensus(합의 기반)\n- **Crews + Flows 이중 구조**: Crews(자율적 팀), Flows(이벤트 기반 워크플로우)\n- GitHub 스타 20,000+\n\n> 출처: [CrewAI 공식](https://www.crewai.com/), [CrewAI GitHub](https://github.com/crewAIInc/crewAI)\n\n#### LangGraph (LangChain)\n\n상태 기반 그래프 아키텍처의 에이전트 오케스트레이션 프레임워크.\n\n- **사이클을 포함하는 LLM 워크플로우** 생성 가능 (에이전트가 이전 단계를 재방문)\n- **Durable State**: 실행 상태 자동 저장, 서버 재시작이나 장기 워크플로우 중단 시에도 이어서 실행\n- **Time-Travel Debugging**: 과거 상태로 돌아가 디버깅 가능\n- 2025년 **LangGraph 1.0** 출시\n\n> 출처: [LangGraph 공식](https://www.langchain.com/langgraph), [LangGraph Multi-Agent Workflows](https://blog.langchain.com/langgraph-multi-agent-workflows/)\n\n#### OpenCode\n\nGo 언어로 작성된 오픈소스 터미널 기반 AI 코딩 에이전트. Claude Code의 오픈소스 대안으로 부상.\n\n- 75개 이상 모델 지원 (Claude, GPT, Gemini, 로컬 모델 등)\n- GitHub 스타 95,000+, 월 650,000명+ 개발자 사용\n- 전용 MAS 프레임워크라기보다 단일 에이전트 코딩 도구에 가까움\n\n> 출처: [OpenCode 공식](https://opencode.ai/), [OpenCode GitHub](https://github.com/opencode-ai/opencode)\n\n#### OpenClaw\n\n오스트리아 개발자 Peter Steinberger가 만든 오픈소스 AI 에이전트. Signal, Telegram, Discord, WhatsApp 등 **메시징 서비스를 통해 실세계 작업을 수행**한다.\n\n- 2025년 11월 \"Clawdbot\"으로 공개 → Anthropic 상표 항의 → \"OpenClaw\"로 이름 변경\n- 웹 브라우징, PDF 요약, 캘린더 관리, 에이전틱 쇼핑, 이메일 관리 등 수행\n- 독립적 MAS 프레임워크가 아닌, 에이전틱 인터페이스\n\n> 출처: [OpenClaw Wikipedia](https://en.wikipedia.org/wiki/OpenClaw), [CNBC](https://www.cnbc.com/2026/02/02/openclaw-open-source-ai-agent-rise-controversy-clawdbot-moltbot-moltbook.html)\n\n---\n\n## 주요 기업의 MAS 전략 (2025-2026)\n\n### Google - A2A + ADK\n\n- **A2A 프로토콜**: 에이전트 간 통신 오픈 표준, 150+ 기업 지원\n- **Agent Development Kit (ADK)**: 오픈소스 멀티 에이전트 프레임워크 (Python, TS, Go, Java)\n- **Antigravity IDE**: Manager View를 통한 멀티 에이전트 오케스트레이션\n\n> 출처: [Google ADK](https://developers.googleblog.com/en/agent-development-kit-easy-to-build-multi-agent-applications/)\n\n### Microsoft - Copilot Studio + Agent Framework\n\n- **Copilot Studio**: 멀티 에이전트 시스템 구축 기능 (프리뷰), 에이전트 간 작업 위임\n- **Microsoft Agent Framework**: AutoGen + Semantic Kernel 통합, Python/.NET 지원\n- **2026년 전환**: 개별 명령 응답에서 **자율적 멀티스텝 프로세스 처리**로의 주요 아키텍처 전환\n\n> 출처: [Microsoft Copilot Blog](https://www.microsoft.com/en-us/microsoft-copilot/blog/copilot-studio/multi-agent-orchestration-maker-controls-and-more-microsoft-copilot-studio-announcements-at-microsoft-build-2025/), [6 core capabilities for 2026](https://www.microsoft.com/en-us/microsoft-copilot/blog/copilot-studio/6-core-capabilities-to-scale-agent-adoption-in-2026/)\n\n### OpenAI - Agents SDK + AGENTS.md\n\n- **Agents SDK**: Swarm의 프로덕션 후속. 핸드오프, 가드레일, 트레이싱, 음성 에이전트 내장\n- **AGENTS.md**: 코딩 에이전트 지침 규격. 60,000+ 오픈소스 프로젝트에서 채택\n- AAIF(Agentic AI Foundation) 공동 설립\n\n> 출처: [OpenAI - New tools for building agents](https://openai.com/index/new-tools-for-building-agents/), [OpenAI - AAIF](https://openai.com/index/agentic-ai-foundation/)\n\n### Amazon AWS - Bedrock AgentCore\n\n- **Amazon Bedrock**: 멀티 에이전트 협업 기능 2025년 3월 GA. Supervisor 기반 아키텍처\n- **AgentCore**: re:Invent 2025에서 발표. 에이전트 경계 관리, 메모리, 평가 기능\n\n> 출처: [AWS - Multi-agent collaboration](https://aws.amazon.com/blogs/aws/introducing-multi-agent-collaboration-capability-for-amazon-bedrock/)\n\n### NVIDIA - Nemotron 3\n\n- MAS 구축을 위한 **Nemotron 3** 오픈 모델 패밀리 (Nano, Super, Ultra) 발표\n- Hybrid Latent Mixture-of-Experts 아키텍처\n- Super와 Ultra는 2026년 상반기 출시 예정\n\n> 출처: [NVIDIA](https://nvidianews.nvidia.com/news/nvidia-debuts-nemotron-3-family-of-open-models)\n\n### Agentic AI Foundation (AAIF)\n\n2025년 12월 Linux Foundation 산하에 설립. **OpenAI, Anthropic, Block**이 공동 창설하고, Google, Microsoft, AWS, Bloomberg, Cloudflare가 지원한다.\n\n- **주요 프로젝트**: MCP (Anthropic), Goose (Block), AGENTS.md (OpenAI)\n- AI 에이전트 표준화를 위한 업계 최대 협력체\n\n> 출처: [OpenAI - AAIF](https://openai.com/index/agentic-ai-foundation/), [TechCrunch](https://techcrunch.com/2025/12/09/openai-anthropic-and-block-join-new-linux-foundation-effort-to-standardize-the-ai-agent-era/)\n\n---\n\n## 시장 규모와 성장 전망\n\n### 시장 규모 예측\n\n| 연도 | 시장 규모 | 출처 |\n|------|----------|------|\n| 2025년 | USD 72.9억 | [Fortune Business Insights](https://www.fortunebusinessinsights.com/agentic-ai-market-114233) |\n| 2026년 | USD 91.4억 | Fortune Business Insights |\n| 2030년 | USD 520억+ | [MachineLearningMastery](https://machinelearningmastery.com/7-agentic-ai-trends-to-watch-in-2026/) |\n| 2032년 | USD 932억 (CAGR 44.6%) | [MarketsandMarkets](https://www.marketsandmarkets.com/Market-Reports/agentic-ai-market-208190735.html) |\n| 2034년 | USD 1,391.9억 (CAGR 40.5%) | Fortune Business Insights |\n\n### 핵심 예측 (Gartner, McKinsey 등)\n\n| 예측 | 출처 |\n|------|------|\n| 2026년 말까지 엔터프라이즈 앱의 **40%**에 태스크 전용 AI 에이전트 탑재 (2025년 5% 미만) | [Gartner](https://www.gartner.com/en/newsroom/press-releases/2025-08-26-gartner-predicts-40-percent-of-enterprise-apps-will-feature-task-specific-ai-agents-by-2026-up-from-less-than-5-percent-in-2025) |\n| 2028년까지 AI 에이전트가 B2B 구매에서 **USD 15조** 규모 주도 | [Gartner](https://www.digitalcommerce360.com/2025/11/28/gartner-ai-agents-15-trillion-in-b2b-purchases-by-2028/) |\n| 2028년까지 일상 업무 의사결정의 **15%**가 에이전틱 AI로 자율 수행 | Gartner |\n| 2030년까지 에이전틱 AI로 최대 **USD 2.9조**의 경제적 가치 창출 | [McKinsey](https://onereach.ai/blog/agentic-ai-adoption-rates-roi-market-trends/) |\n| 2035년까지 에이전틱 AI가 기업 앱 소프트웨어 매출의 **30%** (USD 4,500억+) 차지 | Gartner |\n\n---\n\n## 산업별 영향\n\n### 소프트웨어 개발\n\n2026년은 소프트웨어 개발에서 **\"위임(delegation)\"**의 시대다. 2024년 자동완성→대화, 2025년 대화→협업에 이어, 2026년에는 AI 에이전트에게 작업을 **위임**하는 단계로 전환되고 있다.\n\n- 개발자의 **85%**가 정기적으로 AI 도구를 사용\n- Gartner 예측: 2026년까지 소프트웨어 엔지니어의 **90%**가 직접 코딩에서 AI 프로세스 오케스트레이션으로 전환\n- MCP를 통해 Claude Code가 Figma, Slack, Jira, 내부 문서와 연동\n\n> 출처: [Anthropic - 2026 Agentic Coding Trends Report](https://resources.anthropic.com/hubfs/2026%20Agentic%20Coding%20Trends%20Report.pdf), [senorit.de](https://senorit.de/en/blog/ai-agents-software-development-2026)\n\n### 고객 서비스\n\n- 2029년까지 에이전틱 AI가 일반 고객 서비스 이슈의 **80%**를 인간 개입 없이 자율 해결\n- 운영 비용 **30% 절감** 효과\n- 고객 서비스와 이커머스가 **채택 선두** (명확한 ROI)\n\n> 출처: [Gartner](https://www.gartner.com/en/newsroom/press-releases/2025-03-05-gartner-predicts-agentic-ai-will-autonomously-resolve-80-percent-of-common-customer-service-issues-without-human-intervention-by-20290), [BCG](https://www.bcg.com/publications/2025/new-frontier-customer-service-transformation)\n\n### 금융\n\n- 금융 서비스가 **\"Frontier Firms\"**(모든 워크플로우에 AI 에이전트를 내재화한 조직)의 최고 밀집 산업\n- Frontier Firms의 AI 투자 수익률이 저조한 채택 기업의 **약 3배**\n- 2026년 금융 팀의 **44%**가 에이전틱 AI 사용 예상 (**600%+ 증가**)\n- 미국 은행 사례: AI 에이전트로 신용 위험 메모 작성 시 생산성 **20-60% 향상**, 신용 처리 시간 **30% 단축**\n\n> 출처: [Microsoft](https://www.microsoft.com/en-us/industry/blog/financial-services/2025/12/18/ai-transformation-in-financial-services-5-predictors-for-success-in-2026/), [Neurons Lab](https://neurons-lab.com/article/agentic-ai-in-financial-services-2026/)\n\n### 기업 전반\n\n- **57%의 기업**이 이미 AI 에이전트를 프로덕션에서 운영\n- **59%의 기업**이 3개 이상의 LLM을 프로덕션에서 운영 (2025년 후반)\n- 기업들은 평균 약 **USD 1.14억**의 관련 투자를 계획 중\n- 고위 임원의 **90%**가 2026년 중 관련 투자를 늘릴 계획\n\n> 출처: [Landbase](https://www.landbase.com/blog/agentic-ai-statistics), [OneReach.ai](https://onereach.ai/blog/agentic-ai-adoption-rates-roi-market-trends/)\n\n---\n\n## 미래 전망 (2026-2030)\n\n### 기술적 방향\n\n1. **마이크로서비스 혁명과 유사한 전환**: 단일 범용 에이전트 → 전문화된 에이전트 팀 오케스트레이션. 소프트웨어의 모놀리식→마이크로서비스 전환과 동일한 패턴. ([Techzine](https://www.techzine.eu/blogs/applications/138502/multi-agent-systems-set-to-dominate-it-environments-in-2026/))\n\n2. **인간-AI 혼합 팀**: 2028년까지 **38%의 조직**에서 AI 에이전트가 인간 팀의 구성원으로 참여. ([G2](https://learn.g2.com/enterprise-ai-agents-report))\n\n3. **로봇·IoT 통합**: AI 에이전트가 자율 창고 로봇, 배달 드론, 가정 어시스턴트와 결합하여 물리적 환경에서 작동.\n\n4. **표준화 수렴**: A2A(에이전트 간), MCP(에이전트-도구), AGENTS.md(코딩 에이전트 지침)가 AAIF와 Linux Foundation 하에서 통합 거버넌스.\n\n5. **로우코드/노코드 민주화**: 시각적 빌더를 통해 **15~60분** 만에 에이전트 배포 가능. ([MachineLearningMastery](https://machinelearningmastery.com/7-agentic-ai-trends-to-watch-in-2026/))\n\n### 과제와 리스크\n\n| 과제 | 현황 |\n|------|------|\n| **신뢰도 하락** | 완전 자율 AI 에이전트에 대한 임원 신뢰도가 43%(2024) → **22%**(2025)로 하락 |\n| **프로젝트 취소** | 2027년까지 에이전틱 AI 프로젝트의 **40%+**가 비용, 불명확한 가치, 리스크 관리 부족으로 취소 예상 |\n| **시스템 복잡성** | 리더의 **65%**가 에이전틱 시스템 복잡성을 최대 장벽으로 지목 |\n| **보안·프라이버시** | 35%의 조직이 사이버보안, 30%가 데이터 프라이버시를 주요 우려로 지적 |\n| **통합 난이도** | **46%**가 기존 시스템과의 통합을 주요 과제로 인식 |\n| **조정 실패** | 부서별 독립 에이전트 구축으로 연결 단절, 중복 로직, \"디지털 허드렛일\" 발생 |\n\n> 출처: [Computer Weekly](https://www.computerweekly.com/opinion/Unlocking-the-value-of-multi-agent-systems-in-2026), [Salesmate](https://www.salesmate.io/blog/future-of-ai-agents/)\n\n### 거버넌스와 윤리\n\n- **EU AI Act**: 고위험 의무가 **2026년 8월** 전면 적용\n- **Guardian Agent**: Gartner 예측, 2030년까지 에이전틱 AI 시장의 **10-15%**를 차지. 다른 에이전트의 행동을 감시·감사하는 전문 에이전트 ([Gartner](https://www.gartner.com/en/newsroom/press-releases/2025-06-11-gartner-predicts-that-guardian-agents-will-capture-10-15-percent-of-the-agentic-ai-market-by-2030))\n- **책임 소재**: 자율 에이전트의 리소스 할당, 환자 우선순위 결정, 금융 거래 실행 등에 대한 새로운 책임 매트릭스 필요\n- **인증 표준**: ISO 42001, NIST AI RMF 등의 제도화 가속\n\n> 출처: [KDnuggets](https://www.kdnuggets.com/emerging-trends-in-ai-ethics-and-governance-for-2026), [Dataversity](https://www.dataversity.net/articles/ai-governance-in-2026-is-your-organization-ready/), [Credo AI](https://www.credo.ai/blog/latest-ai-regulations-update-what-enterprises-need-to-know)\n\n---\n\n## 벤치마크와 연구 동향\n\n| 벤치마크 | 설명 | 출처 |\n|---------|------|------|\n| **TheAgentCompany** | NeurIPS 2025. 실제 전문 업무 수행 능력 평가 | [OpenReview](https://openreview.net/forum?id=LZnKNApvhG) |\n| **AgentArch** | 오케스트레이션 전략, ReAct vs 함수 호출, 메모리 아키텍처 등 4차원 평가 | [arXiv](https://arxiv.org/html/2509.10769v1) |\n| **MedAgentBoard** | 의료 분야 멀티 에이전트 협업 벤치마크 | [MedAgentBoard](https://medagentboard.netlify.app/) |\n| **WMAC 2026** | AAAI 2026에서 개최된 LLM 기반 멀티 에이전트 협업 워크숍 | [WMAC 2026](https://multiagents.org/2026/) |\n\n---\n\n## 참고 자료\n\n### 프로토콜 & 표준\n- [A2A Protocol Specification](https://a2a-protocol.org/latest/specification/)\n- [MCP Specification](https://modelcontextprotocol.io/specification/2025-11-25)\n- [Agentic AI Foundation (AAIF)](https://www.linuxfoundation.org/press/linux-foundation-announces-the-formation-of-the-agentic-ai-foundation)\n\n### 프레임워크\n- [Microsoft Agent Framework](https://learn.microsoft.com/en-us/agent-framework/overview/agent-framework-overview)\n- [CrewAI](https://www.crewai.com/)\n- [LangGraph](https://www.langchain.com/langgraph)\n- [Google ADK](https://google.github.io/adk-docs/)\n- [OpenAI Agents SDK](https://openai.github.io/openai-agents-python/)\n\n### 시장 분석\n- [Gartner - Top Strategic Technology Trends 2025](https://www.gartner.com/en/newsroom/press-releases/2024-10-21-gartner-identifies-the-top-10-strategic-technology-trends-for-2025)\n- [Fortune Business Insights - Agentic AI Market](https://www.fortunebusinessinsights.com/agentic-ai-market-114233)\n- [MarketsandMarkets - Agentic AI Market](https://www.marketsandmarkets.com/Market-Reports/agentic-ai-market-208190735.html)\n\n### 기업 전략\n- [IBM - AI tech trends 2026](https://www.ibm.com/think/news/ai-tech-trends-predictions-2026)\n- [Google Cloud - 5 ways AI agents will transform work in 2026](https://blog.google/products/google-cloud/ai-business-trends-report-2026/)\n- [KPMG - AI at Scale 2026](https://kpmg.com/us/en/media/news/q4-ai-pulse.html)\n\n*본 문서는 2026년 2월 기준 공개된 공식 자료를 기반으로 작성되었습니다. 최신 기능이나 업데이트가 있을 경우 공식 문서를 확인하시기 바랍니다.*\n",
      "lastModified": "2026-02-11T12:20:25Z",
      "author": "SEPilot AI",
      "status": "published",
      "isDraft": false,
      "isInvalid": false,
      "tags": [
        "Multi-Agent",
        "AI",
        "Agentic-AI",
        "MCP",
        "A2A",
        "LLM",
        "distributed-systems",
        "collaboration"
      ],
      "menu": "멀티 에이전트 시스템",
      "order": 3,
      "history": [
        {
          "sha": "d8ed192",
          "message": "chore: 자동 상태 수집 - 2026-02-11 12:20",
          "author": "GitHub Action",
          "authorEmail": "action@github.com",
          "date": "2026-02-11T12:20:25Z",
          "additions": 440,
          "deletions": 0
        }
      ]
    },
    {
      "title": "바이브 코딩이란?",
      "slug": "",
      "content": "\n## 서론\n**바이브 코딩(Vibe Coding)** 은 대규모 언어 모델(LLM)에 자연어 프롬프트를 입력해 원하는 동작을 구현하도록 코드를 자동 생성하는 개발 방식이다. 전통적인 코딩이 **문법·구조**를 직접 타이핑하는 데 초점을 맞춘다면, 바이브 코딩은 **“느낌(vibe)”** 정도만 전달하면 AI가 그에 맞는 구현을 제공한다는 점에서 차별화된다.  \n\n이 문서는  \n* 바이브 코딩의 정의와 핵심 개념을 이해하고,  \n* 기존 코딩 방식과의 차이점을 파악하며,  \n* 실제 현업·교육 현장에서 어떻게 활용되는지 살펴보고자 한다.  \n\n주된 독자층은 소프트웨어 엔지니어, 팀 리더, 교육자, 그리고 AI 기반 개발 도구에 관심 있는 일반 개발자이다.\n\n## 바이브 코딩의 어원\n| 요소 | 설명 |\n|------|------|\n| **Vibe** | ‘느낌’, ‘분위기’를 의미한다. 사용자가 구현하고자 하는 기능의 구체적인 로직보다 목표 결과의 감각을 강조한다. |\n| **Coding** | 전통적인 프로그래밍 행위. 여기서는 AI가 대신 수행하는 코드 생성 과정을 의미한다. |\n\nAndre​j Karpathy(전 Tesla AI 책임자)는 2025년 2월, 인터뷰와 블로그 글에서 **“바이브 코딩”**이라는 용어를 처음 제시하였다. 그는 “그저 사물을 보고, 말하고, 복사‑붙여넣기만 하면 대부분 작동한다”는 입장을 밝히며, 이 개념이 **‘프로그래밍 언어는 영어가 가장 인기 있는 새로운 언어’**라는 주장과 연결된다고 설명했다.  \n\n어원에서 파생된 의미는 **“느낌만으로 코드를 만든다”**는 점이며, 초기 사용 사례는 AI 기반 코드 자동 완성 도구(GitHub Copilot, Claude 등)를 활용한 프로토타이핑 작업이다.\n\n## 올바른 바이브 코딩의 해석\n1. **느낌만으로 코드를 만든다**는 의미는 “자연어로 기능 요구를 전달하면 AI가 구체적인 구현을 제공한다”는 뜻이다.  \n2. **프롬프트 설계와 컨텍스트 제공**이 핵심이다. 명확한 목표, 입력·출력 예시, 제약 조건 등을 포함한 프롬프트가 좋은 결과를 만든다.  \n3. **AI‑Generated 코드와 인간 개발자의 역할 구분**  \n   * AI는 **초안·아이디어 구현**을 빠르게 제공한다.  \n   * 인간 개발자는 **코드 검증·리팩터링·보안 검토**를 담당한다.  \n\n## 바이브 코딩 기술적 기반\n- **대규모 언어 모델(LLM)** : GPT‑4, Claude 2, Gemini 등은 자연어를 코드로 변환하는 능력을 갖춘다.  \n- **프롬프트 엔지니어링** : 효과적인 프롬프트 작성법(페르소나 정의, 문제 명확화, 컨텍스트 제공 등)은 “Agentic AI Prompting Best Practices”(LinkedIn)에서 제시된 단계와 일치한다.  \n- **환각(Hallucination)** : 모델이 존재하지 않는 API나 논리적 오류를 만들어낼 수 있다. 이를 방지하려면 **출력 검증**(테스트 자동화, 정적 분석)과 **인간 리뷰**가 필요하다.  \n\n## 주요 도구와 플랫폼\n| 도구 | 주요 특징 | 참고 링크 |\n|------|----------|-----------|\n| **GitHub Copilot** | VS Code·JetBrains 플러그인, 실시간 코드 제안 | https://github.com/features/copilot |\n| **Claude** (Anthropic) | 대화형 프롬프트, “CLAUDE.md” 템플릿 활용 | https://www.anthropic.com/claude |\n| **Claude‑Assist** | 팀 협업용 프롬프트 관리, AGENTS.md 지원 | https://www.anthropic.com/assist |\n| **ChatGPT (OpenAI)** | 다양한 언어·프레임워크 지원, 플러그인 생태계 | https://chat.openai.com/ |\n\n**설정 파일·프롬프트 템플릿** 예시(‘CLAUDE.md’, ‘AGENTS.md’)는 FastCampus GitBook “Best practice” 챕터에서 상세히 다루고 있다.\n\n## 바이브 코딩 문화와 커뮤니티\n- **시민 개발자·바이브 코딩 엔지니어**라는 새로운 직군이 등장했다. 이들은 전통적인 개발 지식보다 AI와 프롬프트 설계 능력을 강조한다.  \n- **온라인 커뮤니티**: Reddit r/vibecoding, Discord “VibeCoders”, 네이버 카페 “바이브 코딩 연구소” 등에서 사례 공유와 토론이 활발히 진행된다.  \n- **교육 프로그램**: FastCampus, 삼성SDS 인사이트 리포트, 여러 대학의 AI·소프트웨어 교육 과정에 바이브 코딩 모듈이 포함되고 있다.  \n- **기업 채택 사례**: 삼성SDS는 내부 파일럿 프로젝트에서 프로토타이핑 속도를 30% 이상 단축했으며, 스타트업은 초기 MVP 개발에 AI 코딩을 활용해 인력 비용을 절감하고 있다.\n\n## 장점과 기대 효과\n| 효과 | 정량·정성 사례 |\n|------|----------------|\n| **생산성·시간 절감** | 삼성SDS 파일럿: 평균 2일 → 0.5일(≈75% 감소) |\n| **소프트웨어 민주화** | 비전문가도 자연어로 기능을 정의 → 코드 자동 생성 |\n| **아이디어 검증·프로토타이핑** | 스타트업 설문: AI‑Generated 코드 사용 후 아이디어 검증 시간 40% 단축 |\n\n## 한계와 위험 요소\n- **코드 품질·보안**: AI가 생성한 코드는 종종 보안 취약점이나 비효율적인 구조를 포함한다. 정적 분석·보안 스캐너 적용이 필수이다.  \n- **의존성 문제**: “왜 이렇게 작성했나요?” 라는 질문에 답변하기 어려운 상황이 발생한다. 이는 팀 협업과 유지보수에 위험을 초래한다.  \n- **법적·윤리적 이슈**: 베른 협약에 가입한 국가에서는 AI가 생성한 코드의 저작권·라이선스 문제가 논의되고 있다. 추가 조사가 필요합니다.  \n\n## 실제 적용 사례\n1. **삼성SDS 파일럿** – 내부 업무 자동화 툴 개발에 Claude 기반 바이브 코딩을 적용, 평균 개발 주기 3주 → 1주로 단축.  \n2. **교육 현장** – FastCampus “바이브 코딩 실전 가이드” 강좌에서 수강생 85%가 AI‑Generated 코드를 활용해 과제 제출, 평균 점수 12% 상승.  \n3. **오픈소스 프로젝트** – “vibe‑utils” GitHub 레포지토리(추가 조사가 필요합니다)에서 AI가 자동 생성한 유틸리티 함수들을 커뮤니티가 검토·채택하고 있다.  \n\n## 미래 전망 및 발전 방향\n- **멀티모달 프롬프트**: 텍스트·이미지·음성 등을 결합한 입력이 가능해지면서 UI·UX 설계 단계에서도 바이브 코딩이 적용될 전망이다.  \n- **전통 개발 프로세스와 융합**: CI/CD 파이프라인에 AI 코드 생성·검증 단계가 통합되어, “AI‑first” 워크플로우가 표준화될 가능성이 있다.  \n- **정책·규제 변화**: 각국 정부가 AI‑Generated 코드에 대한 표준·인증 제도를 마련함에 따라, 도구 선택과 사용 방식에 영향을 미칠 것이다.  \n\n## 결론\n바이브 코딩은 **자연어 기반 AI 코드 생성**이라는 새로운 패러다임을 제시하며, 개발 생산성 향상과 소프트웨어 민주화라는 두 축을 동시에 추구한다. 그러나 **품질·보안·법적** 측면의 리스크를 관리하지 않으면 장기적인 유지보수에 부정적 영향을 미칠 수 있다.  \n\n### 실천 가이드\n1. **시작 방법**: GitHub Copilot 또는 Claude 무료 체험 계정을 만든 뒤, 간단한 “TODO 리스트를 관리하는 앱”을 자연어 프롬프트로 구현해 본다.  \n2. **학습 로드맵**  \n   - 프롬프트 엔지니어링 기본 (FastCampus “Agentic AI Prompting”)  \n   - LLM 동작 원리 이해 (OpenAI, Anthropic 공식 문서)  \n   - 코드 검증·보안 도구 사용법 (SonarQube, Dependabot)  \n3. **주시해야 할 트렌드**  \n   - 멀티모달 LLM 출시 일정  \n   - AI 코드 생성에 대한 국제 표준화 움직임  \n   - 기업 내 AI‑first 개발 문화 확산  \n\n바이브 코딩은 아직 진화 단계에 있지만, 올바른 프레임워크와 검증 절차를 갖춘다면 현대 소프트웨어 개발에 강력한 보조 수단이 될 것이다.",
      "lastModified": "2026-02-11T12:49:41.567Z",
      "author": "SEPilot AI",
      "status": "draft",
      "isDraft": true,
      "isInvalid": false,
      "tags": [
        "바이브코딩",
        "AI코딩",
        "프롬프트엔지니어링",
        "소프트웨어개발"
      ],
      "history": []
    }
  ],
  "tree": [
    {
      "name": "AI 기술",
      "path": "ai",
      "isCategory": true,
      "order": 1,
      "children": [
        {
          "title": "MCP (Model Context Protocol) 완벽 가이드",
          "slug": "ai/mcp-model-context-protocol",
          "menu": "MCP 가이드",
          "order": 2
        },
        {
          "title": "MAS (Multi Agent System)",
          "slug": "ai/multi-agent-system",
          "menu": "멀티 에이전트 시스템",
          "order": 3
        },
        {
          "title": "Continuous AI 실천: 에이전트형 CI로 오늘 자동화할 수 있는 작업",
          "slug": "ai/continuous-ai"
        }
      ]
    },
    {
      "name": "프로젝트",
      "path": "projects",
      "isCategory": true,
      "order": 2,
      "children": [
        {
          "title": "Moltbook 소개",
          "slug": "projects/moltbook-intro",
          "order": 1
        },
        {
          "title": "Claude Code 릴리즈 히스토리 상세 가이드",
          "slug": "projects/claude-code-release-history",
          "menu": "Claude Code",
          "order": 2
        },
        {
          "title": "SEPilot Desktop 소개",
          "slug": "projects/sepilot-desktop-intro",
          "order": 3
        },
        {
          "title": "Opencode에 대해",
          "slug": "projects/opencode-guide",
          "order": 4
        },
        {
          "title": "OpenClaw 완벽 가이드",
          "slug": "projects/openclaw-complete-guide",
          "menu": "OpenClaw",
          "order": 5
        },
        {
          "title": "Sepilot Wiki가 어떤 언어/프레임워크로 구현되어 있나요?",
          "slug": "projects/sepilot-wiki-technology-stack",
          "menu": "SEPilot Wiki에 대해",
          "order": 6
        },
        {
          "title": "Antigravity 릴리즈 노트 정리",
          "slug": "projects/antigravity-release-notes",
          "menu": "Antigravity",
          "order": 7
        }
      ]
    },
    {
      "name": "Bun",
      "path": "bun",
      "isCategory": true,
      "order": 3,
      "children": [
        {
          "title": "bun 이란?",
          "slug": "bun/bun-overview",
          "order": 1
        },
        {
          "title": "bun과 pnpm, npm의 차이",
          "slug": "bun/comparison-pnpm-npm",
          "order": 2
        },
        {
          "title": "GitHub Actions로 bun을 쓰는 방법",
          "slug": "bun/bun-github-actions-setup",
          "order": 3
        }
      ]
    },
    {
      "name": "Kubernetes",
      "path": "kubernetes",
      "isCategory": true,
      "order": 4,
      "children": [
        {
          "title": "Kubernetes 버전별 릴리즈 노트",
          "slug": "kubernetes/kubernetes-release-notes",
          "menu": "K8s 릴리즈 노트",
          "order": 1
        },
        {
          "title": "Ingress NGINX 은퇴 선언 및 마이그레이션 가이드",
          "slug": "kubernetes/ingress-nginx-deprecation-guide",
          "menu": "Ingress NGINX 마이그레이션",
          "order": 2
        }
      ]
    },
    {
      "title": "바이브 코딩이란?",
      "slug": ""
    }
  ]
}