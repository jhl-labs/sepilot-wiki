{
  "pages": [
    {
      "title": "MAS (Multi Agent System)",
      "slug": "mas-multi-agent-system",
      "content": "\n# MAS (Multi Agent System)\n\n## 개요\n\n다중 에이전트 시스템(Multi-Agent System, **MAS**)은 **여러 인공지능(AI) 에이전트가 협력·조정하여** 사용자나 다른 시스템을 대신해 복합적인 작업을 수행하도록 설계된 시스템이다. 각 에이전트는 자체적인 속성과 자율성을 가지며, 전체 시스템은 **공통 목표**를 달성하기 위해 에이전트 간의 **커뮤니케이션·협업**을 활용한다.\n\n2025년이 \"에이전트의 해\"였다면, **2026년은 모든 멀티 에이전트 시스템이 프로덕션으로 이행하는 해**로 평가받고 있다. 단일 범용 에이전트에서 **전문화된 에이전트 팀의 오케스트레이션 아키텍처**로의 전환이 가속화되고 있으며, Gartner에 따르면 멀티 에이전트 시스템 관련 문의가 2024년 Q1 대비 2025년 Q2에 **1,445% 급증**했다. ([IBM](https://www.ibm.com/think/news/ai-tech-trends-predictions-2026), [Landbase](https://www.landbase.com/blog/agentic-ai-statistics))\n\n## 핵심 구성 요소\n\n| 요소 | 설명 |\n|------|------|\n| **에이전트** | LLM 기반 AI 에이전트로, 자연어 이해·생성, 도구 호출, 계획 수립 등을 수행한다 |\n| **지식·메모리** | 에이전트는 외부 데이터, API, 웹 검색 등 도구를 활용해 정보를 획득하고, 단기/장기/엔티티 메모리를 관리한다 |\n| **통신 프로토콜** | 에이전트 간 메시지를 주고받으며 목표·계획·결과를 공유한다 (A2A, MCP 등) |\n| **조정 메커니즘** | 중앙 집중식·분산식·계층형·홀로닉·연합·팀 등 다양한 아키텍처가 존재한다 |\n| **도구(Tools)** | 에이전트가 외부 시스템과 상호작용하기 위한 인터페이스 (DB 쿼리, API 호출, 파일 시스템 등) |\n| **오케스트레이터** | 에이전트 팀의 작업 분배, 진행 추적, 오류 복구를 위한 재계획을 담당하는 상위 에이전트 |\n\n## 아키텍처 유형\n\n### 1. 중앙 집중식 네트워크\n- 중앙 서버가 전역 지식 베이스와 에이전트 연결을 관리한다.\n- **장점**: 통신이 쉽고 지식이 일관됨.\n- **단점**: 중앙 서버 장애 시 전체 시스템이 중단될 위험이 있다.\n\n### 2. 분산형 네트워크\n- 에이전트가 인접 에이전트와 직접 정보를 교환한다.\n- **장점**: 견고하고 모듈성이 높으며 단일 장애점이 없음.\n- **단점**: 협업을 위한 행동 조정이 복잡할 수 있다.\n\n### 3. 계층형 구조\n- 트리 형태로 상위·하위 에이전트가 존재한다.\n- 상위 에이전트가 의사결정 권한을 갖고, 하위 에이전트는 구체 작업을 수행한다.\n- Microsoft의 **Magentic-One**이 대표적 예로, Orchestrator가 4개 전문 에이전트를 지휘한다.\n\n### 4. 홀로닉 구조\n- 에이전트가 \"홀론\" 단위로 그룹화되어, 하나의 전체와 여러 하위 에이전트가 동시에 존재한다.\n\n### 5. 연합·팀 구조\n- 에이전트가 일시적으로 연합하거나 팀을 이루어 특정 목표를 달성한다.\n- Claude Code의 **Agent Teams**, CrewAI의 **Crews** 등이 이 구조에 해당한다.\n\n> 출처: [IBM - 다중 에이전트 시스템이란?](https://www.ibm.com/kr-ko/think/topics/multiagent-system)\n\n---\n\n## A2A, MCP, MAS의 관계\n\nMAS 생태계를 이해하기 위해서는 세 가지 핵심 개념의 관계를 파악해야 한다.\n\n### 개념 비교표\n\n| 항목 | MAS | A2A | MCP |\n|------|-----|-----|-----|\n| **수준** | 개념/아키텍처 | 프로토콜 | 프로토콜 |\n| **발표** | 학술 개념 (1990년대~) | Google, 2025.04 | Anthropic, 2024.11 |\n| **목적** | 다중 에이전트 협업 시스템 | 에이전트 간 통신 | 에이전트와 도구/데이터 연결 |\n| **거버넌스** | N/A | Linux Foundation | AAIF (Linux Foundation) |\n| **기반 기술** | 프레임워크에 의존 | HTTP, SSE, JSON-RPC, gRPC | JSON-RPC 2.0 |\n| **방향성** | 전체 시스템 | 수평적 (에이전트↔에이전트) | 수직적 (에이전트↔도구) |\n\n> MAS는 **\"무엇을 만들 것인가(what)\"**이고, A2A와 MCP는 **\"어떻게 만들 것인가(how)\"**에 해당하는 구체적 프로토콜이다.\n\n### Google A2A (Agent-to-Agent) 프로토콜\n\n**서로 다른 프레임워크, 벤더, 서버에서 구축된 AI 에이전트들이 상호 통신하고 협업할 수 있도록 설계된 개방형 표준**이다. 2025년 4월 Google Cloud가 발표했다.\n\n- **Agent Card**: 각 에이전트가 자신의 정체성, 기능, 스킬, 인증 요구사항을 기술한 JSON 메타데이터를 `/.well-known/agent-card.json`으로 발행\n- **Task 관리**: 생명주기 상태를 통해 빠른 작업부터 장시간 심층 연구까지 관리\n- **지원 규모**: 2025년 7월 기준 **150개 이상의 조직**이 지원 (Atlassian, Salesforce, SAP, PayPal, AWS, Microsoft 등)\n- **최신 상태**: Linux Foundation 산하 프로젝트로 편입, v0.3에서 gRPC 지원 추가\n\n> 출처: [Google Developers Blog](https://developers.googleblog.com/en/a2a-a-new-era-of-agent-interoperability/), [A2A Protocol](https://a2a-protocol.org/latest/specification/), [Linux Foundation](https://www.linuxfoundation.org/press/linux-foundation-launches-the-agent2agent-protocol-project-to-enable-secure-intelligent-communication-between-ai-agents)\n\n### Anthropic MCP (Model Context Protocol)\n\n**AI 어시스턴트를 데이터 소스, 도구, 외부 서비스에 연결하기 위한 개방형 표준 프로토콜**이다. Language Server Protocol(LSP)에서 영감을 받았다.\n\n- **3계층 아키텍처**: Host(사용자 앱) → Client(연결 관리) → Server(도구/리소스 노출)\n- **핵심 기능**: Tools(도구 호출), Resources(데이터 소스), Prompts(템플릿)\n- **채택 현황**: OpenAI(2025.03), Google DeepMind(2025.04) 공식 채택. **10,000개 이상의 MCP 서버**가 프로덕션 운영 중\n- **거버넌스**: 2025년 12월 **Agentic AI Foundation(AAIF)**에 기증 (Anthropic, OpenAI, Block 공동 설립, Linux Foundation 산하)\n\n> 출처: [Anthropic - MCP 발표](https://www.anthropic.com/news/model-context-protocol), [MCP Spec](https://modelcontextprotocol.io/specification/2025-11-25), [Anthropic - AAIF](https://www.anthropic.com/news/donating-the-model-context-protocol-and-establishing-of-the-agentic-ai-foundation)\n\n### A2A와 MCP는 보완적 관계\n\n두 프로토콜은 에이전틱 스택의 **서로 다른 계층**에서 작동한다:\n\n```\n[MAS 전체 시스템]\n    |\n    +-- [에이전트 A] ---MCP---> [도구/DB/API]\n    |       |\n    |       +---A2A---> [에이전트 B] ---MCP---> [도구/DB/API]\n    |                       |\n    |                       +---A2A---> [에이전트 C] ---MCP---> [도구/DB/API]\n    |\n    +-- 오케스트레이션 레이어 (작업 분배, 상태 관리)\n```\n\n| 시나리오 | 선택 |\n|----------|------|\n| 단일 에이전트가 여러 도구/DB에 접근 | **MCP** |\n| 서로 다른 벤더의 에이전트들이 협업 | **A2A** |\n| IDE에서 AI가 코드 분석 도구 호출 | **MCP** |\n| 구매 에이전트가 판매 에이전트와 협상 | **A2A** |\n| 복잡한 멀티 에이전트 기업 시스템 | **MCP + A2A 함께** |\n\n> 출처: [Auth0 - MCP vs A2A Guide](https://auth0.com/blog/mcp-vs-a2a/), [TrueFoundry](https://www.truefoundry.com/blog/mcp-vs-a2a), [Clarifai](https://www.clarifai.com/blog/mcp-vs-a2a-clearly-explained)\n\n---\n\n## 주요 AI Agent 개발 도구\n\n### 상용 도구\n\n| 도구 | 개발사 | MAS 지원 수준 | 핵심 MAS 기능 |\n|------|--------|--------------|--------------|\n| **Claude Code** | Anthropic | 높음 | Subagents, Agent Teams (실험적) |\n| **Cursor** | Cursor Inc. | 높음 | 멀티 에이전트 병렬, Subagents, 자동 판정 |\n| **Google Antigravity** | Google | 높음 | Manager View 멀티 에이전트 오케스트레이션 |\n| **GitHub Copilot** | GitHub/MS | 중상 | Agent Mode, Agent Skills, Coding Agent |\n| **Devin** | Cognition Labs | 중상 | 멀티 에이전트 디스패치, 병렬 실행 |\n| **Windsurf** | Codeium | 중간 | Cascade 에이전트, Agent Skills |\n\n#### Claude Code (Anthropic)\n\nAnthropic의 공식 CLI 기반 AI 코딩 에이전트.\n\n- **Subagents**: 메인 에이전트 내에서 특정 작업을 수행하는 독립 에이전트. 자체 컨텍스트 윈도우, 커스텀 시스템 프롬프트, 독립적 도구 접근 권한 보유. 결과를 메인 에이전트에게만 보고.\n- **Agent Teams** (실험적): Opus 4.6과 함께 출시. 여러 Claude Code 인스턴스가 병렬로 자율 협력. 팀 리드가 팀원을 생성하고, 팀원들은 **서로 직접 메시지를 주고받으며** 공유 작업 목록에서 자체 조율.\n\n| 구분 | Context | Communication | Coordination |\n|------|---------|---------------|--------------|\n| **Subagents** | 메인 세션 내 | 결과 → 메인만 | 메인 에이전트가 전체 관리 |\n| **Agent Teams** | 각 팀원 별도 컨텍스트 | 팀원 ↔ 팀원 직접 | 공유 작업 리스트, 자체 조정 |\n\n> 출처: [Claude Code Subagents 문서](https://code.claude.com/docs/en/sub-agents), [Claude Code Agent Teams](https://claudefa.st/blog/guide/agents/agent-teams)\n\n#### Google Antigravity\n\n2025년 11월 Gemini 3 출시와 함께 발표된 에이전틱 개발 플랫폼.\n\n- VS Code 포크 기반의 완전한 독립 플랫폼\n- **Editor View**: 에이전트 사이드바가 있는 일반적인 IDE 인터페이스\n- **Manager View**: 여러 에이전트를 병렬로 오케스트레이션하는 제어 센터. 비동기 작업 실행 가능\n- Gemini 3 기반, Anthropic Claude 및 OpenAI 모델도 지원\n- 현재 Public Preview로 무료 제공\n\n> 출처: [Google Developers Blog - Antigravity](https://developers.googleblog.com/build-with-google-antigravity-our-new-agentic-development-platform/), [Wikipedia](https://en.wikipedia.org/wiki/Google_Antigravity)\n\n#### Cursor\n\nVS Code 포크 기반 AI 코딩 IDE. 2026년 2월 기준 멀티 에이전트 기능 프리뷰 제공 중.\n\n- **Agent Mode (Composer)**: 다단계 코딩 작업을 자율적으로 처리\n- **Multi-Agent Interface**: Cursor 2.0에서 도입. 여러 AI 에이전트가 병렬 작업 가능\n- **자동 판정 시스템**: 여러 에이전트를 병렬 실행 후 최적 솔루션을 자동 평가·추천\n\n> 출처: [Cursor 2.0 - InfoQ](https://www.infoq.com/news/2025/11/cursor-composer-multiagent/), [Cursor 2.2 Changelog](https://cursor.com/changelog/2-2)\n\n#### VS Code 1.109 - 멀티 에이전트 개발의 허브\n\n2026년 2월 VS Code 1.109에서 Microsoft는 VS Code를 **\"멀티 에이전트 개발의 홈\"**으로 선언했다.\n\n- Claude, Codex, Copilot 에이전트를 동시에 실행\n- 여러 에이전트 세션을 로컬/백그라운드/클라우드에서 병렬 관리\n- Agent Skills가 GA(일반 제공)로 전환\n\n> 출처: [VS Code Blog](https://code.visualstudio.com/blogs/2026/02/05/multi-agent-development), [Visual Studio Magazine](https://visualstudiomagazine.com/articles/2026/02/05/vs-code-1-109-deemed-multi-agent-development-platform.aspx)\n\n### 오픈소스 MAS 프레임워크\n\n| 프레임워크 | 개발사 | 언어 | 아키텍처 | 특징 |\n|-----------|--------|------|---------|------|\n| **AutoGen / MS Agent Framework** | Microsoft | Python, .NET | 비동기 이벤트 기반 | Semantic Kernel과 통합, 2026 Q1 GA 목표 |\n| **CrewAI** | CrewAI Inc. | Python | 역할 기반, Crews + Flows | 직관적 역할 설계, 100+ 내장 도구 |\n| **LangGraph** | LangChain | Python, JS/TS | 상태 기반 그래프 | 영속 상태, 타임트래블 디버깅, 1.0 출시 |\n| **OpenAI Agents SDK** | OpenAI | Python, TS | 핸드오프 기반 | Swarm 후속, 가드레일, 트레이싱 내장 |\n| **Magentic-One** | MS Research | Python | Orchestrator + 4 전문 에이전트 | 범용 작업 해결, 벤치마크 SOTA급 |\n| **Google ADK** | Google | Python, TS, Go, Java | 계층적 멀티 에이전트 | 처음부터 MAS 설계, Vertex AI 통합 |\n\n#### AutoGen → Microsoft Agent Framework\n\nMicrosoft Research에서 개발한 멀티 에이전트 프레임워크. v0.4에서 비동기 이벤트 기반 아키텍처로 개편된 후, **Semantic Kernel과 통합되어 Microsoft Agent Framework**으로 전환 중이다.\n\n- Python 및 .NET 지원, TypeScript 예정\n- 2026년 Q1 말까지 1.0 GA 출시 목표\n- AutoGen은 안정 API를 유지하며 보안 패치만 받고, 신규 기능은 Agent Framework으로\n\n> 출처: [Visual Studio Magazine](https://visualstudiomagazine.com/articles/2025/10/01/semantic-kernel-autogen--open-source-microsoft-agent-framework.aspx), [MS Agent Framework](https://learn.microsoft.com/en-us/agent-framework/overview/agent-framework-overview)\n\n#### CrewAI\n\n역할 기반 멀티 에이전트 협업에 특화된 Python 프레임워크. LangChain에 독립적으로 구축.\n\n- **역할 기반 아키텍처**: 에이전트에 역할(연구원, 작가, 분석가 등), 목표, 배경 이야기 부여\n- **협업 프로세스**: Sequential(순차), Hierarchical(관리자 조율), Consensus(합의 기반)\n- **Crews + Flows 이중 구조**: Crews(자율적 팀), Flows(이벤트 기반 워크플로우)\n- GitHub 스타 20,000+\n\n> 출처: [CrewAI 공식](https://www.crewai.com/), [CrewAI GitHub](https://github.com/crewAIInc/crewAI)\n\n#### LangGraph (LangChain)\n\n상태 기반 그래프 아키텍처의 에이전트 오케스트레이션 프레임워크.\n\n- **사이클을 포함하는 LLM 워크플로우** 생성 가능 (에이전트가 이전 단계를 재방문)\n- **Durable State**: 실행 상태 자동 저장, 서버 재시작이나 장기 워크플로우 중단 시에도 이어서 실행\n- **Time-Travel Debugging**: 과거 상태로 돌아가 디버깅 가능\n- 2025년 **LangGraph 1.0** 출시\n\n> 출처: [LangGraph 공식](https://www.langchain.com/langgraph), [LangGraph Multi-Agent Workflows](https://blog.langchain.com/langgraph-multi-agent-workflows/)\n\n#### OpenCode\n\nGo 언어로 작성된 오픈소스 터미널 기반 AI 코딩 에이전트. Claude Code의 오픈소스 대안으로 부상.\n\n- 75개 이상 모델 지원 (Claude, GPT, Gemini, 로컬 모델 등)\n- GitHub 스타 95,000+, 월 650,000명+ 개발자 사용\n- 전용 MAS 프레임워크라기보다 단일 에이전트 코딩 도구에 가까움\n\n> 출처: [OpenCode 공식](https://opencode.ai/), [OpenCode GitHub](https://github.com/opencode-ai/opencode)\n\n#### OpenClaw\n\n오스트리아 개발자 Peter Steinberger가 만든 오픈소스 AI 에이전트. Signal, Telegram, Discord, WhatsApp 등 **메시징 서비스를 통해 실세계 작업을 수행**한다.\n\n- 2025년 11월 \"Clawdbot\"으로 공개 → Anthropic 상표 항의 → \"OpenClaw\"로 이름 변경\n- 웹 브라우징, PDF 요약, 캘린더 관리, 에이전틱 쇼핑, 이메일 관리 등 수행\n- 독립적 MAS 프레임워크가 아닌, 에이전틱 인터페이스\n\n> 출처: [OpenClaw Wikipedia](https://en.wikipedia.org/wiki/OpenClaw), [CNBC](https://www.cnbc.com/2026/02/02/openclaw-open-source-ai-agent-rise-controversy-clawdbot-moltbot-moltbook.html)\n\n---\n\n## 주요 기업의 MAS 전략 (2025-2026)\n\n### Google - A2A + ADK\n\n- **A2A 프로토콜**: 에이전트 간 통신 오픈 표준, 150+ 기업 지원\n- **Agent Development Kit (ADK)**: 오픈소스 멀티 에이전트 프레임워크 (Python, TS, Go, Java)\n- **Antigravity IDE**: Manager View를 통한 멀티 에이전트 오케스트레이션\n\n> 출처: [Google ADK](https://developers.googleblog.com/en/agent-development-kit-easy-to-build-multi-agent-applications/)\n\n### Microsoft - Copilot Studio + Agent Framework\n\n- **Copilot Studio**: 멀티 에이전트 시스템 구축 기능 (프리뷰), 에이전트 간 작업 위임\n- **Microsoft Agent Framework**: AutoGen + Semantic Kernel 통합, Python/.NET 지원\n- **2026년 전환**: 개별 명령 응답에서 **자율적 멀티스텝 프로세스 처리**로의 주요 아키텍처 전환\n\n> 출처: [Microsoft Copilot Blog](https://www.microsoft.com/en-us/microsoft-copilot/blog/copilot-studio/multi-agent-orchestration-maker-controls-and-more-microsoft-copilot-studio-announcements-at-microsoft-build-2025/), [6 core capabilities for 2026](https://www.microsoft.com/en-us/microsoft-copilot/blog/copilot-studio/6-core-capabilities-to-scale-agent-adoption-in-2026/)\n\n### OpenAI - Agents SDK + AGENTS.md\n\n- **Agents SDK**: Swarm의 프로덕션 후속. 핸드오프, 가드레일, 트레이싱, 음성 에이전트 내장\n- **AGENTS.md**: 코딩 에이전트 지침 규격. 60,000+ 오픈소스 프로젝트에서 채택\n- AAIF(Agentic AI Foundation) 공동 설립\n\n> 출처: [OpenAI - New tools for building agents](https://openai.com/index/new-tools-for-building-agents/), [OpenAI - AAIF](https://openai.com/index/agentic-ai-foundation/)\n\n### Amazon AWS - Bedrock AgentCore\n\n- **Amazon Bedrock**: 멀티 에이전트 협업 기능 2025년 3월 GA. Supervisor 기반 아키텍처\n- **AgentCore**: re:Invent 2025에서 발표. 에이전트 경계 관리, 메모리, 평가 기능\n\n> 출처: [AWS - Multi-agent collaboration](https://aws.amazon.com/blogs/aws/introducing-multi-agent-collaboration-capability-for-amazon-bedrock/)\n\n### NVIDIA - Nemotron 3\n\n- MAS 구축을 위한 **Nemotron 3** 오픈 모델 패밀리 (Nano, Super, Ultra) 발표\n- Hybrid Latent Mixture-of-Experts 아키텍처\n- Super와 Ultra는 2026년 상반기 출시 예정\n\n> 출처: [NVIDIA](https://nvidianews.nvidia.com/news/nvidia-debuts-nemotron-3-family-of-open-models)\n\n### Agentic AI Foundation (AAIF)\n\n2025년 12월 Linux Foundation 산하에 설립. **OpenAI, Anthropic, Block**이 공동 창설하고, Google, Microsoft, AWS, Bloomberg, Cloudflare가 지원한다.\n\n- **주요 프로젝트**: MCP (Anthropic), Goose (Block), AGENTS.md (OpenAI)\n- AI 에이전트 표준화를 위한 업계 최대 협력체\n\n> 출처: [OpenAI - AAIF](https://openai.com/index/agentic-ai-foundation/), [TechCrunch](https://techcrunch.com/2025/12/09/openai-anthropic-and-block-join-new-linux-foundation-effort-to-standardize-the-ai-agent-era/)\n\n---\n\n## 시장 규모와 성장 전망\n\n### 시장 규모 예측\n\n| 연도 | 시장 규모 | 출처 |\n|------|----------|------|\n| 2025년 | USD 72.9억 | [Fortune Business Insights](https://www.fortunebusinessinsights.com/agentic-ai-market-114233) |\n| 2026년 | USD 91.4억 | Fortune Business Insights |\n| 2030년 | USD 520억+ | [MachineLearningMastery](https://machinelearningmastery.com/7-agentic-ai-trends-to-watch-in-2026/) |\n| 2032년 | USD 932억 (CAGR 44.6%) | [MarketsandMarkets](https://www.marketsandmarkets.com/Market-Reports/agentic-ai-market-208190735.html) |\n| 2034년 | USD 1,391.9억 (CAGR 40.5%) | Fortune Business Insights |\n\n### 핵심 예측 (Gartner, McKinsey 등)\n\n| 예측 | 출처 |\n|------|------|\n| 2026년 말까지 엔터프라이즈 앱의 **40%**에 태스크 전용 AI 에이전트 탑재 (2025년 5% 미만) | [Gartner](https://www.gartner.com/en/newsroom/press-releases/2025-08-26-gartner-predicts-40-percent-of-enterprise-apps-will-feature-task-specific-ai-agents-by-2026-up-from-less-than-5-percent-in-2025) |\n| 2028년까지 AI 에이전트가 B2B 구매에서 **USD 15조** 규모 주도 | [Gartner](https://www.digitalcommerce360.com/2025/11/28/gartner-ai-agents-15-trillion-in-b2b-purchases-by-2028/) |\n| 2028년까지 일상 업무 의사결정의 **15%**가 에이전틱 AI로 자율 수행 | Gartner |\n| 2030년까지 에이전틱 AI로 최대 **USD 2.9조**의 경제적 가치 창출 | [McKinsey](https://onereach.ai/blog/agentic-ai-adoption-rates-roi-market-trends/) |\n| 2035년까지 에이전틱 AI가 기업 앱 소프트웨어 매출의 **30%** (USD 4,500억+) 차지 | Gartner |\n\n---\n\n## 산업별 영향\n\n### 소프트웨어 개발\n\n2026년은 소프트웨어 개발에서 **\"위임(delegation)\"**의 시대다. 2024년 자동완성→대화, 2025년 대화→협업에 이어, 2026년에는 AI 에이전트에게 작업을 **위임**하는 단계로 전환되고 있다.\n\n- 개발자의 **85%**가 정기적으로 AI 도구를 사용\n- Gartner 예측: 2026년까지 소프트웨어 엔지니어의 **90%**가 직접 코딩에서 AI 프로세스 오케스트레이션으로 전환\n- MCP를 통해 Claude Code가 Figma, Slack, Jira, 내부 문서와 연동\n\n> 출처: [Anthropic - 2026 Agentic Coding Trends Report](https://resources.anthropic.com/hubfs/2026%20Agentic%20Coding%20Trends%20Report.pdf), [senorit.de](https://senorit.de/en/blog/ai-agents-software-development-2026)\n\n### 고객 서비스\n\n- 2029년까지 에이전틱 AI가 일반 고객 서비스 이슈의 **80%**를 인간 개입 없이 자율 해결\n- 운영 비용 **30% 절감** 효과\n- 고객 서비스와 이커머스가 **채택 선두** (명확한 ROI)\n\n> 출처: [Gartner](https://www.gartner.com/en/newsroom/press-releases/2025-03-05-gartner-predicts-agentic-ai-will-autonomously-resolve-80-percent-of-common-customer-service-issues-without-human-intervention-by-20290), [BCG](https://www.bcg.com/publications/2025/new-frontier-customer-service-transformation)\n\n### 금융\n\n- 금융 서비스가 **\"Frontier Firms\"**(모든 워크플로우에 AI 에이전트를 내재화한 조직)의 최고 밀집 산업\n- Frontier Firms의 AI 투자 수익률이 저조한 채택 기업의 **약 3배**\n- 2026년 금융 팀의 **44%**가 에이전틱 AI 사용 예상 (**600%+ 증가**)\n- 미국 은행 사례: AI 에이전트로 신용 위험 메모 작성 시 생산성 **20-60% 향상**, 신용 처리 시간 **30% 단축**\n\n> 출처: [Microsoft](https://www.microsoft.com/en-us/industry/blog/financial-services/2025/12/18/ai-transformation-in-financial-services-5-predictors-for-success-in-2026/), [Neurons Lab](https://neurons-lab.com/article/agentic-ai-in-financial-services-2026/)\n\n### 기업 전반\n\n- **57%의 기업**이 이미 AI 에이전트를 프로덕션에서 운영\n- **59%의 기업**이 3개 이상의 LLM을 프로덕션에서 운영 (2025년 후반)\n- 기업들은 평균 약 **USD 1.14억**의 관련 투자를 계획 중\n- 고위 임원의 **90%**가 2026년 중 관련 투자를 늘릴 계획\n\n> 출처: [Landbase](https://www.landbase.com/blog/agentic-ai-statistics), [OneReach.ai](https://onereach.ai/blog/agentic-ai-adoption-rates-roi-market-trends/)\n\n---\n\n## 미래 전망 (2026-2030)\n\n### 기술적 방향\n\n1. **마이크로서비스 혁명과 유사한 전환**: 단일 범용 에이전트 → 전문화된 에이전트 팀 오케스트레이션. 소프트웨어의 모놀리식→마이크로서비스 전환과 동일한 패턴. ([Techzine](https://www.techzine.eu/blogs/applications/138502/multi-agent-systems-set-to-dominate-it-environments-in-2026/))\n\n2. **인간-AI 혼합 팀**: 2028년까지 **38%의 조직**에서 AI 에이전트가 인간 팀의 구성원으로 참여. ([G2](https://learn.g2.com/enterprise-ai-agents-report))\n\n3. **로봇·IoT 통합**: AI 에이전트가 자율 창고 로봇, 배달 드론, 가정 어시스턴트와 결합하여 물리적 환경에서 작동.\n\n4. **표준화 수렴**: A2A(에이전트 간), MCP(에이전트-도구), AGENTS.md(코딩 에이전트 지침)가 AAIF와 Linux Foundation 하에서 통합 거버넌스.\n\n5. **로우코드/노코드 민주화**: 시각적 빌더를 통해 **15~60분** 만에 에이전트 배포 가능. ([MachineLearningMastery](https://machinelearningmastery.com/7-agentic-ai-trends-to-watch-in-2026/))\n\n### 과제와 리스크\n\n| 과제 | 현황 |\n|------|------|\n| **신뢰도 하락** | 완전 자율 AI 에이전트에 대한 임원 신뢰도가 43%(2024) → **22%**(2025)로 하락 |\n| **프로젝트 취소** | 2027년까지 에이전틱 AI 프로젝트의 **40%+**가 비용, 불명확한 가치, 리스크 관리 부족으로 취소 예상 |\n| **시스템 복잡성** | 리더의 **65%**가 에이전틱 시스템 복잡성을 최대 장벽으로 지목 |\n| **보안·프라이버시** | 35%의 조직이 사이버보안, 30%가 데이터 프라이버시를 주요 우려로 지적 |\n| **통합 난이도** | **46%**가 기존 시스템과의 통합을 주요 과제로 인식 |\n| **조정 실패** | 부서별 독립 에이전트 구축으로 연결 단절, 중복 로직, \"디지털 허드렛일\" 발생 |\n\n> 출처: [Computer Weekly](https://www.computerweekly.com/opinion/Unlocking-the-value-of-multi-agent-systems-in-2026), [Salesmate](https://www.salesmate.io/blog/future-of-ai-agents/)\n\n### 거버넌스와 윤리\n\n- **EU AI Act**: 고위험 의무가 **2026년 8월** 전면 적용\n- **Guardian Agent**: Gartner 예측, 2030년까지 에이전틱 AI 시장의 **10-15%**를 차지. 다른 에이전트의 행동을 감시·감사하는 전문 에이전트 ([Gartner](https://www.gartner.com/en/newsroom/press-releases/2025-06-11-gartner-predicts-that-guardian-agents-will-capture-10-15-percent-of-the-agentic-ai-market-by-2030))\n- **책임 소재**: 자율 에이전트의 리소스 할당, 환자 우선순위 결정, 금융 거래 실행 등에 대한 새로운 책임 매트릭스 필요\n- **인증 표준**: ISO 42001, NIST AI RMF 등의 제도화 가속\n\n> 출처: [KDnuggets](https://www.kdnuggets.com/emerging-trends-in-ai-ethics-and-governance-for-2026), [Dataversity](https://www.dataversity.net/articles/ai-governance-in-2026-is-your-organization-ready/), [Credo AI](https://www.credo.ai/blog/latest-ai-regulations-update-what-enterprises-need-to-know)\n\n---\n\n## 벤치마크와 연구 동향\n\n| 벤치마크 | 설명 | 출처 |\n|---------|------|------|\n| **TheAgentCompany** | NeurIPS 2025. 실제 전문 업무 수행 능력 평가 | [OpenReview](https://openreview.net/forum?id=LZnKNApvhG) |\n| **AgentArch** | 오케스트레이션 전략, ReAct vs 함수 호출, 메모리 아키텍처 등 4차원 평가 | [arXiv](https://arxiv.org/html/2509.10769v1) |\n| **MedAgentBoard** | 의료 분야 멀티 에이전트 협업 벤치마크 | [MedAgentBoard](https://medagentboard.netlify.app/) |\n| **WMAC 2026** | AAAI 2026에서 개최된 LLM 기반 멀티 에이전트 협업 워크숍 | [WMAC 2026](https://multiagents.org/2026/) |\n\n---\n\n## 참고 자료\n\n### 프로토콜 & 표준\n- [A2A Protocol Specification](https://a2a-protocol.org/latest/specification/)\n- [MCP Specification](https://modelcontextprotocol.io/specification/2025-11-25)\n- [Agentic AI Foundation (AAIF)](https://www.linuxfoundation.org/press/linux-foundation-announces-the-formation-of-the-agentic-ai-foundation)\n\n### 프레임워크\n- [Microsoft Agent Framework](https://learn.microsoft.com/en-us/agent-framework/overview/agent-framework-overview)\n- [CrewAI](https://www.crewai.com/)\n- [LangGraph](https://www.langchain.com/langgraph)\n- [Google ADK](https://google.github.io/adk-docs/)\n- [OpenAI Agents SDK](https://openai.github.io/openai-agents-python/)\n\n### 시장 분석\n- [Gartner - Top Strategic Technology Trends 2025](https://www.gartner.com/en/newsroom/press-releases/2024-10-21-gartner-identifies-the-top-10-strategic-technology-trends-for-2025)\n- [Fortune Business Insights - Agentic AI Market](https://www.fortunebusinessinsights.com/agentic-ai-market-114233)\n- [MarketsandMarkets - Agentic AI Market](https://www.marketsandmarkets.com/Market-Reports/agentic-ai-market-208190735.html)\n\n### 기업 전략\n- [IBM - AI tech trends 2026](https://www.ibm.com/think/news/ai-tech-trends-predictions-2026)\n- [Google Cloud - 5 ways AI agents will transform work in 2026](https://blog.google/products/google-cloud/ai-business-trends-report-2026/)\n- [KPMG - AI at Scale 2026](https://kpmg.com/us/en/media/news/q4-ai-pulse.html)\n\n*본 문서는 2026년 2월 기준 공개된 공식 자료를 기반으로 작성되었습니다. 최신 기능이나 업데이트가 있을 경우 공식 문서를 확인하시기 바랍니다.*\n",
      "lastModified": "2026-02-10T00:36:18Z",
      "author": "SEPilot AI",
      "status": "draft",
      "isDraft": true,
      "isInvalid": false,
      "tags": [
        "Multi-Agent",
        "AI",
        "Agentic-AI",
        "MCP",
        "A2A",
        "LLM"
      ],
      "history": [
        {
          "sha": "b4a35c2",
          "message": "chore: 자동 상태 수집 - 2026-02-10 00:36",
          "author": "GitHub Action",
          "authorEmail": "action@github.com",
          "date": "2026-02-10T00:36:18Z",
          "additions": 436,
          "deletions": 0
        }
      ]
    },
    {
      "title": "Sepilot Wiki가 어떤 언어/프레임워크로 구현되어 있나요?",
      "slug": "projects/technology-stack",
      "content": "\n## 기술 스택\n\nSEPilot Wiki는 다음과 같은 기술 스택으로 구현되어 있습니다:\n\n### 프론트엔드\n- **React 18** - UI 라이브러리\n- **TypeScript** - 타입 안전성을 위한 정적 타입 언어\n- **Vite** - 빌드 도구 및 개발 서버\n- **React Router DOM** - SPA 라우팅\n- **TanStack Query (React Query)** - 서버 상태 관리\n\n### Next.js 사용 여부\n- SEPilot Wiki는 **Next.js**를 사용하지 않습니다.\n- 대신 **Vite**와 **React**를 조합하여 클라이언트 사이드 렌더링 SPA 형태로 구현되었습니다.\n- Next.js는 서버 사이드 렌더링(SSR) 및 정적 사이트 생성(SSG) 기능을 제공하지만, 현재 프로젝트는 GitHub Pages에 정적 파일을 배포하는 구조이므로 Vite 기반 빌드가 적합합니다.\n- 필요 시 향후 SSR이나 SSG가 요구될 경우 Next.js로 마이그레이션을 고려할 수 있습니다.\n\n### 마크다운 렌더링\n- **react-markdown** - 마크다운 파싱 및 렌더링\n- **remark-gfm** - GitHub Flavored Markdown 지원\n- **rehype-raw** - HTML 태그 지원\n- **rehype-sanitize** - XSS 방지를 위한 HTML 살균\n- **react-syntax-highlighter** - 코드 구문 강조\n\n### 스타일링\n- **CSS Variables** - 테마 시스템\n- **Lucide React** - 아이콘 라이브러리\n\n### 개발 도구\n- **ESLint** - 코드 린팅\n- **Vitest** - 테스트 프레임워크\n- **Husky** - Git hooks\n\n### CI/CD\n- **GitHub Actions** - 자동화 워크플로우\n- **GitHub Pages** - 정적 사이트 호스팅\n- **Bun** - 패키지 매니저 및 런타임\n\n### AI 통합\n- **OpenAI API 호환** - LLM을 통한 문서 자동 생성\n\n## 참고 링크\n\n- [SEPilot Wiki GitHub Repository](https://github.com/jhl-labs/sepilot-wiki)\n",
      "lastModified": "2026-02-10T00:36:18Z",
      "author": "SEPilot AI",
      "status": "published",
      "isDraft": false,
      "isInvalid": false,
      "tags": [
        "sepilot-wiki",
        "기술스택",
        "React",
        "TypeScript",
        "Vite"
      ],
      "menu": "SEPilot Wiki에 대해",
      "history": [
        {
          "sha": "b4a35c2",
          "message": "chore: 자동 상태 수집 - 2026-02-10 00:36",
          "author": "GitHub Action",
          "authorEmail": "action@github.com",
          "date": "2026-02-10T00:36:18Z",
          "additions": 58,
          "deletions": 0
        }
      ]
    },
    {
      "title": "SEPilot Desktop 소개",
      "slug": "projects/sepilot-desktop",
      "content": "\n# SEPilot Desktop 소개\n\nSEPilot Desktop은 오픈소스 LLM 기반 데스크톱 애플리케이션으로, **Chat**, **Editor**, **Browser** 세 가지 모드를 제공하여 강력하고 유연한 AI 워크플로우를 지원합니다. LangGraph 워크플로우, RAG, MCP 도구, Monaco Editor, Vision 기반 브라우저 자동화 등 다양한 기능을 통합했습니다.\n\n---\n\n## 📦 다운로드 & 소스\n- **다운로드**: [SEPilot Desktop 다운로드](https://jhl-labs.github.io/sepilot_desktop/#download)\n- **GitHub**: [GitHub 저장소](https://github.com/jhl-labs/sepilot_desktop)\n- **데모 영상**: assets/videos/demo-main.mp4\n\n---\n\n## 🧭 3가지 애플리케이션 모드\n\n### 1. Chat 모드\nAI와 대화하고 질문할 수 있습니다.\n- LangGraph 워크플로우 (Instant, Sequential, Deep, Coding, RAG, Browser 등 6가지)\n- RAG 문서 검색 & 편집, 폴더 관리, Export/Import\n- MCP 도구 통합 (GitHub, Brave Search, Filesystem 등)\n- 이미지 생성 & 해석 (ComfyUI, Vision API)\n- Persona 시스템 (AI 역할 정의, SQLite 영구 저장)\n- Quick Question (최대 5개 단축키)\n- GitHub Sync (AES‑256‑GCM 암호화)\n\n> **데모**: assets/videos/chat-mode-demo.mp4\n\n### 2. Editor 모드\n코드 작성 및 파일 관리에 최적화된 환경입니다.\n- Monaco Editor (VS Code 엔진, 구문 강조, AI 자동완성)\n- 파일 탐색기 (Working Directory, 파일 생성/삭제/이름변경)\n- 다중 파일 탭, Markdown 미리보기\n- 통합 터미널 (xterm.js, PowerShell/bash/zsh, 탭 관리)\n- 전체 파일 검색 (ripgrep 기반, Ctrl+Shift+F)\n- Advanced Editor Agent (50회 반복, 9개 Built‑in Tools)\n- 10가지 Notion 스타일 Writing Tools\n\n> **데모**: assets/videos/editor-mode-demo.mp4\n\n### 3. Browser 모드\nAI와 함께 웹을 탐색하고 자동화합니다.\n- Chromium 기반 브라우저 (BrowserView, Chrome 스타일 탭)\n- 18개 자동화 도구 (Navigate, DOM Inspection, Vision Tools 등)\n- Google Search Tools (검색, 뉴스, Scholar, 이미지, 고급 필터)\n- Vision 기반 UI 제어 (Set‑of‑Mark, 좌표 클릭)\n- Bot 감지 우회 (Stealth Fingerprint, 자연스러운 타이밍)\n- 페이지 캡처 (MHTML + 스크린샷, 오프라인 뷰어)\n- 북마크 관리 (폴더별 정리)\n\n> **데모**: assets/videos/browser-mode-demo.mp4\n\n---\n\n## 🌟 주요 기능\n\n### LangGraph 워크플로우\n다양한 사고(Thinking) 모드 지원: Instant, Sequential, Tree‑of‑Thought, Deep 등. 실시간 스트리밍으로 사고 과정 시각화 및 conversationId 기반 격리.\n\n### AI Persona 시스템 (v0.6.0)\n- 기본 페르소나: 일반 어시스턴트, 번역가, 영어 선생님, 시니어 개발자\n- 사용자 정의 페르소나 추가/수정/삭제\n- 슬래시 커맨드 자동완성 (/persona)\n- SQLite 기반 영구 저장\n\n### RAG (검색 증강 생성)\n- 텍스트, URL, 파일(PDF, DOCX, TXT, MD) 업로드 지원\n- SQLite‑vec, OpenSearch, Elasticsearch, pgvector 지원\n- 문서 편집 AI (정제, 확장, 축약, 검증, 커스텀 프롬프트)\n- 폴더 구조 관리 (드래그 앤 드롭, Tree/List/Grid 뷰)\n- Export/Import (JSON 형식, 백업/복원)\n\n> **데모**: assets/videos/rag-demo.gif\n\n### 브라우저 자동화 (v0.6.0)\n- Electron BrowserView 기반 Chromium 통합\n- Vision 기반 UI 제어 및 Google Search Tools\n- DOM Inspection, Vision Tools, Bot 감지 우회 등 27개 도구\n\n> **데모**: assets/videos/browser-automation.gif\n\n### MCP 프로토콜\n- Model Context Protocol을 통한 도구 및 컨텍스트 표준화\n- GitHub, Brave Search, Git, Filesystem 등 템플릿 제공\n- 환경 변수 UI 설정, 실행 전 사용자 승인 (5분 타임아웃)\n\n> **데모**: assets/videos/mcp-tools.gif\n\n### GitHub Sync (v0.6.0)\n- Personal Access Token 기반 안전한 데이터 동기화\n- AES‑256‑GCM 암호화로 민감 정보 보호\n- 설정, 문서, 페르소나, 이미지, 대화 내역 동기화\n\n> **데모**: assets/videos/github-sync.gif\n\n### 이미지 기능\n- ComfyUI 통합 이미지 생성\n- Vision API 기반 이미지 해석 및 질의응답\n\n> **데모**: assets/videos/image-generation.gif\n\n---\n\n## 🛠️ 기술 스택\n- **프론트엔드**: Next.js 15.3, React 19, TypeScript 5.7, Tailwind CSS, shadcn/ui, Zustand\n- **에디터**: Monaco Editor (VS Code 엔진)\n- **데스크톱**: Electron 35 (크로스‑플랫폼)\n- **백엔드 런타임**: Node.js 20+\n- **데이터베이스**: better‑sqlite3, SQLite‑vec (벡터 검색)\n- **IPC**: Context Bridge (안전한 통신)\n- **LLM & AI**: LangGraph, LangChain, OpenAI, Anthropic, Google, Groq, MCP Protocol, ComfyUI\n\n---\n\n## 🚀 빠른 시작 (5분 안에 시작)\n1. **다운로드 및 설치**\n   - Windows: `SEPilot-Setup-0.6.0.exe`\n   - macOS: `SEPilot-0.6.0.dmg`\n   - Linux: `SEPilot-0.6.0.AppImage`\n2. **LLM 설정**\n   - 좌측 하단 설정 아이콘 → LLM 제공자 및 API 키 입력\n   - 지원: OpenAI, Anthropic, Google, Custom (OpenAI‑compatible)\n3. **모드 및 그래프 선택**\n   - Chat, Editor, Browser 중 선택\n   - 필요 시 LangGraph 워크플로우 타입 선택 (Instant, RAG, Agent 등)\n4. **대화 시작**\n   - 준비가 완료되면 AI와 대화를 시작하세요!\n\n---\n\n## 📋 시스템 요구사항\n- **최소**: Node.js 20.9+, 4 GB RAM, 500 MB 디스크\n- **권장**: Node.js 22+, 8 GB RAM, 1 GB 디스크\n\n---\n\n*이 문서는 초안(draft) 상태이며, 검토 후 `published` 로 전환될 예정입니다.*",
      "lastModified": "2026-02-10T00:36:18Z",
      "author": "GitHub Action",
      "status": "draft",
      "isDraft": true,
      "isInvalid": false,
      "tags": [
        "SEPilot",
        "Desktop",
        "LLM",
        "Project"
      ],
      "history": [
        {
          "sha": "b4a35c2",
          "message": "chore: 자동 상태 수집 - 2026-02-10 00:36",
          "author": "GitHub Action",
          "authorEmail": "action@github.com",
          "date": "2026-02-10T00:36:18Z",
          "additions": 153,
          "deletions": 0
        }
      ]
    },
    {
      "title": "bun과 pnpm, npm의 차이",
      "slug": "bun/comparison-pnpm-npm",
      "content": "\n# bun과 pnpm, npm의 차이\n\n## 개요\n`bun`은 JavaScript 런타임, 패키지 매니저, 번들러를 하나의 바이너리로 제공하는 **통합 툴**입니다. 반면에 `npm`과 `pnpm`은 **패키지 매니저**에 초점을 맞추고 있으며, 각각 Node.js와 별도로 동작합니다.\n\n이 가이드에서는 **설치 방식**, **성능**, **디스크 사용량**, **호환성**, **생태계** 등을 기준으로 세 도구를 비교하고, 어떤 상황에서 어떤 도구를 선택하면 좋은지 살펴봅니다.\n\n---\n\n## 1. 설치 및 초기 설정\n\n| 항목 | bun | npm (Node.js 기본) | pnpm |\n|------|-----|-------------------|------|\n| 설치 명령 | `curl -fsSL https://bun.sh/install | bash` (스크립트) 또는 `brew install bun` (macOS) | Node.js 설치 시 자동 포함 (`node -v` 확인) | `npm i -g pnpm` |\n| 기본 제공 기능 | 런타임, 패키지 매니저, 번들러, 테스트 러너 등 | 런타임 + npm (패키지 매니저) | npm 호환 CLI + 효율적인 저장소 관리 |\n| 설정 파일 | `bunfig.toml` (선택) | `package.json` | `pnpm-workspace.yaml` (멀티패키지) |\n\n## 2. 성능 비교\n\n| 항목 | bun | npm | pnpm |\n|------|-----|-----|------|\n| 패키지 설치 속도 | **매우 빠름** (C++ 로 구현, 병렬 다운로드) | 보통 (JavaScript 기반) | npm보다 빠름, 하지만 bun보다는 느림 |\n| 실행 속도 (런타임) | **Node.js 대비 2~4배 빠름** (V8 엔진 최적화) | Node.js 표준 | Node.js 표준 (pnpm은 런타임이 아님) |\n| 번들링 속도 | `bun build` 로 **초단위** 번들링 | `webpack`, `esbuild` 등 별도 도구 필요 | 별도 번들러 필요 |\n\n> **벤치마크**: `bun install` 은 10,000개의 의존성을 30초 이내에 설치할 수 있는 반면, npm은 2~3분, pnpm은 약 1분 정도 소요됩니다(환경에 따라 차이 존재).\n\n## 3. 디스크 사용량\n\n- **npm**: 각 프로젝트마다 `node_modules`에 전체 복사본을 저장 → 중복 파일이 많이 발생.\n- **pnpm**: **내용 주소 기반 저장소**(content‑addressable store)를 전역에 두고, 프로젝트마다 심볼릭 링크를 사용 → 중복 최소화, 디스크 사용량 30~50% 절감.\n- **bun**: `bun install` 역시 전역 캐시를 사용하지만, 현재는 pnpm만큼 세밀한 deduplication을 제공하지 않음. 그래도 npm 대비 20~30% 정도 절감.\n\n## 4. 호환성 및 생태계\n\n| 항목 | bun | npm | pnpm |\n|------|-----|-----|------|\n| Node.js API 호환 | 대부분 호환, 일부 네이티브 모듈(특히 C/C++ 애드온)에서 빌드 오류 가능 | 완전 호환 | 완전 호환 (npm 스크립트 그대로 사용) |\n| 패키지 레지스트리 | 기본적으로 npm 레지스트리 사용 | npm 레지스트리 | npm 레지스트리 |\n| 스크립트 실행 | `bun run <script>` (npm script와 동일) | `npm run <script>` | `pnpm run <script>` |\n| 커뮤니티·플러그인 | 아직 초기 단계, 공식 플러그인 제한적 | 가장 큰 생태계, 수많은 플러그인·툴 | npm 호환 플러그인 대부분 사용 가능 |\n\n## 5. 주요 사용 사례\n\n- **bun**: 빠른 프로토타이핑, 작은 프로젝트, 번들링이 필요 없는 서버리스 함수, 성능이 중요한 CLI 툴.\n- **npm**: 대부분의 Node.js 프로젝트, 레거시 코드베이스, 광범위한 CI/CD 파이프라인.\n- **pnpm**: 모노레포, 대규모 프로젝트, 디스크 사용량을 최소화하고 설치 속도를 개선하고 싶을 때.\n\n## 6. 선택 가이드\n\n| 상황 | 추천 도구 |\n|------|-----------|\n| 프로젝트가 작고 빠른 설치·실행이 필요 | **bun** |\n| 기존 Node.js 생태계와 완전 호환이 필요 | **npm** |\n| 멀티패키지(모노레포) 혹은 디스크 절감이 중요한 대규모 프로젝트 | **pnpm** |\n\n## 7. 결론\n\n- `bun`은 **속도와 통합성**을 중시하는 최신 개발자에게 매력적인 선택입니다.\n- `npm`은 **보편성**과 **광범위한 호환성**을 제공하므로 여전히 기본 선택지입니다.\n- `pnpm`은 **효율적인 저장소 관리**와 **모노레포 지원**이 강점이며, npm과 100% 호환됩니다.\n\n프로젝트 요구사항(성능, 디스크 사용량, 생태계 지원)을 고려해 적절한 도구를 선택하면 됩니다.\n\n---\n\n*이 문서는 2025년 기준 정보를 바탕으로 작성되었습니다. 각 툴의 최신 버전 및 업데이트 내용은 공식 문서를 참고하세요.*\n",
      "lastModified": "2026-02-10T00:36:18Z",
      "author": "GitHub Action",
      "status": "published",
      "isDraft": false,
      "isInvalid": false,
      "tags": [
        "bun",
        "pnpm",
        "npm",
        "비교",
        "가이드"
      ],
      "history": [
        {
          "sha": "b4a35c2",
          "message": "chore: 자동 상태 수집 - 2026-02-10 00:36",
          "author": "GitHub Action",
          "authorEmail": "action@github.com",
          "date": "2026-02-10T00:36:18Z",
          "additions": 83,
          "deletions": 0
        }
      ]
    },
    {
      "title": "bun 이란?",
      "slug": "bun/overview",
      "content": "\n## 개요\n\n**bun**은 JavaScript/TypeScript 런타임, 번들러, 그리고 패키지 매니저를 하나로 통합한 도구입니다.\n- **런타임**: Node.js와 호환되는 API를 제공하면서 V8 엔진 대신 **JavaScriptCore**(Apple의 엔진)를 사용합니다.\n- **번들러**: `bun build` 명령을 통해 ES 모듈, CommonJS, TypeScript 등을 빠르게 번들링합니다.\n- **패키지 매니저**: `bun install` 로 npm 레지스트리의 패키지를 설치하며, `package.json`과 `node_modules` 구조를 그대로 사용합니다.\n\n공식 웹사이트: https://bun.sh\nGitHub 레포지터리: https://github.com/oven-sh/bun\n\n## bun을 선택한 이유\n\n| 항목 | 설명 |\n|------|------|\n| **성능** | Zig 언어와 JavaScriptCore를 활용해 파일 I/O, 네트워크, 패키지 설치, 번들링 속도가 기존 Node.js 기반 도구보다 현저히 빠릅니다. 공식 벤치마크에서는 `npm install` 대비 2~3배, `webpack` 대비 5~10배 빠른 결과가 보고되었습니다. |\n| **통합 도구** | 런타임, 번들러, 패키지 매니저가 하나의 바이너리(`bun`)에 포함돼 별도 설치가 필요 없습니다. 개발 환경 설정이 간단해집니다. |\n| **Zero‑Config 지원** | `bun run` 명령만으로 TypeScript 파일을 바로 실행할 수 있어 별도 `ts-node` 설정이 불필요합니다. |\n| **호환성** | 대부분의 npm 패키지를 그대로 사용할 수 있으며, `package.json` 스크립트도 그대로 동작합니다. |\n| **경량 설치 파일** | 단일 실행 파일(≈ 30 MB)로 배포되어 CI/CD 파이프라인에 쉽게 통합할 수 있습니다. |\n\n## 장점\n\n- **빠른 설치 및 실행**\n  - `bun install` 은 병렬 I/O와 캐시 최적화를 통해 npm/yarn 대비 수 초 내에 의존성을 설치합니다.\n- **내장 번들러**\n  - `bun build` 로 ESBuild와 유사한 속도로 번들을 생성하며, 자동 트리쉐이킹과 코드 스플리팅을 지원합니다.\n- **TypeScript 지원**\n  - 별도 트랜스파일러 없이 `bun run src/index.ts` 로 바로 실행 가능.\n- **단일 바이너리**\n  - 런타임, 번들러, 패키지 매니저가 하나의 실행 파일에 포함돼 환경 관리가 단순합니다.\n- **POSIX 호환**\n  - macOS, Linux, Windows(WSL 포함)에서 동일한 바이너리를 사용합니다.\n\n## 단점\n\n- **생태계 성숙도**\n  - npm/yarn에 비해 아직 사용자가 적고, 일부 복잡한 네이티브 모듈(예: `node-gyp` 기반)에서 호환성 문제가 발생할 수 있습니다.\n- **플러그인 및 툴링**\n  - Webpack, Rollup 등 기존 번들러용 플러그인 생태계와 직접 호환되지 않으며, bun 전용 플러그인도 아직 제한적입니다.\n- **문서 및 커뮤니티**\n  - 공식 문서는 꾸준히 업데이트되고 있지만, Stack Overflow 등 커뮤니티 기반 Q&A가 상대적으로 적습니다.\n- **버전 관리**\n  - 현재는 `bun` 자체가 버전 관리 도구 역할을 하지 않으며, 프로젝트별 Node.js 버전 관리와는 별개로 다루어야 합니다.\n\n## 라이선스 및 역사\n\n- **라이선스**: MIT License (오픈 소스, 자유롭게 사용·수정·배포 가능)\n- **주요 연혁**\n  - **2021년 5월**: 프로젝트 초기 설계 및 공개 발표 (Jarred Sumner, Oven.sh 팀)\n  - **2022년 1월**: 첫 베타 버전(`bun v0.1.0`) 공개, GitHub 스타 수 급증\n  - **2022년 8월**: `bun v0.2.0` 에서 패키지 매니저 기능 정식 추가\n  - **2023년 3월**: `bun v0.3.0` 에서 TypeScript 실행 지원 및 `bun build` 도입\n  - **2024년 11월**: `bun v0.5.0` 에서 Windows 지원 및 안정화 버전 출시\n\n자세한 릴리즈 노트는 GitHub Releases 페이지(https://github.com/oven-sh/bun/releases)를 참고하세요.\n\n## 결론\n\nbun은 **속도와 통합성을 중시하는 프로젝트**에 적합한 최신 JavaScript 도구입니다.\n- **성능**이 중요한 CI/CD 파이프라인, 대규모 모노레포, 혹은 빠른 개발 피드백 루프가 필요한 경우 bun을 고려해볼 만합니다.\n- 반면, **특정 네이티브 모듈**이나 **풍부한 플러그인 생태계**가 필수인 경우에는 기존 npm/yarn + Webpack/Rollup 조합이 더 안정적일 수 있습니다.\n\n프로젝트에 적용하기 전, 핵심 의존성이 bun과 호환되는지 확인하고, 작은 파일럿 프로젝트에서 성능 및 호환성을 검증하는 것을 권장합니다.\n\n> **추가 조사 필요**: 복잡한 네이티브 모듈(예: `node-gyp` 기반)과 bun의 호환성 여부는 프로젝트별 테스트가 필요합니다. 공식 문서와 GitHub 이슈 트래커를 지속적으로 확인하세요.\n",
      "lastModified": "2026-02-10T00:36:18Z",
      "author": "SEPilot AI",
      "status": "published",
      "isDraft": false,
      "isInvalid": false,
      "tags": [
        "bun",
        "npm",
        "yarn",
        "패키지 매니저",
        "가이드"
      ],
      "history": [
        {
          "sha": "b4a35c2",
          "message": "chore: 자동 상태 수집 - 2026-02-10 00:36",
          "author": "GitHub Action",
          "authorEmail": "action@github.com",
          "date": "2026-02-10T00:36:18Z",
          "additions": 77,
          "deletions": 0
        }
      ]
    },
    {
      "title": "GitHub Actions로 bun을 쓰는 방법",
      "slug": "bun/github-actions-setup",
      "content": "\n## 개요\nGitHub Actions 워크플로우에서 **bun**(JavaScript 런타임 및 패키지 매니저)을 사용하면 빠른 의존성 설치와 빌드가 가능합니다. 이 문서에서는 bun을 설치하고, 캐시를 활용하며, 일반적인 스크립트를 실행하는 전체 흐름을 예시와 함께 설명합니다.\n\n## 사전 요구 사항\n- 저장소에 `bun`을 사용하도록 설정된 `package.json` 혹은 `bunfig.toml` 파일이 존재해야 합니다.\n- 워크플로우는 Linux(`ubuntu-latest`) 환경을 기준으로 설명합니다. Windows/macOS에서도 동일한 단계가 적용되지만, OS별 경로 차이에 유의하세요.\n\n## 워크플로우 파일 구조\n`.github/workflows/` 디렉터리에 `bun-ci.yml` 과 같은 파일을 생성합니다.\n\n### 1. 워크플로우 트리거\n```yaml\nname: Bun CI\n\non:\n  push:\n    branches: [ main ]\n  pull_request:\n    branches: [ main ]\n```\n\n### 2. Job 정의\n```yaml\njobs:\n  build:\n    runs-on: ubuntu-latest\n```\n\n### 3. 단계별 설정\n#### 3-1. 레포지토리 체크아웃\n```yaml\n    steps:\n      - name: Checkout repository\n        uses: actions/checkout@v4\n```\n\n#### 3-2. bun 설치\nbun은 공식 설치 스크립트를 통해 간단히 설치할 수 있습니다.\n공식 설치 스크립트는 <https://bun.sh> 에서 확인할 수 있습니다.\n```yaml\n      - name: Install bun\n        run: |\n          curl -fsSL https://bun.sh/install | bash\n          echo \"$HOME/.bun/bin\" >> $GITHUB_PATH\n```\n\n#### 3-3. 의존성 캐시\nbun은 `node_modules` 대신 `bun.lockb`와 `~/.bun` 디렉터리를 사용합니다.\n`actions/cache` 액션을 이용해 이 디렉터리를 캐시하면 설치 속도가 크게 향상됩니다.\n```yaml\n      - name: Cache bun dependencies\n        uses: actions/cache@v4\n        with:\n          path: |\n            ~/.bun\n            bun.lockb\n          key: ${{ runner.os }}-bun-${{ hashFiles('bun.lockb') }}\n          restore-keys: |\n            ${{ runner.os }}-bun-\n```\n\n#### 3-4. 의존성 설치\n```yaml\n      - name: Install dependencies\n        run: bun install\n```\n\n#### 3-5. 테스트 실행 (예시)\n```yaml\n      - name: Run tests\n        run: bun test\n```\n\n#### 3-6. 빌드 및 배포 (필요 시)\n```yaml\n      - name: Build project\n        run: bun run build\n```\n\n## 전체 예시 워크플로우\n아래는 위 단계들을 하나의 파일에 통합한 최종 예시입니다.\n\n```yaml\nname: Bun CI\n\non:\n  push:\n    branches: [ main ]\n  pull_request:\n    branches: [ main ]\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout repository\n        uses: actions/checkout@v4\n\n      - name: Install bun\n        run: |\n          curl -fsSL https://bun.sh/install | bash\n          echo \"$HOME/.bun/bin\" >> $GITHUB_PATH\n\n      - name: Cache bun dependencies\n        uses: actions/cache@v4\n        with:\n          path: |\n            ~/.bun\n            bun.lockb\n          key: ${{ runner.os }}-bun-${{ hashFiles('bun.lockb') }}\n          restore-keys: |\n            ${{ runner.os }}-bun-\n\n      - name: Install dependencies\n        run: bun install\n\n      - name: Run tests\n        run: bun test\n\n      - name: Build project\n        run: bun run build\n```\n\n> **주의**: 위 예시에서는 `bun test`와 `bun run build` 스크립트가 `package.json` 혹은 `bunfig.toml`에 정의되어 있다고 가정합니다. 실제 프로젝트에 맞게 스크립트 명령을 조정하세요.\n\n## macOS / Windows 환경에서 사용하기\n- **macOS**: `runs-on: macos-latest` 로 변경하고, `curl` 설치가 기본 제공됩니다.\n- **Windows**: `runs-on: windows-latest` 로 변경하고, PowerShell 스크립트(`Invoke-WebRequest`)를 사용해 bun을 설치합니다. 예시:\n```yaml\n      - name: Install bun on Windows\n        shell: pwsh\n        run: |\n          iwr https://bun.sh/install -UseBasicParsing | iex\n          Add-Content $env:GITHUB_PATH \"$env:USERPROFILE\\.bun\\bin\"\n```\n> Windows에서는 경로 구분자(`\\`)와 환경 변수 사용법에 유의하세요.\n\n## 베스트 프랙티스\n1. **캐시 키 관리**: `bun.lockb` 파일이 변경될 때마다 캐시가 무효화되도록 `hashFiles('bun.lockb')` 를 사용합니다.\n2. **CI 속도 최적화**: `actions/setup-node` 대신 bun 전용 설치 스크립트를 사용하면 불필요한 Node.js 설치를 피할 수 있습니다.\n3. **보안**: 공식 설치 스크립트는 HTTPS를 통해 전달되며, `curl -fsSL` 옵션으로 오류 시 중단됩니다. 필요 시 SHA256 검증을 추가할 수 있습니다.\n4. **버전 고정**: 특정 bun 버전을 사용하려면 `BUN_VERSION` 환경 변수를 설정하고 설치 스크립트에 전달합니다.\n```yaml\n        env:\n          BUN_VERSION: 1.1.12\n```\n\n## 참고 자료\n- Bun 공식 홈페이지 및 설치 가이드: <https://bun.sh>\n- GitHub Actions 공식 문서: <https://docs.github.com/en/actions>\n- actions/cache 액션: <https://github.com/actions/cache>\n\n## 결론\nGitHub Actions에서 bun을 활용하면 의존성 설치와 빌드 속도가 크게 개선됩니다. 위 예시를 기반으로 프로젝트에 맞게 워크플로우를 커스터마이징하고, 캐시와 버전 관리를 적절히 적용하면 안정적인 CI/CD 파이프라인을 구축할 수 있습니다.\n",
      "lastModified": "2026-02-10T00:36:18Z",
      "author": "SEPilot AI",
      "status": "published",
      "isDraft": false,
      "isInvalid": false,
      "tags": [
        "github-actions",
        "bun",
        "CI",
        "CI/CD",
        "node-alternative"
      ],
      "history": [
        {
          "sha": "b4a35c2",
          "message": "chore: 자동 상태 수집 - 2026-02-10 00:36",
          "author": "GitHub Action",
          "authorEmail": "action@github.com",
          "date": "2026-02-10T00:36:18Z",
          "additions": 169,
          "deletions": 0
        }
      ]
    }
  ],
  "tree": [
    {
      "name": "bun",
      "path": "bun",
      "isCategory": true,
      "children": [
        {
          "title": "bun 이란?",
          "slug": "bun/overview"
        },
        {
          "title": "bun과 pnpm, npm의 차이",
          "slug": "bun/comparison-pnpm-npm"
        },
        {
          "title": "GitHub Actions로 bun을 쓰는 방법",
          "slug": "bun/github-actions-setup"
        }
      ]
    },
    {
      "name": "projects",
      "path": "projects",
      "isCategory": true,
      "children": [
        {
          "title": "SEPilot Desktop 소개",
          "slug": "projects/sepilot-desktop"
        },
        {
          "title": "Sepilot Wiki가 어떤 언어/프레임워크로 구현되어 있나요?",
          "slug": "projects/technology-stack",
          "menu": "SEPilot Wiki에 대해"
        }
      ]
    },
    {
      "title": "MAS (Multi Agent System)",
      "slug": "mas-multi-agent-system"
    }
  ]
}