{
  "title": "프론트엔드 API 서비스 레이어 설명",
  "slug": "frontend/api-service-layer",
  "content": "\n## 1. 문서 개요\n**목적**  \n프론트엔드 애플리케이션이 백엔드와 통신할 때 사용하는 공통 API 클라이언트 로직(`src/services/api.ts`)을 이해하고, 유지·보수·확장에 필요한 정보를 제공한다.  \n\n**대상 독자**  \n- 프론트엔드 개발자 (신규 입사자 포함)  \n- QA 엔지니어 및 테스트 자동화 담당자  \n- 아키텍처 리뷰어 및 문서 담당자  \n\n**역할**  \n`services/api.ts`는 HTTP 요청/응답 처리, 에러 핸들링, 토큰 자동 갱신 등 **백엔드와의 통신 전반**을 캡슐화한다. 이를 통해 UI 레이어는 비즈니스 로직에 집중하고, 네트워크 관련 구현은 한 곳에 집중시킬 수 있다.  \n\n**커버리지 분석 결과 요약**  \n\n| 항목 | 내용 |\n|------|------|\n| **모듈** | `services/api.ts` |\n| **소스 경로** | `src/services/api.ts` |\n| **중요도** | **high** (백엔드와의 모든 통신을 담당) |\n| **문서 필요 사유** | 요청/응답 흐름, 에러 처리, 토큰 재발급 로직 등 핵심 로직이 포함돼 있어 신규 개발자와 운영팀 모두에게 필수적인 가이드가 필요함 |\n\n---\n\n## 2. 서비스 레이어 아키텍처 개요\n### 2.1 전체 프론트엔드 아키텍처에서 위치\n- UI 컴포넌트 → **서비스 레이어(`api.ts`)** → HTTP 클라이언트(Axios 혹은 fetch) → 백엔드 API  \n- 서비스 레이어는 UI와 네트워크 사이의 **추상화 계층**으로, 데이터 페칭·전송 로직을 중앙집중화한다. (Medium 기사 “프론트엔드 아키텍처: API 요청 관리” 참고)  \n\n### 2.2 `services/api.ts` 의 책임 범위\n- HTTP 메서드별 헬퍼 함수 제공 (GET, POST, PUT, DELETE 등)  \n- 공통 헤더(Authorization, Content-Type 등) 자동 삽입  \n- 응답 정규화 및 성공/실패 판별  \n- 전역 에러 로깅·모니터링 연동  \n- Access/Refresh 토큰 자동 갱신 로직 구현  \n\n### 2.3 외부 의존성\n| 의존성 | 용도 | 참고 |\n|--------|------|------|\n| **Axios** (또는 fetch) | HTTP 요청/응답 처리 | 일반적인 프론트엔드 API 클라이언트 구현에 사용됨 (Medium) |\n| **토큰 저장소** (예: `localStorage`, `sessionStorage`, 쿠키) | Access/Refresh 토큰 보관 | 보안 고려사항 섹션에서 상세히 다룸 |\n| **인터셉터** | 요청 전/후 공통 로직(헤더 삽입, 토큰 재발급) | Axios 인터셉터 활용이 일반적 |\n| **타입 정의 파일** (`*.d.ts`) | API 응답 타입 및 파라미터 정의 | TypeScript 기반 프로젝트에서 타입 안전성 확보 |\n\n---\n\n## 3. 파일 및 디렉터리 구조\n```\nsrc/\n └─ services/\n     ├─ api.ts          ← 메인 API 클라이언트\n     ├─ interceptors.ts ← 요청·응답 인터셉터 정의 (예시)\n     └─ types.ts        ← API 요청·응답 인터페이스\n```\n\n- `api.ts`는 **public API**(예: `get`, `post`, `put`, `delete`)를 export하고, 내부적으로 인터셉터와 타입을 활용한다.  \n- `interceptors.ts`(존재한다면)에서는 토큰 자동 갱신 로직과 에러 전역 처리 로직을 구현한다.  \n- `types.ts`는 각 엔드포인트가 반환하는 데이터 구조를 정의해 TypeScript 컴파일 타임에 검증한다.  \n\n> **추가 조사 필요**: 현재 레포지토리에서 실제 `interceptors.ts`·`types.ts` 파일 존재 여부와 구체적인 export 형태를 확인해야 함.\n\n---\n\n## 4. 핵심 기능 상세\n### 4.1 요청(Request) 처리\n- **헬퍼 함수**: `get<T>(url, config)`, `post<T>(url, data, config)` 등 타입 파라미터 `T`를 통해 응답 타입을 명시한다.  \n- **파라미터 직렬화**: 객체를 쿼리스트링으로 변환해 GET 요청에 포함한다. (Axios 기본 동작)  \n- **공통 헤더 삽입**: `Authorization: Bearer <accessToken>` 및 `Content-Type: application/json` 등을 자동으로 추가한다.  \n\n### 4.2 응답(Response) 처리\n- **정규화**: 서버가 반환하는 `{ data, meta, pagination }` 형태를 일관된 구조로 변환한다.  \n- **성공/실패 판별**: HTTP 2xx는 성공, 그 외는 실패로 간주하고, `response.status`에 따라 분기한다.  \n- **페이징·메타데이터 추출**: `meta` 혹은 `pagination` 필드를 별도 객체로 분리해 UI 레이어에 전달한다.  \n\n### 4.3 에러 핸들링\n- **네트워크 오류·타임아웃**: Axios 인터셉터에서 `error.code`를 검사해 재시도 정책을 적용한다.  \n- **HTTP 상태 코드 별 처리**: 401(Unauthorized) → 토큰 재발급 흐름; 403(Forbidden) → 접근 제한 메시지; 5xx → 전역 알림 및 로깅.  \n- **사용자 친화적 메시지 매핑**: 서버 오류 코드를 프론트엔드 메시지(`'서버에 문제가 발생했습니다.'`)와 매핑한다.  \n- **전역 로깅·모니터링 연동**: Sentry·Datadog 등 외부 모니터링 툴에 에러 정보를 전송한다.  \n\n### 4.4 토큰 자동 갱신\n- **흐름**:  \n  1. 요청 인터셉터에서 `Authorization` 헤더에 현재 Access Token 삽입.  \n  2. 401 응답이 오면 응답 인터셉터가 Refresh Token을 사용해 새로운 Access Token을 발급받는다.  \n  3. 재발급 성공 시 원래 요청을 **재시도**하고, 실패 시 로그아웃 처리한다.  \n- **무한 루프 방지**: 재시도 횟수를 1회로 제한하고, 재시도 중에도 401이 발생하면 즉시 로그아웃한다.  \n\n> **추가 조사 필요**: 현재 구현에서 Refresh Token 저장 위치와 재발급 API 엔드포인트가 어떻게 정의돼 있는지 확인이 필요함.\n\n### 4.5 복잡한 데이터 페칭 문제와 권장 패턴\n#### Problem statement – useQuery & Promise.all 스파게티\n마이크로서비스 기반 백엔드에서는 하나의 엔티티가 여러 다른 엔티티의 ID를 참조합니다.  \n예시 흐름:\n\n1. 티켓 조회 → `assigneeId` 반환  \n2. 담당자 조회 → `teamId` 반환  \n3. 팀 조회 → `leadUserId` 반환  \n4. 워처 목록 조회 → 각각 `userId` 반환  \n5. 역할(Role) 조회 등…\n\n각 ID마다 별도 API 호출을 수행하면 **중복 요청**이 빈번해지고, 컴포넌트마다 `useQuery`, `Promise.all`, `null 체크` 로직이 난무합니다. 결과적으로:\n\n- **네트워크 트래픽 급증**  \n- **렌더링 최적화 어려움** (불필요한 재렌더)  \n- **타입 안전성 저하** (any/unknown 사용)  \n- **보일러플레이트 증가** (새 필드 추가 시 코드 복잡도 급증)\n\n#### Recommended patterns\n| 패턴 | 핵심 아이디어 | 적용 시 장점 |\n|------|---------------|--------------|\n| **TanStack Query (React Query)** | 쿼리 키 기반 캐싱·중복 제거, 자동 재시도, 배치 옵션 | 동일 키에 대한 중복 호출 방지, UI 상태 관리 간소화 |\n| **SWR** | Stale‑While‑Revalidate 전략, 전역 캐시 | 간단한 API 호출에 적합, 자동 재검증 |\n| **Batching / Reference Resolver** | 여러 ID를 한 번에 묶어 백엔드에 요청 → 중복 ID 제거 | 네트워크 호출 횟수 최소화, 서버 부하 감소 |\n| **@nimir/references** (오픈소스) | `defineReferences` 로 소스와 필드 매핑 정의 → 자동 배치·중복·캐시·중첩 탐색 제공 | 타입‑안전, 최대 10단계 중첩 지원, React Hook 으로 손쉽게 사용 |\n\n#### Refactoring example with `@nimir/references`\n```ts\n// 1️⃣ reference 정의 (src/references.ts)\nimport { defineReferences } from '@nimir/references';\n\nexport const refs = defineReferences(c => ({\n  User: c.source({ batch: ids => fetchUsers(ids) }),   // ids: string[]\n  Team: c.source({ batch: ids => fetchTeams(ids) }),\n  Role: c.source({ batch: ids => fetchRoles(ids) }),\n}));\n```\n\n```ts\n// 2️⃣ 컴포넌트에서 사용 (React + TanStack Query)\nimport { refs } from '@/references';\nimport { useQuery } from '@tanstack/react-query';\nimport { useGetTicket } from '@/services/ticket';\n\nfunction TicketCard({ ticketId }: { ticketId: string }) {\n  // 기본 티켓 조회 (React Query)\n  const { data: ticket, isLoading } = useQuery(['ticket', ticketId], () => useGetTicket(ticketId));\n\n  // reference resolver를 이용해 연관 데이터 일괄 해결\n  const { result, status, error } = refs.use(ticket, {\n    fields: {\n      assigneeId: {\n        source: 'User',\n        fields: {\n          teamId: {\n            source: 'Team',\n            fields: { leadUserId: 'User' },\n          },\n          roleIds: 'Role',\n        },\n      },\n      watcherIds: 'User',\n    },\n  });\n\n  if (isLoading || status === 'loading') return <Spinner />;\n  if (error) return <ErrorBox>{error.message}</ErrorBox>;\n\n  return (\n    <div>\n      <h2>{ticket.title}</h2>\n      <p>Assignee: {result.assigneeIdT?.name ?? '—'}</p>\n      <p>Team Lead: {result.assigneeIdT?.teamIdT?.leadUserIdT?.name ?? '—'}</p>\n      <p>Watchers: {result.watcherIdsT?.map(u => u.name).join(', ')}</p>\n    </div>\n  );\n}\n```\n\n**핵심 포인트**\n- `fetchUsers`, `fetchTeams`, `fetchRoles` 등 **배치 API**를 한 번만 호출하고, 내부에서 중복 ID를 자동 제거합니다.  \n- `result` 객체에 원본 필드 뒤에 `T`(예: `assigneeIdT`)가 붙어 **타입‑안전하게** 변환된 데이터를 제공합니다.  \n- React Query와 결합하면 **데이터 페칭 상태**(`loading`, `error`)를 그대로 재사용할 수 있어 UI 로직이 간결해집니다.  \n\n#### 기타 적용 팁\n- **Depth limit**: `@nimir/references`는 기본 10단계 깊이 제한을 두어 무한 순환을 방지합니다. 필요 시 `c.options({ depth: 20 })` 로 조정 가능.  \n- **플러그인 캐시**: 메모리 캐시 외에 `IndexedDB`(via `idb-keyval`) 혹은 Redis 플러그인을 연결해 페이지 전환 시에도 데이터 재사용을 극대화합니다.  \n- **SWR와 혼용**: `refs.use` 로 반환된 데이터를 `useSWR` 로 감싸면 자동 재검증 및 stale‑while‑revalidate 전략을 동시에 활용할 수 있습니다.\n\n---\n\n## 5. 사용 예시\n- **기본 GET 호출**  \n  `const users = await get<User[]>('/api/users');`  \n\n- **POST with JSON Body**  \n  `await post('/api/posts', { title, content });`  \n\n- **파일 업로드 (멀티파트)**  \n  `await post('/api/upload', formData, { headers: { 'Content-Type': 'multipart/form-data' } });`  \n\n- **인증이 필요한 엔드포인트**  \n  `await get('/api/profile'); // 인터셉터가 자동으로 토큰 삽입`  \n\n> 실제 코드 예시는 프로젝트 내 `src/services/api.ts`를 참고하고, 필요 시 `interceptors.ts`에 정의된 로직을 검토한다.\n\n---\n\n## 6. 확장 및 커스터마이징\n- **인터셉터 추가/제거**: `apiInstance.interceptors.request.use(customInterceptor)` 형태로 새로운 로직을 삽입한다.  \n- **커스텀 헤더 삽입**: 호출 시 `config.headers`에 추가하면 인터셉터가 병합한다.  \n- **테스트 환경(모킹) 설정**: Jest·MSW(Mock Service Worker)를 사용해 `api.ts`의 Axios 인스턴스를 모킹한다.  \n\n---\n\n## 7. 테스트 전략\n| 테스트 종류 | 대상 | 주요 포인트 |\n|------------|------|-------------|\n| **단위 테스트** | 헬퍼 함수(`get`, `post` 등) | 파라미터 직렬화, 헤더 삽입 검증 (Jest + axios-mock-adapter) |\n| **통합 테스트** | 실제 API 엔드포인트와 연동 | 성공/실패 시 응답 구조, 토큰 재발급 흐름 검증 |\n| **CI/CD 자동화** | Pull Request 단계 | `npm test` 실행, 커버리지 80% 이상 목표 (nodebestpractices 참고) |\n\n---\n\n## 8. 보안 고려사항\n- **토큰 저장소 선택**:  \n  - `httpOnly` 쿠키 → XSS 방어에 유리하지만 CSRF 방어 필요.  \n  - `localStorage`/`sessionStorage` → XSS 위험 존재, 토큰 암호화 필요.  \n- **CSRF 방어**: `SameSite=Lax` 쿠키 설정 또는 CSRF 토큰 헤더 전송.  \n- **XSS 예방**: 모든 입력값을 이스케이프하고, Content Security Policy(CSP) 적용.  \n- **민감 데이터 마스킹**: 로그에 토큰·비밀번호 등은 `***` 로 마스킹하고, 로깅 레벨을 조절한다.  \n\n---\n\n## 9. 성능 최적화\n- **요청 중복 방지(디듀핑)**: 동일 URL·파라미터에 대한 병렬 요청을 하나로 합친 뒤 결과를 공유한다.  \n- **캐시 전략**:  \n  - 메모리 캐시(React Query, SWR) → 최신 데이터와 재요청 최소화.  \n  - IndexedDB 혹은 Service Worker 캐시 → 오프라인 지원.  \n- **타임아웃·재시도 정책**: Axios `timeout` 옵션과 지수 백오프 재시도 로직을 적용한다.  \n\n---\n\n## 10. 베스트 프랙티스\n- **API 명명 규칙**: 리소스는 명사 형태, 동사는 HTTP 메서드로 표현한다 (velog “22 Best Practices” 참고).  \n- **에러 코드·메시지 표준화**: 서버와 클라이언트가 공유하는 에러 코드 사전 정의.  \n- **문서·타입 정의 유지**: `src/services/types.ts`에 인터페이스를 선언하고, 변경 시 문서와 테스트를 동시에 업데이트한다.  \n\n---\n\n## 11. 마이그레이션 가이드\n1. **기존 fetch 기반 구현 파악** – 현재 `fetch` 호출이 있는 파일을 식별한다.  \n2. **API 레이어 설치** – `src/services/api.ts`와 의존 파일을 프로젝트에 추가한다.  \n3. **호출 교체** – `fetch(url, options)` → `get<T>(url)` 혹은 `post<T>(url, data)` 로 교체한다.  \n4. **헤더·토큰 로직 검증** – 새 레이어가 자동으로 Authorization 헤더를 삽입하는지 확인한다.  \n5. **테스트 실행** – 기존 단위 테스트와 새 레이어 테스트를 모두 통과하는지 검증한다.  \n\n---\n\n## 12. Next.js 16 캐싱 전략 및 프로덕션 패턴\nNext.js 16에서는 **데이터 기반 캐싱**이 핵심 개념으로 도입되었습니다. `fetch` 호출마다 `next` 옵션을 통해 재검증, 태그, Draft Mode 등을 선언적으로 제어할 수 있습니다. 아래는 주요 기능과 실제 프로덕션에서 활용하는 패턴을 정리한 내용입니다.\n\n### 12.1 Revalidation (재검증)\n- **기본 개념**: `next: { revalidate: <seconds> }` 옵션은 ISR과 유사하게 동작하지만, fetch 레벨에서 직접 지정한다.  \n- **동작 방식**: 지정된 초가 지나면 백그라운드에서 새 데이터를 가져와 캐시를 업데이트한다. 사용자는 기존(stale) 데이터를 즉시 보며, 다음 요청부터 최신 데이터가 제공된다.  \n\n```tsx\nexport default async function Page() {\n  const data = await fetch('/api/posts', {\n    next: { revalidate: 60 }   // 60초마다 백그라운드 재검증\n  }).then(res => res.json());\n\n  return <PostsList posts={data} />;\n}\n```\n\n- **강제 재검증**: 서버 액션이나 API 라우트에서 `revalidatePath('/posts')` 를 호출하면 해당 경로의 캐시를 즉시 무효화한다.  \n\n```ts\nexport async function POST(request: Request) {\n  // DB 업데이트 로직 …\n  await revalidatePath('/posts');   // 지정 경로 캐시 즉시 무효화\n  return new Response('OK');\n}\n```\n\n### 12.2 Tags 기반 무효화\n- **태그 개념**: `next: { tags: ['tagName'] }` 로 데이터 의존성을 선언하면, 동일 태그를 가진 모든 캐시 엔트리를 한 번에 무효화할 수 있다.  \n- **사용 예시**  \n\n```tsx\n// posts/[id]/page.tsx\nexport default async function Post({ params }) {\n  const post = await fetch(`/api/posts/${params.id}`, {\n    next: { tags: ['post'] }\n  }).then(res => res.json());\n  return <PostDetail post={post} />;\n}\n\n// comments/[postId]/page.tsx\nexport default async function Comments({ params }) {\n  const comments = await fetch(`/api/comments?postId=${params.postId}`, {\n    next: { tags: ['comment'] }\n  }).then(res => res.json());\n  return <CommentsList comments={comments} />;\n}\n```\n\n- **태그 무효화**: 댓글이 추가될 때 `revalidateTag('comment')` 를 호출하면, `comment` 태그와 연결된 모든 페이지가 재검증된다.  \n\n```ts\nexport async function POST(request: Request) {\n  // 댓글 저장 로직 …\n  await revalidateTag('comment');   // 관련 캐시 전체 무효화\n  return new Response('Comment added');\n}\n```\n\n### 12.3 Draft Mode 활용법\n- **개념**: Draft Mode는 아직 퍼블리시되지 않은 콘텐츠를 실시간으로 미리보기 할 수 있는 프리뷰 환경이다. 활성화된 요청은 캐시를 건너뛰고 최신 데이터를 직접 조회한다.  \n- **활성화 / 비활성화**  \n\n```ts\n// app/api/draft/activate/route.ts\nimport { draftMode } from 'next/headers';\nexport async function GET() {\n  draftMode().enable();   // Draft Mode 켜기\n  return new Response('Draft mode enabled');\n}\n\n// app/api/draft/deactivate/route.ts\nimport { draftMode } from 'next/headers';\nexport async function GET() {\n  draftMode().disable();  // Draft Mode 끄기\n  return new Response('Draft mode disabled');\n}\n```\n\n- **Draft Mode와 캐시**: Draft Mode가 켜진 경우 `next: { revalidate: 0 }` 로 no‑cache를 지정한다.  \n\n```tsx\nexport default async function Page() {\n  const data = await fetch('/api/posts', {\n    next: { revalidate: 0 }   // Draft Mode이면 캐시 무시\n  }).then(res => res.json());\n  return <PostsList posts={data} />;\n}\n```\n\n### 12.4 실제 프로덕션 캐시 파이프라인 예시\n1. **데이터 레이어와 캐시 전략 분리**  \n   - API 라우트에서 비즈니스 로직을 수행하고, `revalidateTag`/`revalidatePath` 로 캐시를 관리한다.  \n   - 페이지/컴포넌트에서는 `fetch(..., { next: { tags, revalidate } })` 만 선언해 의존성을 명시한다.  \n\n2. **태그 기반 무효화 + 재검증 조합**  \n\n```ts\n// 게시글 업데이트 API\nexport async function PUT(request: Request) {\n  // DB 업데이트 …\n  await Promise.all([\n    revalidateTag('post'),      // 게시글 페이지 무효화\n    revalidateTag('comment')    // 댓글 리스트 무효화\n  ]);\n  return new Response('Post updated');\n}\n```\n\n3. **ISR + Draft Mode 혼합**  \n\n```tsx\nexport default async function Post({ params }) {\n  const isDraft = draftMode().isEnabled;\n  const data = await fetch(`/api/posts/${params.slug}`, {\n    next: {\n      revalidate: isDraft ? 0 : 30,   // Draft이면 no‑cache, 일반이면 30초 ISR\n      tags: ['post']\n    }\n  }).then(res => res.json());\n  return <PostDetail post={data} />;\n}\n```\n\n4. **Edge Middleware와 캐시 헤더**  \n   - CDN 레벨에서 세밀한 캐시 정책을 적용하기 위해 `Cache-Control` 헤더를 직접 설정한다.  \n\n```ts\n// middleware.ts\nimport { NextResponse } from 'next/server';\nexport function middleware(request) {\n  const response = NextResponse.next();\n  if (request.nextUrl.pathname.startsWith('/api/')) {\n    response.headers.set('Cache-Control', 'public, max-age=5, stale-while-revalidate=30');\n  }\n  return response;\n}\n```\n\n위 패턴들을 조합하면 **성능**, **데이터 신선도**, **정밀한 무효화**를 동시에 만족하는 프로덕션 수준의 캐시 전략을 구현할 수 있다.\n\n---\n\n## 13. FAQ\n- **Q: 토큰 갱신이 실패하면 어떻게 해야 하나요?**  \n  A: 인터셉터에서 401 응답이 두 번 연속 발생하면 `logout()`을 호출해 세션을 종료하고 로그인 페이지로 리다이렉트한다.  \n\n- **Q: CORS 오류가 발생했을 때 점검 포인트는?**  \n  A: 서버의 `Access-Control-Allow-Origin` 헤더와 프론트엔드 요청에 포함된 `Origin`이 일치하는지, 프리플라이트 요청이 정상 처리되는지 확인한다.  \n\n- **Q: 테스트 환경에서 실제 API 호출을 차단하려면?**  \n  A: Jest 설정 파일에 `axios` 모듈을 `jest.mock('axios')` 로 모킹하거나, MSW를 사용해 네트워크 요청을 가로채고 가짜 응답을 반환한다.  \n\n---\n\n## 14. 참고 자료\n- **프론트엔드 아키텍처: API 요청 관리** – Medium (https://medium.com/@junep/%ED%94%84%EB%A0%88%EC%9D%B4%ED%8A%B8-%EC%95%84%ED%82%A4%ED%85%90%EC%B2%B4-%EC%97%94%EC%8B%9C-%EC%9D%B8%ED%84%B0%ED%8F%AC%EC%9D%B8-113c31d7bcee)  \n- **Grab Front End Guide** – 네이버 블로그 (https://m.blog.naver.com/magnking/221149133410)  \n- **Node.js Best Practices (Korean)** – GitHub (https://github.com/goldbergyoni/nodebestpractices/blob/master/README.korean.md)  \n- **API Design Best Practices** – velog (https://velog.io/@juunini/%EB%B8%94%EB%84%88-%22-22-Best-Practices-to-Take-Your-API-Design-Skills-to-the-Next-Level)  \n- **Next.js 16 캐싱 설명: 재검증, 태그, Draft Mode, 실제 프로덕션 패턴** – euno.news (https://euno.news/posts/ko/nextjs-16-caching-explained-revalidation-tags-draf-2d1797)  \n- **React 데이터 페칭 스파게티 해결** – euno.news (https://euno.news/posts/ko/i-got-tired-of-usequerypromiseall-spaghetti-so-i-b-1d6841)  \n- **@nimir/references** – npm (https://www.npmjs.com/package/@nimir/references)  \n- **TanStack Query 공식 블로그** – https://tanstack.com/query/v4  \n\n---",
  "lastModified": "2026-02-28T18:06:35Z",
  "author": "SEPilot AI",
  "status": "published",
  "isDraft": false,
  "isInvalid": false,
  "tags": [
    "frontend",
    "api",
    "service-layer",
    "documentation",
    "coverage"
  ],
  "order": 1,
  "history": [
    {
      "sha": "c054f50",
      "message": "chore: 뉴스 인텔리전스 보고서 업데이트",
      "author": "GitHub Action",
      "authorEmail": "action@github.com",
      "date": "2026-02-28T18:06:35Z",
      "isAutoCommit": false,
      "additions": 0,
      "deletions": 0
    }
  ]
}