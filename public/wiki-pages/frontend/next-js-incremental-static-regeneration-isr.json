{
  "title": "Next.js Incremental Static Regeneration (ISR) 가이드",
  "slug": "frontend/next-js-incremental-static-regeneration-isr",
  "content": "\n## 1. 개요\n- **ISR이란?**  \n  Incremental Static Regeneration(점진적 정적 재생성)은 Next.js가 이미 생성된 정적 페이지를 일정 시간 간격 혹은 온‑디맨드 방식으로 백그라운드에서 재생성하여 최신 데이터를 반영하도록 하는 기능입니다. 최초 요청 시는 캐시된 정적 HTML을 즉시 제공하고, 이후 필요에 따라 페이지를 업데이트합니다【euno.news】.  \n- **SSR·SSG와의 차이**  \n  - **SSR**(Server‑Side Rendering): 매 요청마다 서버가 데이터를 가져와 HTML을 새로 생성 → 응답 시간이 상대적으로 느림, 서버 부하 증가.  \n  - **SSG**(Static Site Generation): 빌드 시점에 모든 페이지를 정적으로 생성 → 빠른 응답하지만 콘텐츠가 변경될 때 전체 재배포가 필요.  \n  - **ISR**: SSG와 유사하게 정적 HTML을 제공하지만, 지정된 `revalidate` 간격이 지나면 백그라운드에서 페이지를 재생성해 최신 콘텐츠를 반영합니다. 빌드 시간과 서버 부하를 크게 줄이면서도 최신성을 유지합니다【dev.to】.  \n- **문서 목표 & 독자**  \n  - Next.js 13 이상을 사용하고자 하는 프론트엔드 개발자  \n  - ISR을 처음 접하거나 기존 프로젝트에 적용하려는 엔지니어  \n  - 성능·SEO 최적화를 목표로 하는 팀 리더  \n\n## 2. 사전 준비\n| 항목 | 권장 사양 |\n|------|-----------|\n| **Next.js 버전** | 13 이상 (App Router 권장) |\n| **Node.js** | 최신 LTS 버전 (예: 18.x) |\n| **배포 환경** | Vercel, Netlify, 혹은 Edge 지원 서버 (CDN 캐시 활용) |\n| **프로젝트 초기화** | `npx create-next-app@latest` 로 시작 후 `app/` 디렉터리 구조 확인 |\n\n## 3. ISR 핵심 개념\n- **정적 페이지와 캐시**: 최초 요청 시 Next.js는 빌드 시점에 생성된 정적 HTML을 CDN 캐시(또는 서버 캐시)에 저장하고, 이후 요청은 이 캐시된 파일을 바로 반환합니다【euno.news】.  \n- **`revalidate` 값**: 초 단위 정수값으로, 해당 시간이 경과하면 다음 요청 시 페이지 재생성을 트리거합니다. 예시: `export const revalidate = 60; // 60초마다 재생성`【euno.news】.  \n- **백그라운드 재생성 흐름**  \n  1. 사용자 요청 → 캐시된 정적 페이지 제공  \n  2. `revalidate` 기간이 지나면 요청을 받는 순간 Next.js가 백그라운드에서 새 페이지를 생성  \n  3. 새 페이지가 성공하면 캐시를 교체하고 이후 요청에 최신 페이지 제공【euno.news】.  \n- **온‑디맨드 재검증(On‑Demand Revalidation)**: 웹훅 등 외부 트리거를 통해 특정 페이지·태그만 즉시 재생성하도록 할 수 있습니다. 이는 `revalidatePath`·`revalidateTag` API와 결합해 구현됩니다【dev.to】.  \n\n## 4. ISR 작동 원리\n1. **최초 요청** → 정적 HTML이 CDN 캐시에서 즉시 반환.  \n2. **`revalidate` 기간 경과** → 다음 요청 시 기존 캐시를 그대로 반환하면서 백그라운드에서 페이지를 재생성.  \n3. **새 페이지 생성 완료** → 캐시가 교체되고, 이후 모든 방문자는 최신 콘텐츠를 받음.  \n4. **CDN vs Next.js 서버 캐시**  \n   - **CDN 캐시**: 전 세계 엣지 노드에 정적 파일을 저장해 지연 시간 최소화.  \n   - **Next.js 서버 캐시**: ISR 재생성 로직이 실행되는 서버 측 캐시이며, 재생성 후 CDN에 새로운 파일을 푸시합니다.  \n\n## 5. 구현 방법\n### 5.1 페이지 레벨에서 ISR 적용 (Pages Router)\n- 페이지 파일(`pages/posts/[id].tsx`) 상단에 `export const revalidate = <seconds>;` 선언.  \n- `getStaticProps` 안에서 `fetch` 로 데이터를 가져와 반환.  \n\n예시 (inline):\n```tsx\nexport const revalidate = 120; // 2분마다 재생성\nexport async function getStaticProps(context) {\n  const res = await fetch(`https://example.com/api/post/${context.params.id}`);\n  const post = await res.json();\n  return { props: { post } };\n}\n```\n*(위 코드는 실제 파일에 넣어야 하며, `export const revalidate` 선언만으로 ISR이 활성화됩니다.)*【euno.news】\n\n### 5.2 App Router에서 ISR 적용\n- **Server Component** 내부 `fetch`에 `next: { revalidate: <seconds> }` 옵션을 전달하거나 파일 최상단에 `export const revalidate = <seconds>;` 선언.  \n\n예시 (inline):\n```tsx\nexport const revalidate = 60; // 1분마다 재생성\nexport default async function Page() {\n  const res = await fetch('https://example.com/items', { next: { revalidate: 60 } });\n  const items = await res.json();\n  return (\n    <ul>\n      {items.map(item => <li key={item.id}>{item.name}</li>)}\n    </ul>\n  );\n}\n```\n※ `next: { revalidate }` 옵션은 fetch 호출마다 개별 재생성 주기를 지정할 수 있습니다【euno.news】.\n\n### 5.3 데이터 소스와 연동\n- **외부 API**: `fetch` 혹은 `axios` 등으로 데이터를 가져오고, `revalidate` 옵션을 통해 캐시 제어.  \n- **CMS (예: Contentful, Sanity)**: 웹훅을 이용해 온‑디맨드 재검증을 트리거하면 전체 사이트 재배포 없이 최신 콘텐츠가 반영됩니다【dev.to】.  \n- **데이터베이스**: 서버 컴포넌트에서 직접 DB 연결 후 `fetch` 옵션 없이도 `export const revalidate` 로 주기적 재생성을 관리할 수 있습니다.  \n\n## 6. 온‑디맨드 재검증 구현\n- **API**: `revalidatePath(path)`와 `revalidateTag(tag)`는 Next.js 13+에서 제공하는 서버‑사이드 함수이며, 특정 경로나 태그에 대한 캐시를 즉시 무효화합니다【nextjs.org】.  \n- **웹훅 연동 흐름**  \n  1. CMS에서 콘텐츠가 업데이트될 때 웹훅 호출 → Next.js API 라우트(`/api/revalidate`)에 POST 요청.  \n  2. API 라우트에서 `revalidatePath('/posts/123')` 혹은 `revalidateTag('blog')` 실행.  \n  3. 해당 페이지가 다음 요청 시 백그라운드에서 재생성되고 최신 HTML이 제공됩니다.  \n\n예시 (inline):\n```tsx\n// pages/api/revalidate.ts\nimport { NextApiRequest, NextApiResponse } from 'next';\nexport default async function handler(req: NextApiRequest, res: NextApiResponse) {\n  if (req.method !== 'POST') return res.status(405).end();\n  const { path } = req.body;\n  try {\n    await res.revalidate(path);\n    return res.json({ revalidated: true });\n  } catch (err) {\n    return res.status(500).json({ error: 'Failed to revalidate' });\n  }\n}\n```\n*(위 코드는 `res.revalidate` (Next.js 12) 혹은 `revalidatePath` (Next.js 13) 중 사용 가능한 함수를 선택해 적용합니다.)*【dev.to】\n\n## 7. 성능·SEO 최적화 효과\n- **응답 시간 단축**: CDN 캐시된 정적 HTML을 즉시 제공하므로 페이지 로드가 매우 빠릅니다【euno.news】.  \n- **검색 엔진 인덱싱**: 정적 HTML은 크롤러가 빠르게 파싱할 수 있어 SEO 점수가 향상됩니다【euno.news】.  \n- **빌드 시간·비용 절감**: 전체 사이트를 매번 재빌드하지 않고, 변경된 페이지만 재생성하므로 대규모 프로젝트에서 빌드 비용이 크게 감소합니다【promleeblog】.  \n\n## 8. 베스트 프랙티스\n| 항목 | 권장 가이드라인 |\n|------|-------------------|\n| **`revalidate` 간격** | 콘텐츠 업데이트 빈도에 따라 설정. 예: 뉴스 사이트는 30~60초, 블로그는 몇 시간~하루 단위. |\n| **캐시 무효화 전략** | 실시간 업데이트가 중요한 경우 온‑디맨드 재검증 사용, 그렇지 않으면 시간 기반 `revalidate`만으로 충분. |\n| **버전 관리** | API 응답에 `ETag` 혹은 `Last-Modified` 헤더를 포함해 데이터 일관성을 검증하고, 재생성 실패 시 기존 캐시 유지. |\n| **에러 핸들링** | `fetch` 실패 시 fallback UI 제공 및 로그 남기기. 재생성 오류는 Vercel 로그(`next build`/`next start`)에서 확인 가능. |\n\n## 9. 트러블슈팅 & 흔히 발생하는 문제\n- **재생성 실패**: 서버 로그에 `Error: Failed to fetch` 혹은 `revalidation failed` 메시지가 출력됩니다. API 엔드포인트 접근 권한, 네트워크 오류 등을 점검합니다.  \n- **캐시가 업데이트되지 않음**: `revalidate` 값이 너무 크게 설정됐거나, CDN이 오래된 파일을 보관하고 있을 수 있습니다. CDN 설정(Edge TTL)과 `Cache-Control` 헤더를 확인하세요.  \n- **Vercel 제한**: Vercel 무료 플랜에서는 ISR 호출 횟수에 제한이 있을 수 있습니다. 플랜 업그레이드 혹은 온‑디맨드 재검증 사용량을 모니터링합니다【euno.news】.  \n\n## 10. 배포·모니터링\n- **배포 플랫폼**  \n  - **Vercel**: `next build` → `next start` 자동 실행, ISR 기본 지원.  \n  - **Netlify**: `next-on-netlify` 플러그인 사용 시 ISR 지원.  \n  - **자체 서버**: Node.js 환경에서 `next start` 실행 후 CDN 앞에 배포.  \n- **ISR 상태 확인**  \n  - `next build` 로그에 `ISR` 관련 메시지가 표시됩니다.  \n  - Vercel Analytics 혹은 Prometheus와 같은 모니터링 도구로 `revalidate` 호출 횟수와 재생성 성공률을 추적합니다【nextjs.org】.  \n- **모니터링 예시**  \n  - **Prometheus**: `nextjs_isr_success_total`, `nextjs_isr_error_total` 메트릭 수집.  \n  - **Vercel Analytics**: 페이지 로드 시간, 캐시 히트 비율 확인.  \n\n## 11. 결론\n- **비즈니스 가치**: ISR은 정적 페이지의 빠른 응답성과 최신 콘텐츠 제공을 동시에 만족시켜 사용자 만족도와 SEO를 동시에 끌어올립니다. 빌드 비용 절감과 배포 주기 단축은 운영 효율성을 크게 향상시킵니다.  \n- **향후 전망**: Next.js는 ISR 기능을 지속적으로 개선하고 있으며, Edge Runtime과 결합된 더 정교한 캐시 제어가 기대됩니다. 최신 Next.js 릴리즈 노트를 주기적으로 확인하고, 커뮤니티(Next.js Discord, GitHub Discussions)에서 베스트 프랙티스를 공유받는 것이 좋습니다.  \n- **추가 학습 자료**  \n  - 공식 문서: “Incremental Static Regeneration” 가이드 (nextjs.org)  \n  - Dev.to 포스트: “A guide to Incremental Static Regeneration (ISR) in Next.js using CMS data”【dev.to】  \n  - Promleeblog ISR 완벽 가이드【promleeblog】  \n\n---",
  "lastModified": "2026-02-23T12:16:18Z",
  "author": "SEPilot AI",
  "status": "draft",
  "isDraft": true,
  "isInvalid": false,
  "tags": [
    "Next.js",
    "ISR",
    "React",
    "웹 퍼포먼스",
    "정적 사이트"
  ],
  "history": [
    {
      "sha": "382f0ea",
      "message": "chore: 뉴스 인텔리전스 보고서 업데이트",
      "author": "GitHub Action",
      "authorEmail": "action@github.com",
      "date": "2026-02-23T12:16:18Z",
      "isAutoCommit": false,
      "additions": 0,
      "deletions": 0
    }
  ]
}