{
  "title": "프론트엔드 API 서비스 레이어 설명",
  "slug": "api",
  "content": "\n## 1. 문서 개요\n**목적**  \n프론트엔드 애플리케이션이 백엔드와 통신할 때 사용하는 공통 API 클라이언트 로직(`src/services/api.ts`)을 이해하고, 유지·보수·확장에 필요한 정보를 제공한다.  \n\n**대상 독자**  \n- 프론트엔드 개발자 (신규 입사자 포함)  \n- QA 엔지니어 및 테스트 자동화 담당자  \n- 아키텍처 리뷰어 및 문서 담당자  \n\n**역할**  \n`services/api.ts`는 HTTP 요청/응답 처리, 에러 핸들링, 토큰 자동 갱신 등 **백엔드와의 통신 전반**을 캡슐화한다. 이를 통해 UI 레이어는 비즈니스 로직에 집중하고, 네트워크 관련 구현은 한 곳에 집중시킬 수 있다.  \n\n**커버리지 분석 결과 요약**  \n\n| 항목 | 내용 |\n|------|------|\n| **모듈** | `services/api.ts` |\n| **소스 경로** | `src/services/api.ts` |\n| **중요도** | **high** (백엔드와의 모든 통신을 담당) |\n| **문서 필요 사유** | 요청/응답 흐름, 에러 처리, 토큰 재발급 로직 등 핵심 로직이 포함돼 있어 신규 개발자와 운영팀 모두에게 필수적인 가이드가 필요함 |\n\n---\n\n## 2. 서비스 레이어 아키텍처 개요\n### 2.1 전체 프론트엔드 아키텍처에서 위치\n- UI 컴포넌트 → **서비스 레이어(`api.ts`)** → HTTP 클라이언트(Axios 혹은 fetch) → 백엔드 API  \n- 서비스 레이어는 UI와 네트워크 사이의 **추상화 계층**으로, 데이터 페칭·전송 로직을 중앙집중화한다. (Medium 기사 “프론트엔드 아키텍처: API 요청 관리” 참고)  \n\n### 2.2 `services/api.ts` 의 책임 범위\n- HTTP 메서드별 헬퍼 함수 제공 (GET, POST, PUT, DELETE 등)  \n- 공통 헤더(Authorization, Content-Type 등) 자동 삽입  \n- 응답 정규화 및 성공/실패 판별  \n- 전역 에러 로깅·모니터링 연동  \n- Access/Refresh 토큰 자동 갱신 로직 구현  \n\n### 2.3 외부 의존성\n| 의존성 | 용도 | 참고 |\n|--------|------|------|\n| **Axios** (또는 fetch) | HTTP 요청/응답 처리 | 일반적인 프론트엔드 API 클라이언트 구현에 사용됨 (Medium) |\n| **토큰 저장소** (예: `localStorage`, `sessionStorage`, 쿠키) | Access/Refresh 토큰 보관 | 보안 고려사항 섹션에서 상세히 다룸 |\n| **인터셉터** | 요청 전/후 공통 로직(헤더 삽입, 토큰 재발급) | Axios 인터셉터 활용이 일반적임 |\n| **타입 정의 파일** (`*.d.ts`) | API 응답 타입 및 파라미터 정의 | TypeScript 기반 프로젝트에서 타입 안전성 확보 |\n\n---\n\n## 3. 파일 및 디렉터리 구조\n```\nsrc/\n └─ services/\n     ├─ api.ts          ← 메인 API 클라이언트\n     ├─ interceptors.ts ← 요청·응답 인터셉터 정의 (예시)\n     └─ types.ts        ← API 요청·응답 인터페이스\n```\n\n- `api.ts`는 **public API**(예: `get`, `post`, `put`, `delete`)를 export하고, 내부적으로 인터셉터와 타입을 활용한다.  \n- `interceptors.ts`(존재한다면)에서는 토큰 자동 갱신 로직과 에러 전역 처리 로직을 구현한다.  \n- `types.ts`는 각 엔드포인트가 반환하는 데이터 구조를 정의해 TypeScript 컴파일 타임에 검증한다.  \n\n> **추가 조사 필요**: 현재 레포지토리에서 실제 `interceptors.ts`·`types.ts` 파일 존재 여부와 구체적인 export 형태를 확인해야 함.\n\n---\n\n## 4. 핵심 기능 상세\n### 4.1 요청(Request) 처리\n- **헬퍼 함수**: `get<T>(url, config)`, `post<T>(url, data, config)` 등 타입 파라미터 `T`를 통해 응답 타입을 명시한다.  \n- **파라미터 직렬화**: 객체를 쿼리스트링으로 변환해 GET 요청에 포함한다. (Axios 기본 동작)  \n- **공통 헤더 삽입**: `Authorization: Bearer <accessToken>` 및 `Content-Type: application/json` 등을 자동으로 추가한다.  \n\n### 4.2 응답(Response) 처리\n- **정규화**: 서버가 반환하는 `{ data, meta, pagination }` 형태를 일관된 구조로 변환한다.  \n- **성공/실패 판별**: HTTP 2xx는 성공, 그 외는 실패로 간주하고, `response.status`에 따라 분기한다.  \n- **페이징·메타데이터 추출**: `meta` 혹은 `pagination` 필드를 별도 객체로 분리해 UI 레이어에 전달한다.  \n\n### 4.3 에러 핸들링\n- **네트워크 오류·타임아웃**: Axios 인터셉터에서 `error.code`를 검사해 재시도 정책을 적용한다.  \n- **HTTP 상태 코드 별 처리**: 401(Unauthorized) → 토큰 재발급 흐름; 403(Forbidden) → 접근 제한 메시지; 5xx → 전역 알림 및 로깅.  \n- **사용자 친화적 메시지 매핑**: 서버 오류 코드를 프론트엔드 메시지(`'서버에 문제가 발생했습니다.'`)와 매핑한다.  \n- **전역 로깅·모니터링 연동**: Sentry·Datadog 등 외부 모니터링 툴에 에러 정보를 전송한다.  \n\n### 4.4 토큰 자동 갱신\n- **흐름**:  \n  1. 요청 인터셉터에서 `Authorization` 헤더에 현재 Access Token 삽입.  \n  2. 401 응답이 오면 응답 인터셉터가 Refresh Token을 사용해 새로운 Access Token을 발급받는다.  \n  3. 재발급 성공 시 원래 요청을 **재시도**하고, 실패 시 로그아웃 처리한다.  \n- **무한 루프 방지**: 재시도 횟수를 1회로 제한하고, 재시도 중에도 401이 발생하면 즉시 로그아웃한다.  \n\n> **추가 조사 필요**: 현재 구현에서 Refresh Token 저장 위치와 재발급 API 엔드포인트가 어떻게 정의돼 있는지 확인이 필요함.\n\n---\n\n## 5. 사용 예시\n- **기본 GET 호출**  \n  `const users = await get<User[]>('/api/users');`  \n\n- **POST with JSON Body**  \n  `await post('/api/posts', { title, content });`  \n\n- **파일 업로드 (멀티파트)**  \n  `await post('/api/upload', formData, { headers: { 'Content-Type': 'multipart/form-data' } });`  \n\n- **인증이 필요한 엔드포인트**  \n  `await get('/api/profile'); // 인터셉터가 자동으로 토큰 삽입`  \n\n> 실제 코드 예시는 프로젝트 내 `src/services/api.ts`를 참고하고, 필요 시 `interceptors.ts`에 정의된 로직을 검토한다.\n\n---\n\n## 6. 확장 및 커스터마이징\n- **인터셉터 추가/제거**: `apiInstance.interceptors.request.use(customInterceptor)` 형태로 새로운 로직을 삽입한다.  \n- **커스텀 헤더 삽입**: 호출 시 `config.headers`에 추가하면 인터셉터가 병합한다.  \n- **테스트 환경(모킹) 설정**: Jest·MSW(Mock Service Worker)를 사용해 `api.ts`의 Axios 인스턴스를 모킹한다.  \n\n---\n\n## 7. 테스트 전략\n| 테스트 종류 | 대상 | 주요 포인트 |\n|------------|------|-------------|\n| **단위 테스트** | 헬퍼 함수(`get`, `post` 등) | 파라미터 직렬화, 헤더 삽입 검증 (Jest + axios-mock-adapter) |\n| **통합 테스트** | 실제 API 엔드포인트와 연동 | 성공/실패 시 응답 구조, 토큰 재발급 흐름 검증 |\n| **CI/CD 자동화** | Pull Request 단계 | `npm test` 실행, 커버리지 80% 이상 목표 (nodebestpractices 참고) |\n\n---\n\n## 8. 보안 고려사항\n- **토큰 저장소 선택**:  \n  - `httpOnly` 쿠키 → XSS 방어에 유리하지만 CSRF 방어 필요.  \n  - `localStorage`/`sessionStorage` → XSS 위험 존재, 토큰 암호화 필요.  \n- **CSRF 방어**: `SameSite=Lax` 쿠키 설정 또는 CSRF 토큰 헤더 전송.  \n- **XSS 예방**: 모든 입력값을 이스케이프하고, Content Security Policy(CSP) 적용.  \n- **민감 데이터 마스킹**: 로그에 토큰·비밀번호 등은 `***` 로 마스킹하고, 로깅 레벨을 조절한다.  \n\n---\n\n## 9. 성능 최적화\n- **요청 중복 방지(디듀핑)**: 동일 URL·파라미터에 대한 병렬 요청을 하나로 합친 뒤 결과를 공유한다.  \n- **캐시 전략**:  \n  - 메모리 캐시(React Query, SWR) → 최신 데이터와 재요청 최소화.  \n  - IndexedDB 혹은 Service Worker 캐시 → 오프라인 지원.  \n- **타임아웃·재시도 정책**: Axios `timeout` 옵션과 지수 백오프 재시도 로직을 적용한다.  \n\n---\n\n## 10. 베스트 프랙티스\n- **API 명명 규칙**: 리소스는 명사 형태, 동사는 HTTP 메서드로 표현한다 (velog “22 Best Practices” 참고).  \n- **에러 코드·메시지 표준화**: 서버와 클라이언트가 공유하는 에러 코드 사전 정의.  \n- **문서·타입 정의 유지**: `src/services/types.ts`에 인터페이스를 선언하고, 변경 시 문서와 테스트를 동시에 업데이트한다.  \n\n---\n\n## 11. 마이거레이션 가이드\n1. **기존 fetch 기반 구현 파악** – 현재 `fetch` 호출이 있는 파일을 식별한다.  \n2. **API 레이어 설치** – `src/services/api.ts`와 의존 파일을 프로젝트에 추가한다.  \n3. **호출 교체** – `fetch(url, options)` → `get<T>(url)` 혹은 `post<T>(url, data)` 로 교체한다.  \n4. **헤더·토큰 로직 검증** – 새 레이어가 자동으로 Authorization 헤더를 삽입하는지 확인한다.  \n5. **테스트 실행** – 기존 단위 테스트와 새 레이어 테스트를 모두 통과하는지 검증한다.  \n\n---\n\n## 12. FAQ\n- **Q: 토큰 갱신이 실패하면 어떻게 해야 하나요?**  \n  A: 인터셉터에서 401 응답이 두 번 연속 발생하면 `logout()`을 호출해 세션을 종료하고 로그인 페이지로 리다이렉트한다.  \n\n- **Q: CORS 오류가 발생했을 때 점검 포인트는?**  \n  A: 서버의 `Access-Control-Allow-Origin` 헤더와 프론트엔드 요청에 포함된 `Origin`이 일치하는지, 프리플라이트 요청이 정상적으로 처리되는지 확인한다.  \n\n- **Q: 테스트 환경에서 실제 API 호출을 차단하려면?**  \n  A: Jest 설정 파일에 `axios` 모듈을 `jest.mock('axios')` 로 모킹하거나, MSW를 사용해 네트워크 요청을 가로채고 가짜 응답을 반환한다.  \n\n---\n\n## 13. 참고 자료\n- **프론트엔드 아키텍처: API 요청 관리** – Medium (https://medium.com/@junep/%ED%94%84%EB%A1%9C%ED%8A%B8%EC%97%94%EB%93%9C-%EC%95%84%ED%82%A4%ED%85%8C%EC%B2%98-api-%EC%9A%94%EC%B2%AD-%EA%B4%80%EB%A6%AC-113c31d7bcee)  \n- **Grab Front End Guide** – 네이버 블로그 (https://m.blog.naver.com/magnking/221149133410)  \n- **Node.js Best Practices (Korean)** – GitHub (https://github.com/goldbergyoni/nodebestpractices/blob/master/README.korean.md)  \n- **API Design Best Practices** – velog (https://velog.io/@juunini/%EB%B2%88%EC%97%AD-22-Best-Practices-to-Take-Your-API-Design-Skills-to-the-Next-Level)  \n\n> **추가 조사 필요**: 프로젝트 내 실제 `src/services/api.ts` 구현 상세와 커밋 히스토리, 인터셉터·타입 정의 파일 위치를 확인해 문서에 반영한다.",
  "lastModified": "2026-02-21T20:15:16+09:00",
  "author": "SEPilot AI",
  "status": "published",
  "isDraft": false,
  "isInvalid": false,
  "tags": [
    "frontend",
    "api",
    "service-layer",
    "documentation",
    "coverage"
  ],
  "history": [
    {
      "sha": "dc9b1f9",
      "message": "feat: 뉴스 인텔리전스 시스템 전면 개선",
      "author": "JHL",
      "authorEmail": "bkperio@gmail.com",
      "date": "2026-02-21T20:15:16+09:00",
      "additions": 0,
      "deletions": 0
    }
  ]
}