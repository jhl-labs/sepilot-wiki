{
  "title": "Kubernetes에서 AI 모델 GitOps 구현 가이드",
  "slug": "kubernetes-ai-gitops",
  "content": "\n## 1. 개요\n이 문서는 **Kubernetes** 환경에서 **AI 모델**을 **GitOps** 방식으로 배포·운영하기 위한 실무 가이드를 제공합니다.  \n대상 독자는  \n- 쿠버네티스 클러스터 운영자  \n- MLOps·DevOps 엔지니어  \n- AI 서비스 개발자  \n이며, GitOps와 AI 모델 배포를 결합해 일관된 배포 파이프라인을 구축하고자 하는 팀을 목표로 합니다.\n\n### GitOps와 AI 모델 배포의 결합 필요성\n- Git을 단일 진실 소스로 삼아 인프라·애플리케이션·모델 버전을 동시에 관리하면 **재현성**과 **감사 가능성**이 확보됩니다.  \n- AI 모델은 빈번한 업데이트와 다양한 하이퍼파라미터 조합이 필요하므로, 모델 버전 관리와 배포 자동화를 동시에 지원하는 GitOps가 최적의 접근법입니다.  \n\n### 주요 용어 정의\n- **GitOps**: Git 저장소에 선언형 정의를 두고, 자동화 도구(Argo CD, Flux 등)가 이를 쿠버네티스에 적용하는 운영 방식.  \n- **MLOps**: 머신러닝 워크플로 전체(데이터, 모델 학습, 배포, 모니터링)를 DevOps 원칙에 맞게 자동화·표준화하는 접근법.  \n- **Model Registry**: 모델 아티팩트(버전, 메타데이터, 서명 등)를 중앙에서 관리하는 저장소(예: MLflow, Harbor).  \n\n## 2. 사전 요구사항\n| 항목 | 권장 사양 / 참고 |\n|------|-------------------|\n| **Kubernetes 클러스터** | 최신 안정 버전(예: 1.27 이상)·GPU 노드 지원·네트워크 플러그인(CNI) 정상 동작 – 클러스터 버전별 릴리즈 노트는 기존 문서([kubernetes-버전별-릴리즈-노트])를 참고 |\n| **Git 저장소** | 접근 권한(읽기/쓰기)·Branch 전략(예: `main`, `release/*`)·CI/CD 트리거를 위한 Webhook 설정 |\n| **CI/CD 도구** | Argo CD, Flux, Jenkins 등 중 하나 선택 – Argo CD는 YouTube 영상에서 소개된 바와 같이 Git‑to‑K8s 자동 동기화에 강점이 있음[[ArgoCD YouTube](https://www.youtube.com/watch?v=9_P7dANzXXk)] |\n| **컨테이너 이미지 레지스트리** | Harbor, Docker Hub 등 – 이미지 서명·스캔을 지원하는 레지스트리 권장 |\n| **Model Registry** | MLflow, ModelDB, 혹은 Harbor와 연동 가능한 커스텀 레지스트리 |\n| **추가 도구** | Kustomize/Helm, Terraform (GitOps와 IaC 결합) – Terraform GitOps 활용 사례는 Velog 글에서 확인 가능[[Terraform GitOps와 EKS AI 워크로드 관리](https://velog.io/@arnold_99/Terraform-GitOps를-활용한-EKS-인프라-자동화와-AI-워크로드-관리-시스템)] |\n\n## 3. 전체 아키텍처 설계\n1. **Git Repository** – 인프라(IaC)와 모델·애플리케이션 매니페스트를 각각 디렉터리 구조로 관리.  \n2. **CI 파이프라인** – 코드·모델 변경 감지 → 테스트·이미지 빌드 → 레지스트리·Model Registry에 푸시.  \n3. **CD (GitOps 엔진)** – Argo CD 혹은 Flux가 `applications/` 디렉터리의 선언형 매니페스트를 지속적으로 클러스터에 적용.  \n4. **Model Registry ↔ CI** – 학습 완료 모델을 버전 태그와 SHA로 레지스트리에 등록하고, 해당 메타데이터를 Git에 기록.  \n5. **Monitoring & Observability** – Prometheus·Grafana, OpenTelemetry, Seldon Core/KFServing 등으로 모델 메트릭·로그 수집.  \n\n전체 흐름도는 기존 “GitOps for Kubernetes: Complete Implementation Guide” 문서에서 제공하는 다이어그램을 참고하면 이해가 쉽습니다[[GitOps for Kubernetes Guide](https://atmosly.com/blog/gitops-for-kubernetes-implementation-guide-2025)].\n\n## 4. Git 저장소 구조 설계\n```\nrepo/\n├─ infrastructure/      # Helm 차트·Kustomize 베이스, Terraform 코드\n│   ├─ base/\n│   └─ overlays/\n├─ applications/        # 모델 서비스 매니페스트\n│   ├─ my-model/\n│   │   ├─ deployment.yaml\n│   │   ├─ service.yaml\n│   │   └─ ingress.yaml\n│   └─ another-model/\n├─ models/              # 모델 아티팩트 메타데이터 (버전, SHA)\n│   ├─ my-model/\n│   │   └─ v1.0.0.json\n│   └─ another-model/\n└─ ci/                  # CI 파이프라인 정의 (GitHub Actions, GitLab CI)\n    └─ pipeline.yaml\n```\n- `infrastructure/`는 클러스터‑레벨 설정(네트워크, RBAC, GPU 플러그인)과 Helm/Kustomize 템플릿을 포함합니다.  \n- `applications/`는 각 모델 서비스에 대한 쿠버네티스 매니페스트를 보관하며, **App‑of‑Apps** 패턴을 적용해 다중 모델을 한 번에 관리할 수 있습니다[[KT Cloud App of Apps](https://tech.ktcloud.com/entry/2025-05-ktcloud-kubernetes-gitops-appofapps-구현환경-전략)].\n\n## 5. 모델 패키징 및 컨테이너화\n- **모델 파일 포맷**: ONNX, TorchScript, TensorFlow SavedModel 등 표준 포맷을 사용해 프레임워크 독립성을 확보합니다.  \n- **Dockerfile 베스트 프랙티스**  \n  - **멀티‑스테이지**: 빌드 단계에서 모델 변환·검증을 수행하고, 최종 단계는 `gcr.io/distroless/cc` 혹은 GPU 베이스 이미지(`nvidia/cuda:12.0-runtime`)만 포함.  \n  - **GPU 베이스**: NVIDIA Container Toolkit을 활용해 GPU 드라이버와 라이브러리를 자동 마운트합니다.  \n- **이미지 빌드 자동화**: Kaniko 혹은 BuildKit을 CI 파이프라인에 통합해 클러스터 내부에서 안전하게 빌드합니다. Velog 글에서 Kaniko 기반 이미지 빌드 예시를 확인할 수 있습니다[[Terraform GitOps와 EKS AI 워크로드 관리](https://velog.io/@arnold_99/Terraform-GitOps를-활용한-EKS-인프라-자동화와-AI-워크로드-관리-시스템)].\n\n## 6. CI 파이프라인 구현\n1. **변경 감지**: `models/` 혹은 `applications/` 디렉터리의 PR/merge 이벤트를 트리거.  \n2. **정적 분석·테스트**  \n   - 코드 유닛 테스트, 모델 유효성 검사(예: ONNX Runtime 테스트)  \n   - 데이터 스키마 검증·성능 기준(accuracy, latency) 확인.  \n3. **이미지 빌드·스캔**  \n   - Kaniko로 이미지 빌드 → Trivy 등으로 SBOM·취약점 스캔.  \n4. **버전 태깅**  \n   - 모델 SHA와 Git 커밋 해시를 조합해 자동 버전 태그(`v1.0.0-<sha>`)를 생성하고, `models/` 메타데이터 파일에 기록.  \n\nCI 정의 예시는 `ci/pipeline.yaml`에 선언형 형태로 저장하고, GitHub Actions 혹은 GitLab CI와 연동합니다.\n\n## 7. CD – GitOps 적용 방법\n- **Argo CD vs. Flux**  \n  - Argo CD는 UI 기반 시각화와 ApplicationSet을 통한 다중 애플리케이션 관리에 강점이 있습니다[[ArgoCD YouTube](https://www.youtube.com/watch?v=9_P7dANzXXk)].  \n  - Flux는 GitOps 원칙을 더 가볍게 구현하고, Kustomize/Helm과 직접 연동이 용이합니다.  \n- **ApplicationSet / App‑of‑Apps** 패턴  \n  - `applications/` 하위 디렉터리를 각각 `Application` 객체로 선언하고, `ApplicationSet`으로 자동 생성·동기화합니다.  \n- **동기화 정책**  \n  - 자동 PR 생성 → 자동 병합(테스트 통과 시) 또는 수동 승인(보안 요구 시) 옵션을 선택할 수 있습니다.  \n\n## 8. 배포 전략 및 롤아웃\n- **Canary**: 새 모델 버전을 기존 서비스와 병렬로 실행하고, 트래픽 비율을 점진적으로 증가시켜 검증합니다.  \n- **Blue/Green**: 기존 버전(Blue)과 새 버전(Green)을 완전 분리하고, 검증 후 Service 객체를 스위치합니다.  \n- **Shadow**: 실제 트래픽을 그대로 유지하면서 새 모델에 복제된 요청을 전송해 성능을 측정합니다.  \n- **리소스 할당**: `ResourceQuota`와 `LimitRange`로 GPU/CPU 사용량을 제한하고, `NodeSelector`·`Tolerations`로 GPU 노드에 스케줄링합니다.  \n- **스케일링**: HPA(Horizontal Pod Autoscaler)와 VPA(Vertical Pod Autoscaler)를 조합하거나, KEDA를 이용해 커스텀 메트릭(예: 큐 길이) 기반 자동 스케일링을 구현합니다.\n\n## 9. 시크릿·구성 관리\n- **시크릿 관리**: Sealed Secrets 혹은 External Secrets Operator을 사용해 모델 인증키·API 토큰을 암호화된 형태로 Git에 저장합니다.  \n- **ConfigMap**: 하이퍼파라미터 파일(`config.yaml`)을 ConfigMap으로 관리하고, 배포 시 `envFrom`으로 주입해 버전별 파라미터를 쉽게 교체합니다.\n\n## 10. 모니터링·관찰성\n- **Prometheus + Grafana**: 쿠버네티스 리소스 사용량, 레이턴시, 오류율을 시각화하는 대시보드 구축.  \n- **모델 메트릭 수집**: Seldon Core 혹은 KFServing(현재 KServe)와 OpenTelemetry를 연동해 모델 추론 지연시간·정확도 등을 수집합니다[[Seldon 공식 문서](https://docs.seldon.io/)].  \n- **로그 집계**: EFK 스택(Elasticsearch, Fluentd, Kibana) 혹은 Loki+Grafana를 이용해 컨테이너 로그를 중앙화하고, 알림 정책을 설정합니다.  \n\n## 11. 롤백·복구 전략\n1. **Git 커밋 기반 롤백**: 문제가 발생하면 이전 커밋을 `git revert`하고, Argo CD/Flux가 자동으로 이전 매니페스트를 적용합니다.  \n2. **이미지·매니페스트 보관**: 모든 모델 이미지와 매니페스트는 레지스트리와 Git에 영구 보관되며, 필요 시 `docker pull <sha>` 로 복구 가능.  \n3. **장애 복구**: Pod 재시작 정책, Node 재배포, 클러스터 재구성 시나리오를 사전 정의하고, `kubectl rollout undo` 명령으로 빠르게 복구합니다.\n\n## 12. 보안·거버넌스\n- **RBAC·네임스페이스 격리**: 팀·프로젝트 별 네임스페이스와 최소 권한 원칙(RBAC) 적용.  \n- **이미지 서명·검증**: Cosign 혹은 Notary를 이용해 컨테이너 이미지 서명 후, Argo CD/Flux가 서명 검증을 통과한 이미지만 배포하도록 정책 설정.  \n- **감사 로그**: GitOps 엔진과 Kubernetes API 서버의 감사 로그를 중앙화하고, 컴플라이언스 체크리스트(예: AWS Well‑Architected 프레임워크)와 비교해 정기 검토합니다[[AWS Well‑Architected 프레임워크](https://docs.aws.amazon.com/ko_kr/wellarchitected/latest/framework/wellarchitected-framework.pdf)].\n\n## 13. 운영 베스트 프랙티스\n- **파이프라인 유지보수**: CI·CD 정의를 코드 리뷰와 PR 프로세스로 관리하고, 정기적인 의존성 업데이트(Argo CD, Flux, Helm) 수행.  \n- **모델 버전 관리**: 오래된 모델은 `archive/` 네임스페이스로 이동하고, 사용되지 않는 이미지와 레지스트리 엔트리를 주기적으로 정리합니다.  \n- **비용 최적화**: GPU 스케줄링 정책(NVIDIA Device Plugin)과 자동 스케일링을 활용해 사용량 기반 비용을 최소화합니다. Velog 사례에서 GPU 활용도 최적화 방법을 확인할 수 있습니다[[Terraform GitOps와 EKS AI 워크로드 관리](https://velog.io/@arnold_99/Terraform-GitOps를-활용한-EKS-인프라-자동화와-AI-워크로드-관리-시스템)].\n\n## 14. 트러블슈팅 가이드\n| 문제 | 원인 후보 | 확인 방법 | 해결 방안 |\n|------|-----------|----------|----------|\n| Argo CD 동기화 실패 | 매니페스트 오류, 이미지 태그 미존재 | Argo CD UI → Application → Events | 매니페스트 검증(`kubectl apply --dry-run`) 후 PR 수정 |\n| Flux 동기화 지연 | Git 리포지터리 접근 제한 | Flux 로그(`flux get kustomizations`) | SSH 키·토큰 재발급 |\n| GPU 드라이버 미설치 | 노드에 NVIDIA Device Plugin 미배포 | `kubectl get ds nvidia-device-plugin` | 플러그인 DaemonSet 재배포 |\n| 모델 추론 지연 | 리소스 부족(HPA 미작동) | Prometheus 대시보드 확인 | HPA 정책 조정 또는 GPU 할당 확대 |\n\n## 15. 참고 자료 및 링크\n- **Argo CD 공식 문서**: https://argo-cd.readthedocs.io/  \n- **Flux 공식 문서**: https://fluxcd.io/  \n- **Kubeflow / KServe**: https://kubeflow.org/, https://kserve.github.io/website/  \n- **Seldon Core**: https://docs.seldon.io/  \n- **GitOps for Kubernetes: Complete Implementation Guide (2026)** – Atmosly 블로그[[GitOps for Kubernetes Guide](https://atmosly.com/blog/gitops-for-kubernetes-implementation-guide-2025)]  \n- **AKS MLOps 모범 사례**: https://learn.microsoft.com/ko-kr/azure/aks/best-practices-ml-ops  \n- **KT Cloud App of Apps 구현**: https://tech.ktcloud.com/entry/2025-05-ktcloud-kubernetes-gitops-appofapps-구현환경-전략  \n- **Terraform + GitOps + EKS AI 워크로드**: https://velog.io/@arnold_99/Terraform-GitOps를-활용한-EKS-인프라-자동화와-AI-워크로드-관리-시스템  \n- **AWS Well‑Architected 프레임워크**: https://docs.aws.amazon.com/ko_kr/wellarchitected/latest/framework/wellarchitected-framework.pdf  \n\n---  \n*본 가이드는 제공된 리서치 자료를 기반으로 작성되었습니다. 구체적인 클러스터 환경이나 조직 정책에 따라 추가 조정이 필요할 수 있습니다.*",
  "lastModified": "2026-03-01T06:16:47Z",
  "author": "SEPilot AI",
  "status": "published",
  "isDraft": false,
  "isInvalid": false,
  "tags": [
    "kubernetes",
    "gitops",
    "mlops",
    "ai",
    "deployment"
  ],
  "history": [
    {
      "sha": "53b0b04",
      "message": "chore: Issue Processor 실행 결과",
      "author": "GitHub Action",
      "authorEmail": "action@github.com",
      "date": "2026-03-01T06:16:47Z",
      "isAutoCommit": false,
      "additions": 0,
      "deletions": 0
    }
  ]
}