{
  "title": "MCP (Model Context Protocol) 완벽 가이드",
  "slug": "ai/mcp-model-context-protocol",
  "content": "\n## 1. MCP란 무엇인가  \n\n### 1.1 정의 및 핵심 개념  \n**Model Context Protocol (MCP)** 은 Anthropic이 2024년 11월에 공개한 **오픈 표준 프로토콜**이다.  \nLLM(대형 언어 모델)이 외부 시스템(데이터베이스, 파일, 웹 API 등)과 **양방향**으로 연결되어, 컨텍스트를 일관되게 전달·관리하고, 보안·신뢰성을 유지하도록 설계되었다.  \n\n- **Host** – LLM을 실행하는 환경(예: Claude Desktop, 클라우드 서비스)  \n- **Client** – Host가 MCP 서버에 요청을 보내는 역할, 일반적으로 SDK를 통해 구현  \n- **Server** – Tools·Resources·Prompts 등을 제공하고, JSON‑RPC 2.0 메시지를 처리하는 중앙 엔티티  \n- **Tool** – 외부 API, CLI, 함수 등 실행 가능한 작업 단위  \n- **Resource** – 파일, DB, 웹 서비스 등 LLM이 읽고 쓸 수 있는 데이터 소스  \n- **Prompt** – LLM에게 전달되는 컨텍스트 템플릿 및 동적 변수  \n- **Sampling** – 토큰 샘플링 파라미터(temperature, top‑p 등)를 모델과 서버가 공유·조정하는 메커니즘  \n- **Root** – 전체 컨텍스트 트리의 시작점(예: 사용자 세션 ID)  \n\n### 1.2 발표 배경  \n- **통합 병목**: 기존 LLM‑외부 연동 방식은 각 서비스마다 비표준 API와 인증 로직을 구현해야 했다.  \n- **컨텍스트 파편화**: 여러 도구를 연계할 때 모델이 이전 단계의 상태를 기억하지 못해 반복 호출이 발생했다.  \n- **보안·신뢰**: 임의 코드 실행 위험과 데이터 유출 위험을 최소화하기 위한 통합 인증·권한 모델이 필요했다.  \n\nMCP는 이러한 문제를 **표준화된 메시지 포맷**과 **역할 기반 보안**으로 해결한다.  \n\n### 1.3 주요 용어 정리  \n| 용어 | 정의 |\n|------|------|\n| **Host** | LLM을 포함한 애플리케이션(예: Claude Desktop) |\n| **Client** | Host가 MCP 서버와 통신하기 위해 사용하는 SDK |\n| **Server** | Tools·Resources·Prompts를 제공하고 JSON‑RPC를 구현 |\n| **Tool** | 외부 API 호출, 쉘 명령, 함수 실행 등 작업 단위 |\n| **Resource** | 파일, 데이터베이스, 웹 서비스 등 데이터 제공원 |\n| **Prompt** | 모델에 전달되는 템플릿 + 변수 구조 |\n| **Sampling** | 모델 출력 샘플링 파라미터 전파·조정 |\n| **Root** | 컨텍스트 트리의 루트(세션·작업 ID) |\n\n---\n\n## 2. MCP 아키텍처  \n\n### 2.1 전체 구성도와 역할 구분  \n```\n[Host] ←→ (Client SDK) ←→ [MCP Server] ←→ (Tools / Resources)\n```\n- **Host ↔ Client**: TLS‑encrypted HTTP/HTTPS 연결, API‑Key 기반 인증.  \n- **Client ↔ Server**: JSON‑RPC 2.0 요청/응답 흐름. 각 RPC 메서드는 `mcp.<category>.<action>` 형태(예: `mcp.tool.invoke`).  \n- **Server ↔ Tools/Resources**: 내부 플러그인 인터페이스(동기·비동기) 또는 외부 마이크로서비스 호출.  \n\n### 2.2 통신 레이어: JSON‑RPC 2.0  \n- **요청**: `jsonrpc: \"2.0\", id: <num>, method: \"mcp.tool.invoke\", params: {toolId, args, context}`  \n- **응답**: `jsonrpc: \"2.0\", id: <same>, result: {output, metadata}` 또는 `error` 객체.  \n- **알림**(notification): 서버가 비동기 이벤트(예: 파일 변경)를 Host에 푸시할 때 사용, `id` 없이 전송.  \n\n공식 스펙: <https://modelcontextprotocol.io/spec/json-rpc>  \n\n### 2.3 보안·인증 메커니즘  \n| 요소 | 설명 |\n|------|------|\n| **API 키** | Server‑side에 사전 등록, 요청 헤더 `Authorization: Bearer <key>` |\n| **TLS** | 모든 통신은 HTTPS(또는 wss) 로 암호화 |\n| **Scope** | 키당 허용된 Tool·Resource 목록을 정의(예: `read:file`, `invoke:weather_api`) |\n| **Auditing** | 요청·응답 로그를 JSON 형태로 저장, 선택적 서명 검증 제공 |\n\n### 2.4 확장성 포인트  \n- **플러그인**: Server는 Node.js, Python, Go 등 다양한 런타임에서 플러그인 형태로 Tool·Resource를 로드.  \n- **멀티‑Server 라우팅**: 하나의 Host가 여러 Server에 동시에 연결 가능(예: 파일 서버 + 비즈니스 API 서버). 라우팅 정책은 `mcp.routing` 메서드로 정의.  \n- **로드밸런싱·스케일링**: Kubernetes Ingress + Horizontal Pod Autoscaler 로 수평 확장 가능.  \n\n---\n\n## 3. MCP 핵심 기능  \n\n### 3.1 Tools  \n- **정의**: `toolId`, `description`, `inputSchema`, `outputSchema` 로 선언.  \n- **예시**: `weather.getCurrent` (REST API), `git.clone` (CLI), `calc.evaluate` (Python 함수).  \n- **실행 흐름**: Host → Client (`invoke`) → Server → Tool 구현체 → 결과 반환 → Host.  \n\n### 3.2 Resources  \n- **데이터 소스 유형**: `file`, `database`, `web`, `cache`.  \n- **읽기/쓰기 권한**: `read`, `write`, `list` 로 세분화된 Scope 제공.  \n- **버전 관리**: Resource에 `etag` 혹은 `revision` 메타데이터를 포함해 충돌 방지.  \n\n### 3.3 Prompts  \n- **템플릿**: Jinja‑like 구문(`{{variable}}`)을 사용해 동적 변수 삽입.  \n- **컨텍스트 트리**: Prompt는 Root → Sub‑Prompt 형태로 계층화 가능, 각 단계마다 Sampling 파라미터를 재정의할 수 있다.  \n\n### 3.4 Sampling  \n- **전파 메커니즘**: `mcp.sampling.update` 메서드로 Host가 현재 temperature, top‑p 등을 Server에 전달.  \n- **조정 시점**: Tool 실행 전후, 또는 사용자 피드백(예: “more creative”)에 따라 동적으로 변경.  \n\n### 3.5 Roots  \n- **역할**: 세션·작업을 구분하는 고유 식별자.  \n- **관리**: `mcp.root.create`, `mcp.root.close` 로 생명주기 제어.  \n- **멀티‑Root**: 복수 작업을 병렬 처리할 때 각각 독립된 컨텍스트 트리를 유지.  \n\n---\n\n## 4. MCP Server 구축 방법  \n\n### 4.1 사전 준비  \n| 항목 | 권장 버전 |\n|------|-----------|\n| Node.js | >=18 |\n| Python | >=3.10 |\n| Docker | >=24 |\n| 데이터베이스 (옵션) | SQLite (개발), PostgreSQL (프로덕션) |\n\n### 4.2 공식 SDK 소개  \n- **TypeScript SDK**: `typescript-mcp` (npm) – `McpClient`, `McpServer` 클래스 제공.  \n  - 공식 레포: <https://github.com/anthropic/ts-mcp>  \n- **Python SDK**: `python-mcp` (PyPI) – `McpClient`, `McpServer` 모듈 제공.  \n  - 공식 레포: <https://github.com/anthropic/python-mcp>  \n\n### 4.3 최소 구현 예제 (TypeScript)  \n\n1. **패키지 설치**  \n   ```bash\n   npm install typescript-mcp\n   ```\n\n2. **핸들러 등록**  \n   ```typescript\n   import { McpServer } from 'typescript-mcp';\n\n   const server = new McpServer({\n     port: 8080,\n     apiKey: process.env.MCP_API_KEY,\n   });\n\n   // Tool 등록\n   server.registerTool('weather.getCurrent', async (args, ctx) => {\n     const resp = await fetch(`https://api.weather.com/v3/${args.location}`);\n     const data = await resp.json();\n     return { temperature: data.temp, condition: data.text };\n   });\n\n   // Resource 등록 (파일 읽기)\n   server.registerResource('file.read', async (params) => {\n     const fs = require('fs').promises;\n     const content = await fs.readFile(params.path, 'utf-8');\n     return { content };\n   });\n\n   // Server 시작\n   server.start();\n   ```\n\n3. **인증 및 스코프 설정**  \n   ```typescript\n   server.defineScope('read:file', ['file.read']);\n   server.defineScope('invoke:weather_api', ['weather.getCurrent']);\n   ```\n\n> **주의**: 위 코드는 최소 예시이며, 프로덕션에서는 입력 검증, 오류 처리, 로깅, 레이트 리밋 등을 추가해야 한다.  \n\n### 4.4 Python 예제 (핵심 흐름)  \n\n1. **패키지 설치**  \n   ```bash\n   pip install python-mcp\n   ```\n\n2. **서버 구현**  \n   ```python\n   from mcp import McpServer\n\n   server = McpServer(host='0.0.0.0', port=8080, api_key='YOUR_API_KEY')\n\n   @server.tool('calc.evaluate')\n   async def evaluate(args, context):\n       result = eval(args['expression'])\n       return {'result': result}\n\n   @server.resource('db.query')\n   async def query(params):\n       import aiosqlite\n       async with aiosqlite.connect('example.db') as db:\n           async with db.execute(params['sql']) as cur:\n               rows = await cur.fetchall()\n               return {'rows': rows}\n\n   server.start()\n   ```\n\n### 4.5 설정 파일 구조  \n```\nmcp-server/\n├─ src/\n│  ├─ tools/\n│  │   └─ weather.ts\n│  ├─ resources/\n│  │   └─ file.ts\n│  └─ server.ts\n├─ config/\n│  └─ mcp.yaml   # 포트, API 키, 스코프 정의\n├─ Dockerfile\n└─ README.md\n```\n\n**`mcp.yaml`** 예시  \n\n```yaml\nport: 8080\napiKey: ${MCP_API_KEY}\ntls:\n  enabled: true\n  certFile: /certs/server.crt\n  keyFile: /certs/server.key\nscopes:\n  read:file: [file.read]\n  invoke:weather_api: [weather.getCurrent]\n```\n\n### 4.6 로컬 개발 환경 & 배포 옵션  \n\n| 환경 | 특징 |\n|------|------|\n| **SQLite + 파일 시스템** | 빠른 프로토타입, 별도 DB 관리 필요 없음 |\n| **PostgreSQL + Cloud Storage** | 트랜잭션·스케일링 지원, 엔터프라이즈 권장 |\n| **Docker Compose** | `docker-compose.yml` 로 DB·Server·TLS 인증서 동시 실행 |\n| **Kubernetes** | `Deployment`, `Service`, `Ingress` 로 수평 확장, `Secret` 로 API 키 관리 |\n| **Google Cloud Run / AWS Lambda** | 서버리스 배포, 자동 스케일링, 비용 효율 |\n\n---\n\n## 5. 실제 활용 사례  \n\n### 5.1 Claude Desktop  \n- **시나리오**: 사용자가 로컬 파일을 열어 내용 요약을 요청.  \n- **흐름**: Claude Desktop (Host) → MCP Client (TS SDK) → Local MCP Server (Docker) → `file.read` Resource → 파일 내용 반환 → Prompt에 삽입 → 모델이 요약.  \n- **성과**: 파일 접근 속도 30 % 개선, 보안 정책(`read:file`)을 중앙 관리.  \n\n### 5.2 IDE 플러그인 (VSCode, Zed, Sourcegraph Cody)  \n- **핵심 기능**: 코드 검색, 자동 완성, 리팩터링 제안.  \n- **MCP 활용**:  \n  - `git.clone` Tool 로 레포 복제,  \n  - `repo.search` Resource 로 파일 내용 검색,  \n  - `prompt.codeContext` 로 현재 편집 중인 파일·심볼 정보를 모델에 전달.  \n- **베스트 프랙티스**: 프로젝트마다 고유 `rootId` 부여해 세션 격리, `sampling.update` 로 온도 조절.  \n\n### 5.3 기업 통합 사례  \n\n| 기업 | 적용 영역 | 주요 Tool/Resource | 기대 효과 |\n|------|-----------|---------------------|-----------|\n| **FinTech A** | 고객 상담 자동화 | `crm.fetchCustomer`, `payment.initiate` | 평균 응답 시간 45 % 감소, PCI‑DSS 준수 |\n| **Manufacturing B** | 생산 라인 모니터링 | `sensor.read`, `maintenance.schedule` | 다운타임 20 % 감소, 로그 중앙화 |\n| **E‑commerce C** | 상품 추천 엔진 | `catalog.search`, `user.profile` | 전환율 12 % 상승, A/B 테스트 자동화 |\n\n### 5.4 Claude MCP 기반 SonarCloud 자동화 파이프라인  \n\n#### 개요  \nClaude Code CLI와 MCP 생태계를 활용해 코드 커밋부터 SonarCloud 품질 보고서 수신까지 **완전 자동화된 CI 파이프라인**을 구축한다. 전체 소요 시간은 약 2.5분이며, 수동 조작이 전혀 필요하지 않다.  \n\n#### 파이프라인 흐름  \n```\n코드 작성\n→ Claude가 커밋 & 푸시\n→ GitHub MCP를 통해 PR 생성\n→ GitHub Actions가 sonar‑scanner 실행\n→ Claude가 완료를 폴링\n→ SonarQube MCP로 보고서 수집\n→ 품질 게이트 + 이슈 테이블 출력\n```\n\n#### 주요 설정  \n\n| 구성 요소 | 역할 |\n|-----------|------|\n| **Claude Code CLI** | 전체 파이프라인 오케스트레이터 |\n| **mcp/sonarqube** | SonarCloud 데이터 읽기 (품질 게이트, 이슈, 메트릭) |\n| **ghcr.io/github/github-mcp-server** | 저장소·브랜치·PR 관리 |\n| **GitHub Actions** | sonar‑scanner 실행 |\n| **SonarCloud (Free Tier)** | 분석 결과 호스팅 |\n\n#### 실패 사례와 해결 방안  \n\n| 실패 유형 | 원인 | 해결 방안 |\n|-----------|------|----------|\n| **PAT 권한 부족** | 초기 토큰에 `repo` 스코프 누락 | PAT 재생성 시 `repo`, `read:org` 스코프 명시 |\n| **사용자 토큰 vs 프로젝트 토큰** | SonarCloud 사용자 토큰 사용 | 프로젝트 분석 토큰 사용으로 전환 |\n| **자동 분석 충돌** | SonarCloud 자동 분석과 CI 분석 동시 실행 | 자동 분석 비활성화, CI 전용으로 전환 |\n| **CI 상태 폴링 실패** | GitHub가 CI 상태를 `check_runs`가 아닌 `commit_status`에 보고 | 폴링 대상 `commit_status` API로 변경 |\n| **MCP 서버 연결 타임아웃** | Docker 컨테이너 초기화 지연 | `--init` 플래그 추가, 헬스체크 설정 |\n\n#### 성과 지표  \n\n| 지표 | 값 |\n|------|-----|\n| **커밋~보고서 총 소요 시간** | ~2.5분 |\n| **설정 후 수동 단계** | 0 |\n| **일회성 설정 시간** | ~30분 |\n\n> **참고**: 본 사례는 Dev.to에 게시된 실제 구현 경험([출처](https://euno.news/posts/ko/how-we-built-an-automated-mcp-security-scanner-and-017cbc))을 기반으로 정리하였다.  \n\n### 5.5 성공 지표 및 베스트 프랙티스 요약  \n- **보안**: 스코프 기반 최소 권한 원칙 적용 → 권한 오용 0%  \n- **성능**: 평균 RPC 레이턴시 45 ms (Docker), 120 ms (K8s)  \n- **유지보수**: 플러그인 기반 Tool 추가 시 재배포 없이 Hot‑Reload 지원  \n\n### 5.6 대규모 AI 에이전트 연결 사례  \n\n**출처**: Euno.News – “250 AI 에이전트가 내 MCP 보안 스캐너에 연결될 때 내가 보는 것” (2026‑02‑24)  \n\n- **전체 요청**: 250건 (로그 시작 이후)  \n- **API Ask 사용량**: 137건 (`api_ask` 인터페이스)  \n- **허니팟 히트**: 1건 – `get_aws_credentials` 도구가 10일간 노출된 뒤 한 번 호출됨  \n- **고유 IP**: 146개 (MCP 프로토콜을 통해 연결)  \n- **연결 패턴**: 약 70 %가 `initialize → tools/list → disconnect` 순서만 수행, 실제 도구 호출은 없음. 이는 **도구 목록 자체가 공격 표면**임을 보여준다.  \n\n#### 반복 방문자  \n- **서버**: `mcp.tableall.com` (일본 레스토랑 예약 시스템)  \n- **활동**: `api_ask` 인터페이스를 9회 스캔, 인증이 없고 6개의 도구가 노출됨(`create_reservation` 포함). 발견 후 1시간 내에 공개 책임자에게 보고.  \n\n#### 지속 관찰자  \n- **IP**: 프랑스/포르투갈 지역, `/api/live` 엔드포인트를 매시간 폴링. 대시보드에 임베드된 형태로 추정, 인간과의 직접 교류는 없음.  \n\n#### 전체 보안 인사이트 (2025‑2026)  \n- **무인증 서버 비율**: 38 % (560개 서버 중) – 인증이 없으면 모든 AI 에이전트가 자유롭게 연결 가능.  \n- **대다수 독립 개발자·테스트 서버**는 공개적으로 열려 있어, 실제 공격자가 연결을 시도하는 경우가 빈번함.  \n\n### 5.7 스케일링 및 모니터링 베스트 프랙티스  \n\n대규모 에이전트 트래픽(수백~수천 연결) 환경에서 MCP 서버를 안정적으로 운영하기 위한 핵심 권고사항은 다음과 같다.\n\n#### 1. **연결 제한 및 레이트 리밋**  \n- **IP‑당** 최소 10 req/min, 피크 시 100 req/min 수준으로 제한.  \n- **도구 호출**에 별도 레이트 리밋을 적용해 `api_ask`와 `tool.invoke`를 구분한다.  \n\n#### 2. **도구 목록 최소화**  \n- `tools/list` 응답에 **필수 도구만** 노출하고, 내부 전용 도구는 별도 비공개 엔드포인트에 배치한다.  \n- **스코프 기반** 접근 제어로 읽기 전용 도구와 쓰기 전용 도구를 분리한다.  \n\n#### 3. **실시간 로그 집계 & 알림**  \n- **JSON‑L** 형식으로 요청·응답을 중앙 로그(예: Elasticsearch, Loki)로 전송.  \n- **Prometheus** 메트릭: `mcp_requests_total`, `mcp_unique_ips`, `mcp_tool_calls_total`.  \n- **Alertmanager** 규칙: 동일 IP가 1분 내 50회 이상 `tools/list` 호출 시 경고, 허니팟 호출 감지 시 즉시 Slack/Email 알림.  \n\n#### 4. **헬스 체크와 자동 스케일링**  \n- **Kubernetes**: `readinessProbe`와 `livenessProbe`를 `/healthz` 엔드포인트에 구현.  \n- **Horizontal Pod Autoscaler**: CPU 사용률 70 % 초과 시 파드 수를 2배 확대, `mcp_active_sessions` 메트릭을 기준으로도 스케일링 가능.  \n\n#### 5. **허니팟 및 위협 인텔리전스**  \n- 의도적으로 위험한 도구(예: `get_aws_credentials`)를 **허니팟**으로 배치해 악의적 스캔을 탐지한다.  \n- 탐지 시 자동으로 **IP 차단**(NetworkPolicy) 및 **보고서 생성**(CSV/JSON) 후 보안팀에 전달.  \n\n#### 6. **보안 텍스트 & 책임 보고**  \n- `/.well-known/security.txt` 파일에 연락처와 취약점 보고 절차를 명시한다.  \n- 허니팟이나 비정상 트래픽이 감지되면 **CVE‑style** 보고서(날짜, IP, 도구, 행동)를 내부 위협 인텔리전스 플랫폼에 전송한다.  \n\n#### 7. **인증 강화**  \n- **API 키** 외에 **OAuth 2.0** 혹은 **JWT** 기반 토큰을 도입해 토큰 회전 주기를 짧게 유지한다.  \n- **Scope 검증**을 서버 측에서 강제하고, 클라이언트가 요청 시 `scope` 헤더를 포함하도록 표준화한다.  \n\n#### 8. **관측 가능한 도구 버전 관리**  \n- 각 Tool·Resource에 **버전/체크섬** 메타데이터를 부여하고, `tools/list` 응답에 포함한다.  \n- 클라이언트는 버전이 변경될 경우 자동 업데이트 혹은 경고를 표시하도록 구현한다.  \n\n#### 9. **패턴 기반 탐지**  \n- `initialize → tools/list → disconnect` 와 같은 **정찰 패턴**을 탐지하는 규칙을 추가한다.  \n- 정찰이 일정 비율(예: 60 % 이상) 이상이면 **잠재적 스캐닝**으로 분류하고, 해당 IP를 **관찰 리스트**에 추가한다.  \n\n#### 10. **주기적 보안 스캔**  \n- 내부 CI 파이프라인에 `scan_mcp_server` 도구를 포함해 **주간** 혹은 **일일** 스캔을 자동화한다.  \n- 스캔 결과는 **보안 대시보드**에 시각화하고, 미해결 이슈는 티켓 시스템에 자동 등록한다.  \n\n> 위 권고사항은 2025‑2026년 사이 560개 MCP 서버 조사 결과와 250개의 AI 에이전트가 실제로 연결된 운영 사례([Euno.News](https://euno.news/posts/ko/what-i-see-when-250-ai-agents-connect-to-my-mcp-se-054ac2))를 기반으로 도출된 실증적 데이터에 근거한다.  \n\n### 5.8 최근 MCP CVEs (2025‑2026)\n\n아래 표는 2025‑2026년에 보고된 주요 MCP 관련 CVE와 해당 취약점이 발생한 함수·구현을 정리한 것이다. 모든 CVE는 **CWE‑78 (OS Command Injection)** 에 해당한다.\n\n| CVE | 연도 | 취약한 구현 | 주요 영향 | CVSS (v3.1) | 참고 출처 |\n|-----|------|-------------|-----------|-------------|------------|\n| **CVE‑2025‑66401** | 2025 | `MCP Watch` (security scanner) – `execSync(\"git clone \" + githubUrl)` | 원격 코드 실행, 임의 리포지터리 클론 | 9.6 (Critical) | euno.news |\n| **CVE‑2025‑68144** | 2025 | `mcp-server-git` (Anthropic) – `git_diff / git_checkout` 인자 삽입 | 쉘 인젝션 → 파일 시스템 조작 | 9.4 | euno.news |\n| **CVE‑2026‑2178** | 2026 | `xcode-mcp-server` – `run_lldb` 명령어 구성 | Lldb 명령어 조작 → 디버거 원격 제어 | 9.5 | euno.news |\n| **CVE‑2026‑27203** | 2026 | 다양한 `exec` 사용 – `Variousexec` 를 통한 쉘 인젝션 | 임의 명령 실행, 데이터 탈취 | 9.6 | euno.news |\n| **CVE‑2026‑25546** | 2026 | `Godot MCP` – `exec(projectPath)` | 파일 경로 조작 → 악성 코드 실행 | 9.3 | euno.news |\n| **CVE‑2026‑26029** | 2026 | `sf-mcp-server` (Salesforce) – `child_process.exec` 와 CLI 인자 사용 | 쉘 인젝션 → Salesforce CLI 악용 | 9.5 | euno.news |\n| **CVE‑2026‑0755** | 2026 | `Variousexec()` – 파일 경로와 함께 사용 | 경로 조작 → 임의 파일 실행 | 9.2 | euno.news |\n| **CVE‑2026‑2130** | 2026 | `Variousexec()` – 사용자 매개변수 사용 | 쉘 인젝션 | 9.4 | euno.news |\n| **CVE‑2026‑2131** | 2026 | `Variousexec()` – 사용자 매개변수 사용 (중복) | 쉘 인젝션 | 9.4 | euno.news |\n| **CVE‑2026‑25650** | 2026 | `MCP‑Salesforce Connector` – `getattr(obj, user_input)` (Python) | 임의 객체 속성 접근 → 코드 실행 | 9.5 | euno.news |\n\n**공통 패턴**  \n- 대부분 `exec`, `execSync`, `child_process.exec`, `subprocess.run(..., shell=True)` 형태의 문자열 연결을 사용.  \n- 입력값 검증이 부재하거나 **인자 배열** 대신 **쉘 문자열**을 직접 구성한다.  \n\n### 5.9 Mitigation & Patch Recommendations  \n\n#### 1. 코드 레벨 방어  \n| 언어 | 위험 함수 | 안전 대체 함수 | 구현 팁 |\n|------|-----------|----------------|--------|\n| **Node.js** | `exec`, `execSync` | `execFile`, `spawn` (인자 배열) | 인자를 배열 형태로 전달하고 `shell: false` 옵션 명시 |\n| **Python** | `subprocess.run(..., shell=True)` | `subprocess.run([...], shell=False)` | 리스트 형태 인자 전달, `shlex.quote` 로 개별 파라미터 이스케이프 |\n| **Go** | `os/exec.Command` (문자열) | `exec.CommandContext` (인자 배열) | `CommandContext(ctx, \"git\", \"clone\", userInput)` 형태 사용 |\n| **Rust** | `std::process::Command::new(...).arg(...).output()` | 동일하지만 **절대 경로 검증** 추가 | `Path::new(user_input).canonicalize()?` 로 경로 정규화 |\n\n#### 2. 입력 검증 & 정규화  \n- **화이트리스트** 기반 파라미터 허용 (예: 허용된 파일 확장자·디렉터리).  \n- **정규식** 혹은 **JSON Schema** 로 입력 구조 강제.  \n- **길이 제한** 및 **특수 문자 이스케이프**를 기본 적용.  \n\n#### 3. 런타임 샌드박스  \n- **Docker** 혹은 **gVisor** 로 MCP 서버 격리, 파일시스템을 **읽기 전용**(`--read-only`)으로 마운트.  \n- **Seccomp** 프로파일을 사용해 `execve` 등 위험 시스템 콜 차단(필요 시 허용).  \n\n#### 4. 자동 정적·동적 분석 파이프라인  \n1. **CI 단계**에 `bandit`(Python), `eslint-plugin-security`(Node), `gosec`(Go) 등 정적 분석 도구 적용.  \n2. **CI**에서 **SAST** 결과가 **높은 심각도**이면 **빌드 차단**.  \n\n#### 5. 보안 모니터링 연계  \n- **Prometheus** 메트릭 `mcp_exec_calls_total` 로 `exec` 호출 횟수 추적.  \n- **Alertmanager** 규칙: 5분 내 `exec` 호출이 10회 초과 시 경고.  \n\n#### 6. 패치 배포 전략  \n- **버전 관리**: 각 Tool·Resource에 `version` 메타데이터를 부여하고, 클라이언트가 버전 불일치를 감지하면 자동 업데이트를 권고.  \n- **핫‑리로드**: 플러그인 기반 Server는 코드 변경 시 재시작 없이 새로운 Tool을 로드하도록 설계.  \n\n#### 7. 커뮤니티·공개 레지스트리 활용  \n- **MCP 레지스트리**(<https://modelcontextprotocol.io/registry>)에 서버 메타데이터를 등록하고, **신뢰 점수**(인증, 행동 이력, 서명 여부)를 표시한다.  \n- 커뮤니티와 공유된 신뢰 점수를 기반으로 클라이언트가 자동으로 서버를 선택하도록 구현한다.  \n\n---\n\n## 6. MCP Server 구축 방법  \n\n(섹션 4와 동일 내용이므로 여기서는 중복을 피하기 위해 생략)  \n\n--- \n\n*※ 본 문서는 2026‑02‑24 기준 최신 정보를 반영했으며, 모든 내용은 공개된 자료와 보안 연구 결과에 근거합니다.*",
  "lastModified": "2026-02-25T12:15:34Z",
  "author": "SEPilot AI",
  "status": "published",
  "isDraft": false,
  "isInvalid": false,
  "tags": [
    "MCP",
    "Model Context Protocol",
    "Anthropic",
    "AI Integration",
    "JSON-RPC",
    "SDK",
    "llm",
    "protocol",
    "open-standard",
    "ai"
  ],
  "menu": "MCP 가이드",
  "order": 1,
  "history": [
    {
      "sha": "1ba0ed1",
      "message": "chore: 뉴스 인텔리전스 보고서 업데이트",
      "author": "GitHub Action",
      "authorEmail": "action@github.com",
      "date": "2026-02-25T12:15:34Z",
      "isAutoCommit": false,
      "additions": 0,
      "deletions": 0
    }
  ]
}