{
  "title": "Wiki 페이지 API 라우트 상세 가이드",
  "slug": "backend/wiki-api-route-guide",
  "content": "\n## 1. 문서 개요\n**목적**  \n`app/api/wiki/[...slug]/route.ts` 파일이 제공하는 Wiki 페이지 API 엔드포인트의 사용 방법을 외부 개발자와 내부 팀에게 명확히 안내합니다.  \n\n**대상 독자**  \n- 프론트엔드·백엔드 개발자  \n- API 소비자(외부 파트너)  \n- 운영·보안 담당자  \n\n**주요 기능 요약**  \n- Wiki 페이지 조회, 생성, 수정, 삭제 지원  \n- 계층형 경로(`slug`)를 통한 페이지 식별  \n- JWT 기반 인증·인가 적용 및 표준화된 응답 포맷  \n\n**버전 정보 및 적용 범위**  \n- 현재 API 버전: `v1` (프로젝트 루트 `package.json`에 정의)  \n- 적용 범위: `app/api/wiki/[...slug]/route.ts`에 매핑된 모든 HTTP 메서드  \n\n> **참고**: 본 가이드는 로버트의 API 문서 작성 가이드라인을 참고하여 구성되었습니다[[API 문서 작성을 위한 로버트의 가이드라인](https://koko8829.tistory.com/2496)].\n\n---\n\n## 2. 인증·인가 흐름\n| 항목 | 내용 |\n|------|------|\n| **지원 인증 방식** | **JWT (JSON Web Token)** 를 `Authorization: Bearer <token>` 헤더에 담아 전달합니다. 토큰은 `HS256` 알고리즘으로 서명되며, `exp` 클레임을 통해 만료 시간이 관리됩니다. |\n| **토큰 전달 방법** | - `Authorization` 헤더 (권장) <br> - HTTP‑Only `session_token` 쿠키 (옵션, SameSite=Lax) |\n| **권한 레벨 별 접근 제한** | - **읽기**(GET): 인증된 모든 사용자 허용 <br> - **작성·수정·삭제**(POST, PUT/PATCH, DELETE): `editor` 또는 `admin` 역할 필요 |\n| **인증 실패 시 응답** | `401 Unauthorized` 와 아래와 같은 JSON 바디 반환 <br> ```json { \"errorCode\":\"UNAUTHORIZED\", \"message\":\"Invalid or missing token.\" }``` |\n\n**요약**  \nAPI는 JWT 기반 Bearer 토큰을 기본 인증 수단으로 사용합니다. 토큰이 없거나 유효하지 않을 경우 401 오류가 반환되며, 쓰기·삭제 작업은 `editor` 이상 권한이 요구됩니다.\n\n---\n\n## 3. 라우트 구조 및 파라미터\n- **파일 위치**: `app/api/wiki/[...slug]/route.ts`  \n- **라우트 매핑**: Next.js App Router의 와일드카드 `[...]` 로 `/api/wiki/*` 경로 전체를 처리합니다.  \n\n### `slug` 파라미터\n- **형식**: 계층형 경로 문자열 배열 (`string[]`). 예시: `/api/wiki/technology/web/react` → `slug = [\"technology\",\"web\",\"react\"]`.  \n- **역할**: Wiki 페이지의 고유 경로를 식별하며, 페이지 트리 구조를 그대로 반영합니다.  \n\n### 지원 HTTP 메서드\n| 메서드 | 동작 |\n|-------|------|\n| **GET** | 페이지 조회 |\n| **POST** | 새 페이지 생성 |\n| **PUT** / **PATCH** | 기존 페이지 전체/부분 업데이트 |\n| **DELETE** | 페이지 삭제 (soft / hard) |\n\n### 지원 쿼리 파라미터\n| 파라미터 | 타입 | 설명 | 기본값 |\n|----------|------|------|--------|\n| `preview` | boolean | 미발행(초안) 페이지를 조회할 때 `true` 로 설정 | `false` |\n| `includeDeleted` | boolean | 소프트 삭제된 페이지를 포함해 조회 (`true` 시) | `false` |\n| `mode` | string (`soft` \\| `hard`) | DELETE 요청 시 삭제 방식 지정. 지정하지 않으면 `soft` 가 기본 | `soft` |\n\n**요약**  \n`slug` 로 페이지를 식별하고, `preview`, `includeDeleted`, `mode` 같은 쿼리 파라미터로 조회·삭제 동작을 세밀하게 제어할 수 있습니다.\n\n---\n\n## 4. 엔드포인트 상세\n\n### 4‑1. Wiki 페이지 조회 (GET)\n- **요청 URL**: `GET /api/wiki/{slug...}`  \n- **필수 파라미터**: `slug` (경로)  \n- **선택 파라미터**: `preview`, `includeDeleted`  \n\n**성공 응답** (`200 OK`)  \n\n```json\n{\n    \"title\": \"React 소개\",\n    \"content\": \"React는 ...\",\n    \"metadata\": {\n        \"authorId\": \"u123\",\n        \"createdAt\": \"2024-02-01T12:34:56Z\",\n        \"updatedAt\": \"2024-02-10T08:20:00Z\",\n        \"version\": 3,\n        \"deleted\": false\n    }\n}\n```\n\n- **ETag** 헤더가 포함되어 낙관적 잠금에 활용됩니다.  \n- **캐시**: `Cache-Control: private, max-age=60`  \n\n**요약**  \nGET 은 `slug` 로 페이지를 조회하고, `preview`·`includeDeleted` 로 초안·삭제된 페이지 접근을 제어합니다. 성공 시 페이지 데이터와 메타데이터를 반환합니다.\n\n---\n\n### 4‑2. Wiki 페이지 생성 (POST)\n- **요청 URL**: `POST /api/wiki/{slug...}`  \n- **요청 헤더**: `Content-Type: application/json`  \n- **요청 바디**  \n\n```json\n{\n    \"title\": \"새 페이지 제목\",\n    \"content\": \"본문 내용\",\n    \"metadata\": {\n        \"tags\": [\"frontend\", \"react\"]\n    }\n}\n```\n\n- **자동 메타데이터**: 서버가 `authorId`(토큰에서 추출), `createdAt`, `updatedAt`, `version(=1)`, `deleted(false)` 를 삽입합니다.  \n\n**성공 응답** (`201 Created`)  \n\n- `Location` 헤더에 새 페이지 URL (`/api/wiki/{slug...}`) 제공  \n- 응답 본문에 생성된 리소스 전체 반환 (위 GET 응답과 동일 포맷)  \n\n**요약**  \nPOST 로 새 페이지를 만들 때 클라이언트는 `title`, `content`, 선택적 `metadata.tags` 만 제공하면 됩니다. 서버는 인증 토큰에서 사용자 정보를 추출해 메타데이터를 자동 채웁니다.\n\n---\n\n### 4‑3. Wiki 페이지 수정 (PUT / PATCH)\n- **요청 URL**: `PUT /api/wiki/{slug...}` (전체 교체) 또는 `PATCH /api/wiki/{slug...}` (부분 업데이트)  \n- **필수 헤더**: `If-Match: \"<ETag>\"` (버전 충돌 방지)  \n- **요청 바디** (예시)  \n\n```json\n{\n    \"title\": \"수정된 제목\",\n    \"content\": \"수정된 내용\",\n    \"metadata\": {\n        \"tags\": [\"updated\"]\n    }\n}\n```\n\n- **동시성 제어**: `If-Match` 값이 현재 `ETag` 와 일치하지 않으면 `409 Conflict` 반환.  \n\n**성공 응답** (`200 OK`)  \n\n```json\n{\n    \"title\": \"수정된 제목\",\n    \"content\": \"수정된 내용\",\n    \"metadata\": {\n        \"authorId\": \"u123\",\n        \"updatedAt\": \"2024-05-01T10:15:30Z\",\n        \"version\": 4,\n        \"deleted\": false\n    }\n}\n```\n\n**요약**  \nPUT/PATCH 는 `If-Match` 헤더를 통해 낙관적 잠금을 구현합니다. 전체 교체는 PUT, 부분 업데이트는 PATCH 로 구분됩니다.\n\n---\n\n### 4‑4. Wiki 페이지 삭제 (DELETE)\n- **요청 URL**: `DELETE /api/wiki/{slug...}`  \n- **쿼리 파라미터**: `mode=soft` (기본) 혹은 `mode=hard`  \n\n**동작**  \n- **soft**: `deleted` 플래그를 `true` 로 설정하고 `deletedAt` 타임스탬프 기록.  \n- **hard**: 데이터베이스에서 영구 삭제.  \n\n**성공 응답**  \n\n- **soft delete**: `204 No Content` (본문 없음)  \n- **hard delete**: `202 Accepted` 와 작업 ID 반환 (비동기 처리 시)  \n\n```json\n{\n    \"taskId\": \"del-20240501-abc123\",\n    \"status\": \"queued\"\n}\n```\n\n**요약**  \nDELETE 은 기본적으로 소프트 삭제를 수행합니다. `mode=hard` 를 지정하면 즉시 영구 삭제가 진행되며, 비동기 처리 시 202 응답과 작업 ID가 반환됩니다.\n\n---\n\n## 5. 요청·응답 예시\n### cURL 예시\n- **GET (preview 포함)**  \n\n```bash\ncurl -X GET \"https://api.example.com/api/wiki/technology/web/react?preview=true\" \\\n     -H \"Authorization: Bearer <token>\"\n```\n\n- **POST**  \n\n```bash\ncurl -X POST \"https://api.example.com/api/wiki/technology/web/react\" \\\n     -H \"Content-Type: application/json\" \\\n     -H \"Authorization: Bearer <token>\" \\\n     -d '{\"title\":\"React 소개\",\"content\":\"...\",\"metadata\":{\"tags\":[\"frontend\"]}}'\n```\n\n- **PATCH (ETag 사용)**  \n\n```bash\ncurl -X PATCH \"https://api.example.com/api/wiki/technology/web/react\" \\\n     -H \"Content-Type: application/json\" \\\n     -H \"Authorization: Bearer <token>\" \\\n     -H 'If-Match: \"W/\\\"3\\\"\"' \\\n     -d '{\"content\":\"업데이트된 내용\"}'\n```\n\n- **DELETE (hard)**  \n\n```bash\ncurl -X DELETE \"https://api.example.com/api/wiki/technology/web/react?mode=hard\" \\\n     -H \"Authorization: Bearer <token>\"\n```\n\n### JavaScript fetch 예시\n```javascript\n// GET with preview\nfetch('/api/wiki/technology/web/react?preview=true', {\n  method: 'GET',\n  headers: { 'Authorization': `Bearer ${token}` }\n})\n  .then(r => r.json())\n  .then(console.log);\n\n// POST new page\nfetch('/api/wiki/technology/web/react', {\n  method: 'POST',\n  headers: {\n    'Content-Type': 'application/json',\n    'Authorization': `Bearer ${token}`\n  },\n  body: JSON.stringify({\n    title: 'React 소개',\n    content: '...',\n    metadata: { tags: ['frontend'] }\n  })\n})\n  .then(r => r.json())\n  .then(console.log);\n```\n\n### 응답 JSON 샘플\n- **성공 (200)**  \n\n```json\n{\n    \"title\": \"React 소개\",\n    \"content\": \"React는 ...\",\n    \"metadata\": {\n        \"authorId\": \"u123\",\n        \"createdAt\": \"2024-02-01T12:34:56Z\",\n        \"updatedAt\": \"2024-05-01T10:15:30Z\",\n        \"version\": 4,\n        \"deleted\": false\n    }\n}\n```\n\n- **오류 (404)**  \n\n```json\n{\n    \"errorCode\": \"PAGE_NOT_FOUND\",\n    \"message\": \"Requested wiki page does not exist.\",\n    \"details\": { \"slug\": [\"technology\",\"web\",\"react\"] }\n}\n```\n\n---\n\n## 6. 오류 처리 및 상태 코드\n| 코드 | 의미 | 응답 예시 |\n|------|------|-----------|\n| **400** | 잘못된 요청(파라미터 누락·형식 오류) | `{ \"errorCode\":\"INVALID_REQUEST\", \"message\":\"Missing title.\", \"details\":{...} }` |\n| **401** | 인증 실패 | `{ \"errorCode\":\"UNAUTHORIZED\", \"message\":\"Invalid or missing token.\" }` |\n| **403** | 권한 부족 | `{ \"errorCode\":\"FORBIDDEN\", \"message\":\"Insufficient permissions.\" }` |\n| **404** | 페이지 미존재 | `{ \"errorCode\":\"PAGE_NOT_FOUND\", \"message\":\"...\", \"details\":{ \"slug\": [...] } }` |\n| **409** | 버전 충돌(If-Match 불일치) | `{ \"errorCode\":\"VERSION_CONFLICT\", \"message\":\"ETag mismatch.\", \"details\":{ \"currentVersion\":5 } }` |\n| **410** | 소프트 삭제된 페이지 접근 | `{ \"errorCode\":\"PAGE_GONE\", \"message\":\"Page has been soft‑deleted.\", \"details\":{ \"slug\": [...] } }` |\n| **500** | 서버 내부 오류 | `{ \"errorCode\":\"INTERNAL_ERROR\", \"message\":\"Unexpected error.\", \"details\":null }` |\n\n**권장 대응 방안**  \n\n- `400` → 파라미터 검증 로직 강화 (스키마 검증)  \n- `401/403` → 토큰 재발급·권한 재검토  \n- `409` → 최신 버전 조회 후 `If-Match` 재전송  \n- `410` → 복구 API(soft delete 복원) 사용 검토  \n- `500` → 로그 확인 후 운영팀에 보고  \n\n---\n\n## 7. 베스트 프랙티스\n- **Rate Limiting**: 1분당 60건 이하 요청 권장. 초과 시 `429 Too Many Requests` 반환.  \n- **재시도 전략**: 5xx 오류 시 지수 백오프 적용 (예: 100 ms → 200 ms → 400 ms).  \n- **데이터 검증**: 서버와 클라이언트 모두 Zod·Joi 등 스키마 검증 사용.  \n- **보안**  \n  - 입력값에 대한 **SQL/NoSQL 인젝션 방지** 및 **XSS sanitization** 적용.  \n  - CSRF 방지를 위해 `SameSite=Lax` 쿠키 또는 `X-CSRF-Token` 헤더 사용 권장.  \n\n**요약**  \n안정적인 서비스 운영을 위해 레이트 제한, 재시도 정책, 입력 검증, 그리고 CSRF·XSS 방어를 반드시 적용하십시오.\n\n---\n\n## 8. 테스트·샘플 코드\n### 로컬 개발 환경 설정\n1. `node` ≥ 18, `pnpm` 설치  \n2. 레포지토리 클론 후 `pnpm install` 실행  \n3. `.env.local`에 `NEXT_PUBLIC_API_BASE=/api` 등 환경 변수 설정  \n4. `pnpm dev` 로 개발 서버 실행 (`http://localhost:3000`)  \n\n### 통합 테스트 시나리오 예시\n| 시나리오 | 기대 결과 |\n|----------|-----------|\n| **GET 존재 페이지** | `200 OK` + 페이지 데이터 |\n| **GET 비존재 페이지** | `404 NOT FOUND` |\n| **POST 인증된 사용자** | `201 Created` + `Location` 헤더 |\n| **PUT 버전 충돌** (`If-Match` 불일치) | `409 CONFLICT` |\n| **DELETE soft** | `204 No Content` |\n| **DELETE hard** (비동기) | `202 Accepted` + 작업 ID |\n\n### Mock 서버 활용\n`msw`(Mock Service Worker) 로 `GET /api/wiki/*` 등 핸들러를 등록해 프론트엔드 테스트에 활용합니다.\n\n**요약**  \n위 절차대로 로컬 환경을 구성하고, 표에 제시된 시나리오를 자동화 테스트에 포함하면 API 구현 검증이 용이합니다.\n\n---\n\n## 9. 변경 로그 & 버전 관리\n| 날짜 | 버전 | 변경 내용 | 영향 |\n|------|------|-----------|------|\n| 2024-02-20 | v1.0.0 | 최초 문서 초안 작성 | 전체 가이드 제공 |\n| 2024-03-05 | v1.1.0 | 인증·인가 섹션에 JWT 상세 추가 | 보안 가이드 보강 |\n| 2024-04-12 | v1.2.0 | 오류 코드 표에 409·410 추가 | 개발자 오류 처리 개선 |\n| 2024-05-08 | v1.3.0 | 쿼리 파라미터(`preview`, `includeDeleted`, `mode`) 및 soft/hard delete 설명 추가 | 사용성 향상 |\n| 2026-02-27 | v1.4.0 | Next.js 라우팅 문서 업데이트 반영 (파일‑시스템 기반 라우팅, 레이아웃·페이지 파일 규칙) | 최신 Next.js 라우팅 개념과 일치 |\n\n**마이그레이션 가이드**  \n- 기존 `slug` 기반 경로는 그대로 유지됩니다.  \n- 삭제 옵션이 새롭게 `mode` 파라미터로 노출되므로, 기존 클라이언트는 기본 soft delete 동작에 영향이 없습니다.  \n- `preview` 와 `includeDeleted` 파라미터는 선택 사항이며, 기존 호출에 영향을 주지 않습니다.  \n\n---\n\n## 10. 참고 자료\n- **API 문서 작성 가이드라인** – 로버트의 가이드라인[[API 문서 작성을 위한 로버트의 가이드라인](https://koko8829.tistory.com/2496)]  \n- **Next.js App Router 문서** – 공식 문서([Next.js Docs – Routing](https://nextjs.org/docs/app/building-your-application/routing))  \n  *Next.js는 파일‑시스템 기반 라우팅을 사용합니다. `app` 디렉터리 아래에 `page.tsx`·`layout.tsx` 파일을 배치해 각각 페이지와 레이아웃을 정의하며, 폴더 구조가 URL 세그먼트를 결정합니다. 루트 레이아웃(`app/layout.tsx`)은 `html`·`body` 태그를 포함해야 하고, 중첩 레이아웃은 `children` prop을 통해 하위 페이지·레아웃을 감쌉니다.*  \n- **OAuth 2.0 표준** – RFC 6749([IETF RFC 6749](https://datatracker.ietf.org/doc/html/rfc6749))  \n- **JWT (JSON Web Token)** – RFC 7519([IETF RFC 7519](https://datatracker.ietf.org/doc/html/rfc7519))  \n\n> **주의**: 본 문서는 현재 확인 가능한 구현을 기반으로 작성되었습니다. 향후 코드 변경 시 해당 섹션을 업데이트하십시오.\n\n---\n\n## 11. Octrafic – 자연어 기반 API 테스트 도구\nOctrafic은 **plain English** 으로 API 테스트 시나리오를 작성하면, AI가 제공된 OpenAPI/Swagger 스펙을 기반으로 적절한 HTTP 요청을 자동 생성·실행하고 결과를 보고합니다. Wiki API 라우트에 대한 테스트 자동화를 손쉽게 구현할 수 있습니다.\n\n### 11‑1. 설치 방법\n| OS | 설치 명령 |\n|----|-----------|\n| **Linux / macOS** | `curl -fsSL https://octrafic.com/install.sh \\| bash` |\n| **Homebrew** | `brew install octrafic/tap/octrafic` |\n| **Windows (PowerShell)** | `iex (iwr -useb https://octrafic.com/install.ps1)` |\n\n> 설치 스크립트는 최신 릴리스를 자동으로 다운로드하고, 실행 파일을 사용자 PATH에 추가합니다.\n\n### 11‑2. 기본 사용 예시\n#### 1) 인터랙티브 TUI 로 테스트 작성\n```bash\noctrafic -u https://api.example.com -s openapi.json -n \"Wiki API\"\n```\n- `-u` : API 기본 URL  \n- `-s` : OpenAPI 스펙 파일 경로 (`app/api/wiki/[...slug]/route.ts` 를 포함한 스펙)  \n- `-n` : 프로젝트 이름  \n\nTUI가 시작되면 자연어로 테스트를 입력합니다.\n\n```\ntest the GET endpoint for /api/wiki/technology/web/react with preview=true\ntest creating a new wiki page at /api/wiki/technology/web/react\ntest updating the title of /api/wiki/technology/web/react\ntest deleting the page with mode=hard\n```\n\nOctrafic는 각각에 대해 **HTTP 메서드, URL, 헤더, 본문**을 자동 생성·실행합니다. 성공/실패 결과와 응답 본문을 바로 확인할 수 있습니다.\n\n#### 2) 비‑인터랙티브 모드 (CI/CD용)\n```bash\noctrafic test \\\n  --url https://api.example.com \\\n  --spec openapi.json \\\n  --prompt \"test all CRUD operations on /api/wiki/*\" \\\n  --auth bearer --token $API_TOKEN\n```\n- `--prompt` 로 한 줄 설명만 제공하면 전체 테스트를 자동 생성·실행합니다.  \n- 모든 테스트가 통과하면 명령은 `0`을 반환하고, 하나라도 실패하면 `1`을 반환합니다.\n\n### 11‑3. CI / 파이프라인 적용\n#### GitHub Actions 예시\n```yaml\nname: API 테스트\non: [push, pull_request]\n\njobs:\n  test-wiki-api:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - name: Install Octrafic\n        run: curl -fsSL https://octrafic.com/install.sh | bash\n      - name: Run Wiki API tests\n        env:\n          API_TOKEN: ${{ secrets.API_TOKEN }}\n        run: |\n          octrafic test \\\n            --url ${{ secrets.API_URL }} \\\n            --spec ./openapi.json \\\n            --auth bearer \\\n            --token ${{ secrets.API_TOKEN }}\n```\n\n#### Jenkins 파이프라인 스니펫\n```groovy\nstage('Octrafic API Tests') {\n    steps {\n        sh '''\n            curl -fsSL https://octrafic.com/install.sh | bash\n            octrafic test \\\n                --url $API_URL \\\n                --spec openapi.json \\\n                --auth bearer \\\n                --token $API_TOKEN\n        '''\n    }\n}\n```\n\n### 11‑4. 인증 옵션\nOctrafic은 다양한 인증 방식을 지원합니다. Wiki API가 JWT Bearer 토큰을 사용하므로 아래와 같이 전달합니다.\n\n```bash\noctrafic -u https://api.example.com -s openapi.json \\\n  --auth bearer --token \"your-jwt-token\"\n```\n\n환경 변수 활용도 가능해 쉘 히스토리에 토큰이 남지 않게 할 수 있습니다.\n\n```bash\nexport OCTRAFIC_AUTH_TYPE=bearer\nexport OCTRAFIC_AUTH_TOKEN=your-jwt-token\noctrafic -u https://api.example.com -s openapi.json\n```\n\n### 11‑5. 테스트 내보내기\n- **Postman**: `export these tests to postman`  \n- **Shell script**: `export tests as a shell script`  \n- **Python pytest**: `export to pytest and name it test_wiki_api.py`\n\n내보낸 파일은 기본적으로 `~/Documents/octrafic/tests/` 에 저장됩니다. 필요 시 CI 단계에서 미리 생성된 테스트 파일을 실행할 수 있습니다.\n\n### 11‑6. 주요 장점\n- **생산성**: 테스트 스크립트를 직접 코딩할 필요 없이 자연어로 작성.  \n- **일관성**: OpenAPI 스펙과 동기화돼 스펙 변경 시 자동 반영.  \n- **CI 친화적**: 비‑인터랙티브 모드와 명령 반환값을 활용해 파이프라인에서 테스트 성공 여부를 판단.  \n- **다양한 LLM 지원**: Claude, OpenAI, OpenRouter, Gemini, Ollama, llama.cpp 등 선택 가능. 로컬 모델(`ollama pull qwen2.5:7b`)을 사용하면 외부 API 키 없이도 동작합니다.\n\n---\n\n## 12. 기타 참고\n- **Octrafic GitHub**: https://github.com/Octrafic/octrafic-cli  \n- **Octrafic 문서**: https://docs.octrafic.com  \n- **Octrafic 설치 스크립트**: https://octrafic.com/install.ps1  \n\n---",
  "lastModified": "2026-02-28T18:06:35Z",
  "author": "SEPilot AI",
  "status": "published",
  "isDraft": false,
  "isInvalid": false,
  "tags": [
    "API",
    "Wiki",
    "라우트",
    "인증",
    "문서화"
  ],
  "order": 1,
  "history": [
    {
      "sha": "c054f50",
      "message": "chore: 뉴스 인텔리전스 보고서 업데이트",
      "author": "GitHub Action",
      "authorEmail": "action@github.com",
      "date": "2026-02-28T18:06:35Z",
      "isAutoCommit": false,
      "additions": 0,
      "deletions": 0
    }
  ]
}